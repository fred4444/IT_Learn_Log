<!doctype html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0,minimum-scale=1.0,user-scalable=0" />
		<title>Linux</title>
		<style>
			.class___line_head {
				margin-left : 2em;
			}
			.class___tab_place {
				margin-left : 2em;
			}
			.class___center {
				text-align : center;
				width : 100%;
				display : inline-block;
			}
			.shell_instruction {
				color : yellow;
				background-color : black;
				font-weight : 800;
				padding : 4px;
			}
			section > p {
				padding-left : 2em;
				line-height : 180%;
			}
			section > div {
				padding-left : 2em;
				line-height : 180%;
			}
		</style>
		<script>
		</script>
	</head>
	<body>
		<article>
			<header>
				<h3>Linux</h3>
				<p>
					Linux spread log.
				</p>
			</header>
			<section>
				<h3>设置分区的标签</h3>
				<p>
					#ext2/ext3/ext4
					<br/>
					<span class="shell_instruction">e2label [&lt;device&gt;] [&lt;new_label&gt;]</span>
					<br/>
					#xfs
					<br/>
					<span class="shell_instruction">xfs_admin -L [&lt;new_label&gt;] [&lt;device&gt;]</span>
					<br/>
					#jfs
					<br/>
					<span class="shell_instruction">jfs_tune -L [&lt;new_label&gt;] [&lt;device&gt;]</span>
					<br/>
					#Btrfs
					<br/>
					<span class="shell_instruction">btrfs filesystem label [&lt;device&gt;] [&lt;new_label&gt;]</span>
					<br/>
					#or
					<br/>
					<span class="shell_instruction">btrfs-filesystem label [&lt;device&gt;|&lt;mountpoint&gt;] [&lt;new_label&gt;]</span>
					<br/>
					#ReiserFS
					<br/>
					<span class="shell_instruction">reiserfstune -l [&lt;new_label&gt;] [&lt;device&gt;]</span>
					<br/>
					#swap
					<br/>
					<span class="shell_instruction">mkswap -L [&lt;new_label&gt;] [&lt;device&gt;]</span>
					<br/>
					#ntfs
					<br/>
					<span class="shell_instruction">ntfslabel [&lt;device&gt;] [&lt;new_label&gt;]</span>
					<br/>
					#for example set sda5 label is home
					<br/>
					<span class="shell_instruction">ntfslabel /dev/sda7 home</span>
				</p>
			</section>
			<section>
				<h3>添加和删除用户</h3>
				<p>
					#添加用户angular4
					<br/>
					<span class="shell_instruction">adduser angular4</span>
					<br/>
					#添加用户组angular
					<br/>
					<span class="shell_instruction">groupadd angular</span>
					<br/>
					#设置用户angular4所在组为angular
					<br/>
					<span class="shell_instruction">usermod -g angular angular4</span>
					<br/>
					<br/>

					#查看用户组
					<br/>
					<span class="shell_instruction">vim /etc/group</span>
					<br/>
					#删除用户组
					<br/>
					<span class="shell_instruction">groupdel angular</span>
					<br/>
					<span class="shell_instruction">groupdel angular4</span>
					<br/>
					#删除用户
					<br/>
					<span class="shell_instruction">userdel angular4</span>
					<br/>
					<span class="shell_instruction">rm -rf /home/angular4</span>
					<br/>
					#if add this user again will got error
					<br/>
					#Creating mailbox file: File exists
					<br/>
					<span class="shell_instruction">find / -name angular4</span>
					<br/>
					#the result include /var/spool/mail/angular4
					<br/>
					<span class="shell_instruction">rm -rf /var/spool/mail/angular4</span>
					<br/>
					<br/>

					#set user password
					<br/>
					<span class="shell_instruction">passwd angular4</span>
					<br/>
					<br/>

					#delete user password
					<br/>
					<span class="shell_instruction">passwd -d angular4</span>
				</p>
			</section>
			<section>
				<h3>change run level</h3>
				<p>
					#before CentOS 7 is change /etc/inittab file, but from CentOS 7 is no longer use this, the new run level is in /usr/lib/systemd/system/*.target
					<br/>
					#see current run level
					<br/>
					<span class="shell_instruction">systemctl list-units --type=target</span>
					<br/>
					#change run level to 3 level is
					<br/>
					<span class="shell_instruction">systemctl isolate multi-user.target</span>
					<br/>
					#change default run level to 3 level is
					<br/>
					<span class="shell_instruction">systemctl set-default multi-user.target</span>
					<br/>
					#old run level with new target relation is
					<br/>
					<span style="color : blue">
						runlevel0.target -&gt; poweroff.target
						<br/>
						runlevel1.target -&gt; rescue.target
						<br/>
						runlevel2.target -&gt; multi-user.target
						<br/>
						runlevel3.target -&gt; multi-user.target
						<br/>
						runlevel4.target -&gt; multi-user.target
						<br/>
						runlevel5.target -&gt; graphical.target
						<br/>
						runlevel6.target -&gt; reboot.target
					</span>
					<br/>
					#can use the follow instruction to see all the target
					<br/>
					<span class="shell_instruction">ls -lh /usr/lib/systemd/system/*.target</span>
				</p>
			</section>
			<section>
				<h3>CentOS 7 suspend and hibernate</h3>
				<div>
					<span class="shell_instruction">systemctl suspend</span>
					<br/>
					<span class="shell_instruction">systemctl hibernate</span>
				</div>
			</section>
			<section>
				<h3>open port in iptabls or firewalld</h3>
				<p>
					#iptables is(in CentOS 7 not use this):
					<br/>
					#add a data receive rule
					<br/>
					<span class="shell_instruction">iptables -A INPUT -p tcp --dport 22 -j ACCEPT</span>
					<br/>
					#add a data post rule
					<br/>
					<span class="shell_instruction">iptables -A OUTPUT -p tcp --sport 22 -j ACCEPT</span>
					<br/>
					#restart iptables service
					<br/>
					<span class="shell_instruction">service sshd restart</span>
					<br/>
					<br/>

					#firewalld is(in CentOS 7 use this):
					<br/>
					#add a rule, with option parameter --permanent to persistent the rule
					<br/>
					<span class="shell_instruction">firewall-cmd --permanent --add-port=22/tcp</span>
					<br/>
					#restart firewalld service
					<br/>
					<span class="shell_instruction">systemctl restart firewalld</span>
					<br/>
					#ensure the new rule is active
					<br/>
					<span class="shell_instruction">firewall-cmd --query-port=22/tcp</span>
					<br/>
				</p>
			</section>
			<section>
				<h3>set sshd service start with OS boot and start at now</h3>
				<p>
					#query ssdh service status
					<br/>
					<span class="shell_instruction">systemctl status sshd</span>
					<br/>
					#output the follow information
					<br/>
					<span style="color : blue">
					● sshd.service - OpenSSH server daemon
					<br/>
					&nbsp;&nbsp;&nbsp;Loaded: loaded (/usr/lib/systemd/system/sshd.service; disabled; vendor preset: enabled)
					<br/>
					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Active: inactive (dead)
					<br/>
				    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Docs: man:sshd(8)
					<br/>
				    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;man:sshd_config(5)
					</span>
					<br/>
					#so we see the Loaded: loaded (/usr/lib/systemd/system/sshd.service; disabled; vendor preset: enabled)
					<br/>
					#the service is not start with OS boot, so we set it start with OS boot
					<br/>
					<span class="shell_instruction">systemctl enable sshd</span>
					<br/>
					#we also see Active: inactive (dead), that means the service is not run at current time, we start it at now
					<br/>
					<span class="shell_instruction">systemctl start sshd</span>
					<br/>
				</p>
			</section>
			<section>
				<h3>git server via ssh</h3>
				<p>
					#in server
					<br/>
					#use vim edit sshd_config file
					<br/>
					#find "Port 22", in the line head delete "#" to enable this configuration item
					<br/>
					#find "Protocol 2", in the line head delete "#" to enable this configuration item
					<br/>
					#find "PubkeyAuthentication yes", in the line head delete "#" to enable this configuration item
					<br/>
					#find "AuthorizedKeysFile  .ssh/authorized_keys", in the line head delete "#" to enable this configuration item
					<br/>
					#create a user name is git
					<br/>
					<span class="shell_instruction">adduser git</span>
					<br/>
					#set git user password
					<br/>
					<span class="shell_instruction">passwd git</span>
					<br/>
					#change to git user
					<br/>
					<span class="shell_instruction">su git</span>
					<br/>
					#change path to git user home path
					<br/>
					<span class="shell_instruction">cd ~</span>
					<br/>
					#create a empty git bare repository, repository_name is the new repository name
					<br/>
					<span class="shell_instruction">git init --bare repository_name.git</span>
					<br/>
					#if .ssh folder not exist then create .ssh folder
					<br/>
					<span class="shell_instruction">mkdir .ssh</span>

					<br/>
					<br/>
					#in client
					<br/>
					#create ssh key, after -C is comment
					<br/>
					<span class="shell_instruction">ssh-keygen -t rsa -C client_user_name</span>
					<br/>
					#change path to .ssh path
					<br/>
					<span class="shell_instruction">cd ~/.ssh</span>
					<br/>
					#copy id_rsa.pub file to server, git is server username, 192.168.1.110 is server ip
					<br/>
					<span class="shell_instruction">scp id_rsa.pub git@192.168.1.110:id_rsa.pub</span>

					<br/>
					<br/>
					#in server
					<br/>
					#export the client id_rsa.pub file content to ~/.ssh/authorized_keys file
					<br/>
					<span class="shell_instruction">cd ~</span>
					<br/>
					<span class="shell_instruction">cat id_rsa.pub &gt;&gt; .ssh/authorized_keys</span>
					<br/>
					#set git user ssh only use git shell, edit /etc/passwd file
					<br/>
					<span class="shell_instruction">vim /etc/passwd</span>
					<br/>
					#change
					<br/>
					<span style="color : blue;">git:x:1001:1001::/home/git:/bin/bash</span>
					<br/>
					#to
					<br/>
					<span style="color : blue;">git:x:1001:1001::/home/git:/usr/bin/git-shell</span>
					<br/>
					#if you don't want input git user's login password do the next two step
					<br/>
					#change .ssh authority
					<br/>
					<span class="shell_instruction">chmod 700 ~/.ssh</span>
					<br/>
					#change .ssh/authorized_keys authority
					<br/>
					<span class="shell_instruction">chmod 600 ~/.ssh/authorized_keys</span>


					<br/>
					<br/>
					#in client
					<br/>
					#clone the new repository from server
					<br/>
					<span class="shell_instruction">git clone git@192.168.1.110:repository_name.git</span>
				</p>
			</section>
			<section>
				<h3>git server</h3>
				<p>
					//install git and git-daemon
					<br/>
					<br/>
					//generate rsa key pair with the follow instruct
					<br/>
					<span class="shell_instruction">ssh-keygen -t rsa -C comment</span>
					<br/>
					<br/>
					//create a empty file in ~/.ssh/
					<br/>
					<span class="shell_instruction">cd ~/.ssh/</span>
					<br/>
					<span class="shell_instruction">touch authorized_keys</span>
					<br/>
					<br/>
					//export rsa public key file content to authorized_keys file
					<br/>
					<span class="shell_instruction">cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span>
					<br/>
					//note : every client need export the res public key file content to the server's authorized_keys
					<br/>
					<br/>
					//set sshd server
					<br/>
					<span class="shell_instruction">cd /etc/ssh</span>
					<br/>
					//use vim edit sshd_config file
					<br/>
					//find "Port 22", in the line head delete "#" to enable this configuration item
					<br/>
					//find "Protocol 2", in the line head delete "#" to enable this configuration item
					<br/>
					//find "PubkeyAuthentication yes", in the line head delete "#" to enable this configuration item
					<br/>
					//find "AuthorizedKeysFile  .ssh/authorized_keys", in the line head delete "#" to enable this configuration item
					<br/>
					<br/>
					//restart sshd server
					<br/>
					<span class="shell_instruction">service sshd restart</span>
					<br/>
					<br/>
					//use mkdir to crate a folder as the git repository
					<br/>
					<span class="shell_instruction">mkdir git_base</span>
					<br/>
					<span class="shell_instruction">cd git_base</span>
					<br/>
					<br/>
					//initialization a git repository,the repositoy_name is your project name, create a empty file
					<br/>
					<span class="shell_instruction">git init --bare repository_name.git</span>
					<br/>
					<span class="shell_instruction">touch repositoy_name.git/git-daemon-export-ok</span>
					<br/>
					<br/>
					//start git protocol sever
					<br/>
					<span class="shell_instruction">git daemon --reuseaddr --base-path=~/git_base</span>
					<br/>
					<br/>

					//in client clone the project code
					<br/>
					//the format is git clone http://username:password@127.0.0.1/repositoy_name.git
					<br/>
					<span class="shell_instruction">git clone git://127.0.0.1/repositoy_name.git</span>
					<br/>
					//or
					<br/>
					<span class="shell_instruction">git clone username@localhost:/repositoy_name.git</span>
					<br/>
				</p>
			</section>
			<section>
				<h3>双系统, 修复windows启动项</h3>
				<p>
					修改/boot/grub2/grub.cfg
					<br/>
					找到在两个menuentry末尾添加一个win7启动设置，具体参数是
					<br/>
					menuentry	‘win7’{
						<br/>
						<span class="class___tab_place"></span>set root=(hd0,1)
						<br/>
						<span class="class___tab_place"></span>chainloader +1 
						<br/>
					}
				</p>
			</section>
			<section>
				<h3>关闭触控板</h3>
				<p>
					synclient touchpadoff=1
				</p>
			</section>
			<section>
				<h3>清屏命令</h3>
				<p>
					<span class="shell_instruction">clear</span>
					<br/>
					or
					<br/>
					ctrl + l
					<br/>
					刷新屏幕，本质上只是让终端显示页向后翻了一页，如果向上滚动屏幕还可以看到之前的操作信息。
				</p>
				<p>
					<span class="shell_instruction">reset</span>
					<br/>
					完全刷新终端屏幕，之前的终端输入操作信息将都会被清空，这样虽然比较清爽，但整个命令过程速度有点慢，使用较少。
					<br/>
					值得一提的是reset命令在你的终端控制错乱时非常有用。如输入字符不出现在光标的位置的情况。还有当你敲击回车键时，新提示符并没有出现在新行上而是出现在老提示符的前面。此时reset命令就能用来修正这些问题。
				</p>
				<p>
					<span class="shell_instruction">printf '\033c'</span>
					<br/>
					真正的清空了终端屏幕，它的功能跟DOS里CMD.EXE提供的CLS效果很相似。
					<br/>
					工作原理是
					<br/>
					\033  ==  \x1B == 27 == ESC
					<br/>
					于是，这个命令变成了<ESC>c，它是VT-XXX中表示“Full Reset (RIS)”的转义码。现今我们使用的所有的终端都是VT兼容的，它的另一种实现方式也可以这样：
					<br/>
					键盘上Ctrl+v--->Esc-->输入c再回加。但如果你发现自己使用的是一个非常奇怪的终端（如在putty上），那这个命令你可能用不了。
					<br/>
					 printf是bash里内置的命令，内置命令的优先级比其它可执行文件要高。
				</p>
			</section>
			<section>
				<h3>操作目录命令</h3>
				<p>
					回到刚才的目录
					<br/>
					<span class="shell_instruction">cd -</span>
				</p>
				<p>
					目录压栈
					<br/>
					<span class="shell_instruction">pushd .</span>
				</p>
				<p>
					目录出栈
					<br/>
					<span class="shell_instruction">popd</span>
				</p>
			</section>
			<section>
				<h3>查看内存</h3>
				<p>
					<span class="shell_instruction">free</span>
				</p>
			</section>
			<section>
				<h3>帮助,查找命令</h3>
				<p>
					<span class="shell_instruction">man -k key_word</span>
					<br/>
					-k : 列出包含在下一个参数中的字符的命令
				</p>
			</section>
			<section>
				<h3>生成ssh协议秘钥</h3>
				<p>
					use ssh-keygen instruction
				</p>
				<p>
					<span class="shell_instruction">ssh-keygen -t rsa -C email@domain</span>
					<br/>
					-t : 在下一个参数中指定加密算法
					<br/>
					-C : 在下一个参数中指定注释
				</p>
			</section>
			<section>
				<h3>encrypt and decrypt file with symmetric algorithm(文件加密解密使用对称算法)</h3>
				<p>
					use openssl, encrypt file by the follow instruction
				</p>
				<p>
					<span class="shell_instruction">openssl enc -des3 -a -salt -in source_file -out target_file [-pass password]</span>
					<br/>
					-des3 : 为加密算法(可以根据自己需要选择).
					<br/>
					-a : 对加密后的数据进行base64编码，或解密前，先对数据进行base64解码.
					<br/>
					-salt : 加盐,这是一个神奇的选项，加盐后，相同的明文可以得到不同的密文。默认情况下，盐值是随机生成的，可以使用-S选项明确指定盐值.
					<br/>
					-in : 在下一个参数中指定要加密的源文件.
					<br/>
					-out : 在下一个参数中指定加密后的文件.
					<br/>
					-pass : 在下一个参数中指定密码, 不加此参数则会在运行时等待用户输入密码,并以*号显示.
				</p>
				<p>
					use openssl, decrypt file by the follow instruction
				</p>
				<p>
					<span class="shell_instruction">openssl enc -d -des3 -a -salt -in source_file -out target_file [-pass password]</span>
					<br/>
					-d : 解密.
					<br/>
					-des3 : 为加密算法(可以根据自己需要选择).
					<br/>
					-a : 对加密后的数据进行base64编码，或解密前，先对数据进行base64解码.
					<br/>
					-salt : 加盐,这是一个神奇的选项，加盐后，相同的明文可以得到不同的密文。默认情况下，盐值是随机生成的，可以使用-S选项明确指定盐值.
					<br/>
					-in : 在下一个参数中指定要加密的源文件.
					<br/>
					-out : 在下一个参数中指定加密后的文件.
					<br/>
					-pass : 在下一个参数中指定密码, 不加此参数则会在运行时等待用户输入密码,并以*号显示.
				</p>
			</section>
		</article>
	</body>
</html>
