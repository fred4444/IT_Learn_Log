<!doctype html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0,minimum-scale=1.0,user-scalable=0" />
		<title>Linux</title>
		<style>
			.class___line_head {
				margin-left : 2em;
			}
			.class___tab_place {
				margin-left : 2em;
			}
			.class___center {
				text-align : center;
				width : 100%;
				display : inline-block;
			}
			.shell_instruction {
				color : yellow;
				background-color : black;
				font-weight : 800;
				padding : 4px;
			}
			section > p {
				padding-left : 2em;
				line-height : 180%;
			}
			section > div {
				padding-left : 2em;
				line-height : 180%;
			}
			.class___copy_other_people_content {
				background-color : #aef5a8;
			}
		</style>
		<script>
		</script>
	</head>
	<body>
		<article>
			<header>
				<h3>Linux</h3>
				<p>
					Linux spread log.
				</p>
			</header>
			<section>
				<h3>修改用户账号, 如锁定解锁等The usermod command modifies the system account files to reflect the changes that are specified on the command line</h3>
				<div>
					当用户密码输入错误次数过多时用户会被锁定
					<br/>
					解锁用户密码
					<br/>
					<span class="shell_instruction">usermod -U username</span>
					<br/>
					锁定用户密码
					<br/>
					<span class="shell_instruction">usermod -U username</span>
				</div>
			</section>
			<section>
				<h3>systemctl</h3>
				<div>
					<a target="_blank" href="https://www.cnblogs.com/zwcry/p/9602756.html">linux systemctl 指令 —— 阮一峰 - 七脉 - 博客园</a>
				</div>
			</section>
			<section>
				<h3>/etc/fstab指定分区大小</h3>
				<div>
					tmpfs /dev/shm tmpfs defaults,size=4096M 0 0
					<br/>
					其中size=4096M 为4096MB
				</div>
			</section>
			<section>
				<h3>U盘写入文件Read-only file system错误</h3>
				<div>
					可以查看/proc/mounts文件是否U盘挂载为只读, 若有参数ro则为只读, rw为读写
					<br/>
					用如下命令重新挂载即可
					<br/>
					<span class="shell_instruction">mount -o remount -rw  usb_path/</span>
					<br/>
					其中usb_path/为U盘的挂载路径, -rw为读写
				</div>
			</section>
			<section>
				<h3>查看指定路径的man文件</h3>
				<p>
					<span class="shell_instruction">man -l &lt;filepath&gt;</span>
					<br/>
					or
					<br/>
					<span class="shell_instruction">man --local-file &lt;filepath&gt;</span>
					<br/>
					用
					<span class="shell_instruction">man man</span>
					<br/>
					查看man自身的帮助手册, 其中的参数信息如下
					<br/>
					-l, --local-file
					<br/>
Activate `local' mode.  Format and display local manual files instead of searching through the system's manual collection.  Each manual page argument will be interpreted as  an  nroff  source file  in the correct format.  No cat file is produced.  If '-' is listed as one of the arguments, input will be taken from stdin.  When this option is not used, and man fails to find the page required, before displaying the error message, it attempts to act as if this option was supplied, using the name as a filename and looking for an exact match.
				</p>
			</section>
			<section>
				<h3>tar過濾部分文件打包</h3>
				<p>
					<a target="_blank" href="refs/tar__exclude_file.pdf">參考文檔</a>
				</p>
			</section>
			<section>
				<h3>查看Linux内核版本的命令</h3>
				<p>
					<span class="shell_instruction">uname -a</span>
					<br/>
					查看系统内核版本号及系统名称
					<br/>
					or
					<br/>
					<span class="shell_instruction">cat /proc/version</span>
					<br/>
					查看目录"/proc"下version的信息，也可以得到当前系统的内核版本号及系统名称
					<br/>
					补充说明:/proc文件系统，它不是普通的文件系统，而是系统内核的映像，也就是说，该目录中的文件是存放在系统内存之中的，它以文件系统的方式为访问系统内核数 据的操作提供接口。而我们使用命令“uname -a"的信息就是从该文件获取的，当然用方法二的命令直接查看它的内容也可以达到同等效果.另外，加上参数"a"是获得详细信息，如果不加参数为查看系统名称。
				</p>
			</section>
			<section>
				<h3>關機及重啟</h3>
				<p>
					關機
					<br/>
					<span class="shell_instruction">poweroff</span>
					<br/>
					or
					<br/>
					<span class="shell_instruction">shutdown -P now</span>
					<br/>
					or
					<br/>
					<span class="shell_instruction">shutdown -h now</span>
					<br/>
					或參考
					<br/>
					<span class="shell_instruction">man shutdown</span>
					<br/>
					10分鐘後關機
					<br/>
					<span class="shell_instruction">shutdown -h +10</span>
					<br/>
					18:30關機
					<br/>
					<span class="shell_instruction">shutdown -h 18:30</span>
					<br/>

					
					<br/>
					<br/>
					重啟
					<br/>
					<span class="shell_instruction">reboot</span>
					<br/>
					or
					<br/>
					<span class="shell_instruction">shutdown -r now</span>
					<br/>
					或參考
					<br/>
					<span class="shell_instruction">man shutdown</span>
					<br/>
					10分鐘後重啟
					<br/>
					<span class="shell_instruction">shutdown -r +10</span>
					<br/>
					18:30重啟
					<br/>
					<span class="shell_instruction">shutdown -r 18:30</span>
				</p>
			</section>
			<section>
				<h3>ctrl+z(挂起),jobs(任务),fg(前台),bg(后台),kill(终止进程)</h3>
				<p>
					ctrl+z
					<br/>
					ctrl+z挂起前台命令暂停执行，回到shell命令行环境中
				</p>
				<p>
					jobs
					<br/>
					察看当前shell下运行的所有程序；带+表示最新的jobs；带-表示次新的jobs；其他jobs不带符号
				</p>
				<p>
					bg %n
					<br/>
					将第n个job放到后台运行
				</p>
				<p>
					bg
					<br/>
					将最后挂起的命令放到后台运行
				</p>
				<p>
					fg %n
					<br/>
					将第n个job返回前台运行
				</p>
				<p>
					fg
					<br/>
					将最后挂起的命令返回前台运行
				</p>
				<p>
					kill %n
					<br/>
					杀死第n个job，不再执行
				</p>
			</section>
			<section>
				<h3>创建iso文件</h3>
				<p>
					use mkisofs create iso file
				</p>
				<p>
					<span class="shell_instruction">mkisofs -r -o mongodb_linux_x86_64_4.0.7.iso mongodb_linux_x86_64_4.0.7.tgz</span>
					<br/>
					-r : 设置所有文件拥有读取权限
					<br/>
					-o : 在后面指定输出的iso文件的路径及文件名
				</p>
				<p>
					use dd copy device content to file
				</p>
				<p>
					<span class="shell_instruction">dd if=/dev/cdrom of=vcd.iso</span>
					<br/>
					if : 数据源块路径
					<br/>
					of : 输出文件的路径及文件名
				</p>
			</section>
			<section>
				<h3>查看系统配置信息</h3>
				<div>
					#硬件信息
					<br/>
					dmidecode
					<br/>
					#模块信息
					<br/>
					dmesg
					<br/>
					#查看分区信息如uuid等
					<br/>
					blkid
					<br/>
					#查看外存及分区信息
					<br/>
					lsblk
					<br/>
					#查看usb设备
					<br/>
					lsusb
				</div>
			</section>
			<section>
				<h3>设置分区的标签</h3>
				<p>
					#ext2/ext3/ext4
					<br/>
					<span class="shell_instruction">e2label [&lt;device&gt;] [&lt;new_label&gt;]</span>
					<br/>
					#xfs
					<br/>
					<span class="shell_instruction">xfs_admin -L [&lt;new_label&gt;] [&lt;device&gt;]</span>
					<br/>
					#jfs
					<br/>
					<span class="shell_instruction">jfs_tune -L [&lt;new_label&gt;] [&lt;device&gt;]</span>
					<br/>
					#Btrfs
					<br/>
					<span class="shell_instruction">btrfs filesystem label [&lt;device&gt;] [&lt;new_label&gt;]</span>
					<br/>
					#or
					<br/>
					<span class="shell_instruction">btrfs-filesystem label [&lt;device&gt;|&lt;mountpoint&gt;] [&lt;new_label&gt;]</span>
					<br/>
					#ReiserFS
					<br/>
					<span class="shell_instruction">reiserfstune -l [&lt;new_label&gt;] [&lt;device&gt;]</span>
					<br/>
					#swap
					<br/>
					<span class="shell_instruction">mkswap -L [&lt;new_label&gt;] [&lt;device&gt;]</span>
					<br/>
					#ntfs
					<br/>
					<span class="shell_instruction">ntfslabel [&lt;device&gt;] [&lt;new_label&gt;]</span>
					<br/>
					#for example set sda5 label is home
					<br/>
					<span class="shell_instruction">ntfslabel /dev/sda7 home</span>
				</p>
			</section>
			<section>
				<h3>添加和删除用户</h3>
				<p>
					#添加用户angular4
					<br/>
					<span class="shell_instruction">adduser angular4</span>
					<br/>
					#添加用户组angular
					<br/>
					<span class="shell_instruction">groupadd angular</span>
					<br/>
					#设置用户angular4所在组为angular
					<br/>
					<span class="shell_instruction">usermod -g angular angular4</span>
					<br/>
					<br/>

					#查看用户组
					<br/>
					<span class="shell_instruction">vim /etc/group</span>
					<br/>
					#删除用户组
					<br/>
					<span class="shell_instruction">groupdel angular</span>
					<br/>
					<span class="shell_instruction">groupdel angular4</span>
					<br/>
					#删除用户
					<br/>
					<span class="shell_instruction">userdel angular4</span>
					<br/>
					<span class="shell_instruction">rm -rf /home/angular4</span>
					<br/>
					#if add this user again will got error
					<br/>
					#Creating mailbox file: File exists
					<br/>
					<span class="shell_instruction">find / -name angular4</span>
					<br/>
					#the result include /var/spool/mail/angular4
					<br/>
					<span class="shell_instruction">rm -rf /var/spool/mail/angular4</span>
					<br/>
					<br/>

					#set user password
					<br/>
					<span class="shell_instruction">passwd angular4</span>
					<br/>
					<br/>

					#delete user password
					<br/>
					<span class="shell_instruction">passwd -d angular4</span>
				</p>
			</section>
			<section>
				<h3>change run level</h3>
				<p>
					#before CentOS 7 is change /etc/inittab file, but from CentOS 7 is no longer use this, the new run level is in /usr/lib/systemd/system/*.target
					<br/>
					#see current run level
					<br/>
					<span class="shell_instruction">systemctl list-units --type=target</span>
					<br/>
					#change run level to 3 level is
					<br/>
					<span class="shell_instruction">systemctl isolate multi-user.target</span>
					<br/>
					#change default run level to 3 level is
					<br/>
					<span class="shell_instruction">systemctl set-default multi-user.target</span>
					<br/>
					#old run level with new target relation is
					<br/>
					<span style="color : blue">
						runlevel0.target -&gt; poweroff.target
						<br/>
						runlevel1.target -&gt; rescue.target
						<br/>
						runlevel2.target -&gt; multi-user.target
						<br/>
						runlevel3.target -&gt; multi-user.target
						<br/>
						runlevel4.target -&gt; multi-user.target
						<br/>
						runlevel5.target -&gt; graphical.target
						<br/>
						runlevel6.target -&gt; reboot.target
					</span>
					<br/>
					#can use the follow instruction to see all the target
					<br/>
					<span class="shell_instruction">ls -lh /usr/lib/systemd/system/*.target</span>
				</p>
			</section>
			<section>
				<h3>CentOS 7 suspend and hibernate</h3>
				<div>
					<span class="shell_instruction">systemctl suspend</span>
					<br/>
					equal
					<br/>
					<span class="shell_instruction">echo "mem" &gt; /sys/power/state</span>
					<br/>
					<br/>
					<span class="shell_instruction">systemctl hibernate</span>
					<br/>
					equal
					<br/>
					<span class="shell_instruction">echo "disk" &gt; /sys/power/state</span>
					<br/>
					参考内容:
					<br/>
					<a target="_blank" href="http://www.wowotech.net/linux_kenrel/suspend_and_resume.html">Linux电源管理(6)_Generic PM之Suspend功能</a>
					<a target="_blank" href="https://blog.csdn.net/feifei_csdn/article/details/80831373">【sys/power】freeze、standby、mem、disk四个电源状态_勿于浮沙筑高台-CSDN博客</a>
					<div class="class___copy_other_people_content" style="white-space : pre;">
System Power Management Sleep States

(C) 2014 Intel Corp., Rafael J. Wysocki <rafael.j.wysocki@intel.com>

The kernel supports up to four system sleep states generically（一般）, although three
of them depend on the platform support code to implement（实行） the low-level details
for each state.

The states are represented by strings that can be read or written to the
/sys/power/state file.  Those strings may be "mem", "standby", "freeze" and
"disk", where the last three always represent(代表) Power-On Suspend (if supported待机),
Suspend-To-Idle（idle） and hibernation（冬眠） (Suspend-To-Disk), respectively（分别）.

The meaning of the "mem" string is controlled by the /sys/power/mem_sleep file.
It contains strings representing the available modes of system suspend that may
be triggered by writing "mem" to /sys/power/state.  These modes are "s2idle"
(Suspend-To-Idle), "shallow(浅睡)" (Power-On Suspend) and "deep" (Suspend-To-RAM).
The "s2idle" mode is always available, while the other ones are only available
if supported by the platform (if not supported, the strings representing them
are not present in /sys/power/mem_sleep).  The string representing the suspend
mode to be used subsequently(后来) is enclosed in square brackets.  Writing one of
the other strings present in /sys/power/mem_sleep to it causes the suspend mode
to be used subsequently to change to the one represented by that string.

Consequently, there are two ways to cause the system to go into the
Suspend-To-Idle sleep state.  The first one is to write "freeze" directly to
/sys/power/state.  The second one is to write "s2idle" to /sys/power/mem_sleep
and then to write "mem" to /sys/power/state.  Similarly, there are two ways
to cause the system to go into the Power-On Suspend sleep state (the strings to
write to the control files in that case are "standby(待机)" or "shallow" and "mem",
respectively) if that state is supported by the platform.  In turn, there is
only one way to cause the system to go into the Suspend-To-RAM state (write
"deep" into /sys/power/mem_sleep and "mem" into /sys/power/state).

The default suspend mode (ie. the one to be used without writing anything into
/sys/power/mem_sleep) is either "deep" (if Suspend-To-RAM is supported) or
"s2idle", but it can be overridden by the value of the "mem_sleep_default"
parameter in the kernel command line.

The properties of all of the sleep states are described below.


State:		Suspend-To-Idle
ACPI state:	S0
Label:		"s2idle" ("freeze")

This state is a generic, pure software, light-weight, system sleep state.
It allows more energy to be saved relative to runtime idle by freezing user
space and putting all I/O devices into low-power states (possibly
lower-power than available at run time), such that the processors can
spend more time in their idle states.

This state can be used for platforms without Power-On Suspend/Suspend-to-RAM
support, or it can be used in addition to Suspend-to-RAM to provide reduced
resume latency(延迟).  It is always supported.


State:		Standby / Power-On Suspend
ACPI State:	S1
Label:		"shallow" ("standby")

This state, if supported, offers moderate（中等）, though real, power savings, while
providing a relatively low-latency transition back to a working system.  No
operating state is lost (the CPU retains power), so the system easily starts up
again where it left off.

In addition to freezing user space and putting all I/O devices into low-power
states, which is done for Suspend-To-Idle too, nonboot CPUs are taken offline
and all low-level system functions are suspended during transitions into this
state.  For this reason, it should allow more energy to be saved relative to
Suspend-To-Idle, but the resume latency will generally be greater than for that
state.


State:		Suspend-to-RAM
ACPI State:	S3
Label:		"deep"

This state, if supported, offers significant（重大的） power savings as everything in the
system is put into a low-power state, except for memory, which should be placed
into the self-refresh mode to retain(保留) its contents.  All of the steps carried out
when entering Power-On Suspend are also carried out during transitions to STR.
Additional operations may take place depending on the platform capabilities.  In
particular, on ACPI systems the kernel passes control to the BIOS (platform
firmware) as the last step during STR transitions and that usually results in
powering down some more low-level components that aren't directly controlled by
the kernel.

System and device state is saved and kept in memory.  All devices are suspended
and put into low-power states.  In many cases, all peripheral(外围设备) buses lose power
when entering STR, so devices must be able to handle the transition back to the
"on" state.

For at least(最小的) ACPI, STR requires some minimal boot-strapping code to resume the
system from it.  This may be the case on other platforms too.


State:		Suspend-to-disk
ACPI State:	S4
Label:		"disk"

This state offers the greatest power savings, and can be used even in
the absence of low-level platform support for power management. This
state operates similarly to Suspend-to-RAM, but includes a final step
of writing memory contents to disk. On resume, this is read and memory
is restored to its pre-suspend state.

STD can be handled by the firmware or the kernel. If it is handled by
the firmware, it usually requires a dedicated partition that must be
setup via another operating system for it to use. Despite the
inconvenience, this method requires minimal work by the kernel, since
the firmware will also handle restoring memory contents on resume.

For suspend-to-disk, a mechanism called 'swsusp' (Swap Suspend) is used
to write memory contents to free swap space. swsusp has some restrictive
requirements, but should work in most cases. Some, albeit outdated,
documentation can be found in Documentation/power/swsusp.txt.
Alternatively, userspace can do most of the actual suspend to disk work,
see userland-swsusp.txt.

Once memory state is written to disk, the system may either enter a
low-power state (like ACPI S4), or it may simply power down. Powering
down offers greater savings, and allows this mechanism to work on any
system. However, entering a real low-power state allows the user to
trigger wake up events (e.g. pressing a key or opening a laptop lid).

- On (on)									S0 -  Working（s0的状态应该是freeze）

- Standby (standby)						S1 -  CPU and RAM are powered but not executed

- Suspend to RAM (mem)					S3 -  RAM is powered and the running content is saved to RAM

- Suspend to Disk，Hibernation (disk)			S4 -  All content is saved to Disk and power down

S1状态简称standby状态，此状态下CPU处于低功耗状态，并且没有数据保存到RAM或者disk中，此状态待机和恢复通常很快。

S3 aka STR(suspend to ram),挂起到内存，简称待机。计算机将目前的运行状态等数据存放在内存，关闭硬 盘、外设等设备，进入等待状态。此时内存仍然需要电力维持其数据，但整机耗电很少。恢复时计算机从内存读出数据，回到挂起前的状态，恢复速度较快。对 DDR的耗电情况进行优化是S3性能的关键，大多数手持设备都是用S3待机。此状态下计算机会冻结所有的活动并将当前工作状态保存到RAM中，然后关闭屏幕进入低功耗模式，通常睡眠和唤醒需要几秒

S4 aka STD(suspend to disk),挂起到硬盘，简称休眠。把运行状态等数据存放在硬盘上某个文件或者某个特定的区域，关闭硬盘、外设等设备，进入关机状态。此时计算机完全关闭，不耗电。恢复时计算机从休眠文件/分区中读出数据，回到休眠前的状态，恢复速度较慢。电子书项目中，见过一款索尼的电子书，没有定义关机状态，只定义了S4,从而提高开机速度。一般在window系统中常见到。此状态下计算机将所有活动的状态保存到磁盘中，然后处于关机状态，此模式下是不耗电的，而相比之前的模式，休眠和唤醒的速度都比较慢。
					</div>
				</div>
			</section>
			<section>
				<h3>open port in iptabls or firewalld</h3>
				<p>
					#iptables is(in CentOS 7 not use this):
					<br/>
					#add a data receive rule
					<br/>
					<span class="shell_instruction">iptables -A INPUT -p tcp --dport 22 -j ACCEPT</span>
					<br/>
					#add a data post rule
					<br/>
					<span class="shell_instruction">iptables -A OUTPUT -p tcp --sport 22 -j ACCEPT</span>
					<br/>
					#restart iptables service
					<br/>
					<span class="shell_instruction">service sshd restart</span>
					<br/>
					<br/>

					#firewalld is(in CentOS 7 use this):
					<br/>
					#add a rule, with option parameter --permanent to persistent the rule
					<br/>
					<span class="shell_instruction">firewall-cmd --permanent --add-port=22/tcp</span>
					<br/>
					#restart firewalld service
					<br/>
					<span class="shell_instruction">systemctl restart firewalld</span>
					<br/>
					#ensure the new rule is active
					<br/>
					<span class="shell_instruction">firewall-cmd --query-port=22/tcp</span>
					<br/>
				</p>
			</section>
			<section>
				<h3>set sshd service start with OS boot and start at now</h3>
				<p>
					#query ssdh service status
					<br/>
					<span class="shell_instruction">systemctl status sshd</span>
					<br/>
					#output the follow information
					<br/>
					<span style="color : blue">
					● sshd.service - OpenSSH server daemon
					<br/>
					&nbsp;&nbsp;&nbsp;Loaded: loaded (/usr/lib/systemd/system/sshd.service; disabled; vendor preset: enabled)
					<br/>
					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Active: inactive (dead)
					<br/>
				    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Docs: man:sshd(8)
					<br/>
				    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;man:sshd_config(5)
					</span>
					<br/>
					#so we see the Loaded: loaded (/usr/lib/systemd/system/sshd.service; disabled; vendor preset: enabled)
					<br/>
					#the service is not start with OS boot, so we set it start with OS boot
					<br/>
					<span class="shell_instruction">systemctl enable sshd</span>
					<br/>
					#we also see Active: inactive (dead), that means the service is not run at current time, we start it at now
					<br/>
					<span class="shell_instruction">systemctl start sshd</span>
					<br/>
				</p>
			</section>
			<section>
				<h3>双系统, 修复windows启动项</h3>
				<p>
					修改/boot/grub2/grub.cfg
					<br/>
					找到在两个menuentry末尾添加一个win7启动设置，具体参数是
					<br/>
					menuentry	‘win7’{
						<br/>
						<span class="class___tab_place"></span>set root=(hd0,1)
						<br/>
						<span class="class___tab_place"></span>chainloader +1 
						<br/>
					}
				</p>
			</section>
			<section>
				<h3>关闭触控板</h3>
				<p>
					synclient touchpadoff=1
				</p>
			</section>
			<section>
				<h3>清屏命令</h3>
				<p>
					<span class="shell_instruction">clear</span>
					<br/>
					or
					<br/>
					ctrl + l
					<br/>
					刷新屏幕，本质上只是让终端显示页向后翻了一页，如果向上滚动屏幕还可以看到之前的操作信息。
				</p>
				<p>
					<span class="shell_instruction">reset</span>
					<br/>
					完全刷新终端屏幕，之前的终端输入操作信息将都会被清空，这样虽然比较清爽，但整个命令过程速度有点慢，使用较少。
					<br/>
					值得一提的是reset命令在你的终端控制错乱时非常有用。如输入字符不出现在光标的位置的情况。还有当你敲击回车键时，新提示符并没有出现在新行上而是出现在老提示符的前面。此时reset命令就能用来修正这些问题。
				</p>
				<p>
					<span class="shell_instruction">printf '\033c'</span>
					<br/>
					真正的清空了终端屏幕，它的功能跟DOS里CMD.EXE提供的CLS效果很相似。
					<br/>
					工作原理是
					<br/>
					\033  ==  \x1B == 27 == ESC
					<br/>
					于是，这个命令变成了<ESC>c，它是VT-XXX中表示“Full Reset (RIS)”的转义码。现今我们使用的所有的终端都是VT兼容的，它的另一种实现方式也可以这样：
					<br/>
					键盘上Ctrl+v---&gt;Esc--&gt;输入c再回加。但如果你发现自己使用的是一个非常奇怪的终端（如在putty上），那这个命令你可能用不了。
					<br/>
					 printf是bash里内置的命令，内置命令的优先级比其它可执行文件要高。
					<br/>
					 or
					<br/>
					<span class="shell_instruction">printf '\ec'</span>
					<br/>
					\e等价于\033
					<br/>
					 or
					<br/>
					<span class="shell_instruction">echo -e '\ec\c'</span>
					<br/>
					 or
					<br/>
					<span class="shell_instruction">echo -e '\033c\c'</span>
					<br/>
					 or
					<br/>
					<span class="shell_instruction">echo -en '\ec'</span>
					<br/>
					 or
					<br/>
					<span class="shell_instruction">echo -en '\033c'</span>
				</p>
			</section>
			<section>
				<h3>操作目录命令</h3>
				<p>
					回到刚才的目录
					<br/>
					<span class="shell_instruction">cd -</span>
				</p>
				<p>
					目录压栈
					<br/>
					<span class="shell_instruction">pushd .</span>
				</p>
				<p>
					目录出栈
					<br/>
					<span class="shell_instruction">popd</span>
				</p>
			</section>
			<section>
				<h3>查看内存</h3>
				<p>
					<span class="shell_instruction">free</span>
				</p>
			</section>
			<section>
				<h3>帮助,查找命令</h3>
				<p>
					<span class="shell_instruction">man -k key_word</span>
					<br/>
					-k : 列出包含在下一个参数中的字符的命令
				</p>
			</section>
			<section>
				<h3>生成ssh协议秘钥</h3>
				<p>
					use ssh-keygen instruction
				</p>
				<p>
					<span class="shell_instruction">ssh-keygen -t rsa -C email@domain</span>
					<br/>
					-t : 在下一个参数中指定加密算法
					<br/>
					-C : 在下一个参数中指定注释
				</p>
			</section>
			<section>
				<h3>encrypt and decrypt file with symmetric algorithm(文件加密解密使用对称算法)</h3>
				<p>
					use openssl, encrypt file by the follow instruction
				</p>
				<p>
					<span class="shell_instruction">openssl enc -des3 -a -salt -in source_file -out target_file [-pass password]</span>
					<br/>
					-des3 : 为加密算法(可以根据自己需要选择).
					<br/>
					-a : 对加密后的数据进行base64编码，或解密前，先对数据进行base64解码.
					<br/>
					-salt : 加盐,这是一个神奇的选项，加盐后，相同的明文可以得到不同的密文。默认情况下，盐值是随机生成的，可以使用-S选项明确指定盐值.
					<br/>
					-in : 在下一个参数中指定要加密的源文件.
					<br/>
					-out : 在下一个参数中指定加密后的文件.
					<br/>
					-pass : 在下一个参数中指定密码, 不加此参数则会在运行时等待用户输入密码,并以*号显示.
				</p>
				<p>
					use openssl, decrypt file by the follow instruction
				</p>
				<p>
					<span class="shell_instruction">openssl enc -d -des3 -a -salt -in source_file -out target_file [-pass password]</span>
					<br/>
					-d : 解密.
					<br/>
					-des3 : 为加密算法(可以根据自己需要选择).
					<br/>
					-a : 对加密后的数据进行base64编码，或解密前，先对数据进行base64解码.
					<br/>
					-salt : 加盐,这是一个神奇的选项，加盐后，相同的明文可以得到不同的密文。默认情况下，盐值是随机生成的，可以使用-S选项明确指定盐值.
					<br/>
					-in : 在下一个参数中指定要加密的源文件.
					<br/>
					-out : 在下一个参数中指定加密后的文件.
					<br/>
					-pass : 在下一个参数中指定密码, 不加此参数则会在运行时等待用户输入密码,并以*号显示.
				</p>
			</section>
		</article>
	</body>
</html>
