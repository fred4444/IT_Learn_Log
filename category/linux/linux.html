<!doctype html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0,minimum-scale=1.0,user-scalable=0" />
		<title>Linux</title>
		<style>
			.class___line_head {
				margin-left : 2em;
			}
			.class___tab_place {
				margin-left : 2em;
			}
			.class___center {
				text-align : center;
				width : 100%;
				display : inline-block;
			}
			.class___shell, .shell_instruction {
				color : yellow;
				background-color : black;
				font-weight : 800;
				padding : 4px;
			}
			header > div {
				padding-left : 2em;
				line-height : 180%;
			}
			section > p {
				padding-left : 2em;
				line-height : 180%;
			}
			section > div {
				padding-left : 2em;
				line-height : 180%;
			}
			.class___copy_other_people_content {
				background-color : #aef5a8;
			}
		</style>
		<script>
		</script>
	</head>
	<body>
		<article>
			<header>
				<h3>Linux</h3>
				<div>
					Linux spread log.
				</div>
			</header>
			<section>
				<h3>查看cpu信息和开关cpu内核</h3>
				<div>
					查看cpu信息:
					<br/>
					<span class="shell_instruction">cat /proc/cpuinfo</span>
					<br/>
					查看cpu内核数量:
					<br/>
					<span class="shell_instruction">ls /sys/devices/system/cpu/</span>
					<br/>
					显示的cpu0,cpu1...便是相应的cpu内核,从0开始最后一个数加1便是总内核数
					<br/>
					关闭某个内核如cpu3号内核:
					<br/>
					<span class="shell_instruction">echo 0 &gt; /sys/devices/system/cpu/cpu3/online</span>
					<br/>
					开启某个内核如cpu3号内核:
					<br/>
					<span class="shell_instruction">echo 1 &gt; /sys/devices/system/cpu/cpu3/online</span>
				</div>
			</section>
			<section>
				<h3>efibootmgr修改主板上EFI的设备启动项</h3>
				<div>
					查看启动项列表:
					<br/>
					<span class="shell_instruction">efibootmgr</span>
					<br/>
					查看启动项列表详细信息:
					<br/>
					<span class="shell_instruction">efibootmgr -v</span>
					<br/>
					参数列表可参考:
					<br/>
					<span class="shell_instruction">man efibootmgr</span>
					<br/>
					或
					<a target="_blank" target="https://linux.die.net/man/8/efibootmgr">efibootmgr(8): change EFI Boot Manager - Linux man page</a>
					<br/>
					删除启动项:
					<br/>
					<span class="shell_instruction">efibootmgr -b 启动项编号 -B</span>
					<br/>
					如删除编号为0002的项
					<br/>
					<span class="shell_instruction">efibootmgr -b 0002 -B</span>
					<br/>
					创建启动项:
					<br/>
					<span class="shell_instruction">efibootmgr -c -w -L "启动项名称" -d 存储设备路径 -p 分区编号 -l 启动文件相对于前面指定的分区的路径</span>
					<br/>
					如创建启动项叫mylinux, 启动文件在/boot/efi/EFI/fedora/shimx64.efi, 此文件在分区/dev/sda1, /dev/sda1的挂载路径为/boot/efi/
					<br/>
					<span class="shell_instruction">efibootmgr -c -w -L "mylinux" -d /dev/sda -p 1 -l \\EFI\\fedora\\shimx64.efi</span>
					<br/>
					修改启动项顺序:
					<br/>
					<span class="shell_instruction">efibootmgr -o 用,分隔的启动项编号</span>
					<br/>
					如修改启动项顺序为0002,0003,0001
					<br/>
					<span class="shell_instruction">efibootmgr -o 0002,0003,0001</span>
				</div>
			</section>
			<section>
				<h3>make install, make uninstall, make clean</h3>
				<div class="class___copy_other_people_content">
					通常的安装方法是从源码安装包的目录执行以下命令：
					<br/>
					先解压
					<br/>
					然后cd进入源码目录
					<br/>
					检查环境，配置编译条件
					<br/>
					<span class="class___shell">./configure</span>
					<br/>
					<br/>
					调用gcc进行编译
					<br/>
					<span class="class___shell">make</span>
					<br/>
					<br/>
					安装编译好的可执行程序
					<br/>
					<span class="class___shell">sudo make install</span>
					<br/>
					<br/>
					<br/>
					<br/>
					卸载软件：
					<br/>
					删除make install命令时装进去的文件
					<br/>
					<span class="class___shell">sudo make uninstall</span>
					<br/>
					<br/>
					只删除make时产生的临时文件
					<br/>
					<span class="class___shell">make clean</span>
					<br/>
					<br/>
					同时删除configure和make产生的临时文件(soft1下)
					<br/>
					<span class="class___shell">make distclean</span>
					<br/>
					<br/>
					<br/>
					make的原理是执行一个叫Makefile文件里的指令，make的基本用处是自动根据makefile里的指令来编译源文件。它还可以用来做比如安装软件，卸载软件等事情，但前提是作者在makefile里写了。比如makefile里有这么些内容：
					<br/>
					......
					<br/>
					install : < commands >
					<br/>
					然后用make install的话，make程序就会按照上面install：后面的指令< commands >执行安装，uninstall也是一样的道理，大部分的作者会写有卸载的部分，这时只要简单地执行make unistall就可以，如果作者懒没有写，那就只有根据make install中的步骤，看它把什么文件拷到哪去了，然后分别手动删除。
					<br/>
					还有关键的一点是，编译安装完成后，不要删除源代码，不然就算作者写了uninstall目标，你也没有makefile可以执行了。
				</div>
			</section>
			<section>
				<h3>UUID, PARTUUID</h3>
				<div>
					UUID is a filesystem-level UUID, which is retrieved from the filesystem metadata inside the partition. That can only be read if the filesystem type is known and readable.
					<br/>
					PARTUUID is a partition-table-level UUID for the partition, a standard feature for all partitions on GPT-partitioned disks. Since it is retrieved from the partition table, it is accessible without making no assumptions at all about the actual contents of the partition. If the partition is encrypted using some unknown encryption method, this might be the only accessible unique identifier for that particular partition.
					<br/>
					PTUUID is the UUID of the partition table itself, a unique identifier for the entire disk assigned at the time the disk was partitioned. It's the equivalent of disk signature on MBR-partitioned disks, but with more bits and standardized procedure for its generation.
					<br/>
					On MBR-partitioned disks, there are no real UUIDs in the partition table. So, the 32-bit disk signature is used in place of a PTUUID, and PARTUUIDs are created by adding a dash and a two-digit partition number to the end of the disk signature.
				</div>
			</section>
			<section>
				<h3>分区</h3>
				<div>
					GPT分区用:
					<br/>
					<span class="shell_instruction">parted</span>
					<br/>
					MBR分区用:
					<br/>
					<span class="shell_instruction">fdisk</span>
				</div>
			</section>
			<section>
				<h3>文件系统</h3>
				<div>
					<div class="class___copy_other_people_content">
						<a target="_blank" href="https://www.cnblogs.com/tommyli/p/3201047.html">ext3，ext4，xfs和btrfs文件系统性能对比 - 李占卫 - 博客园</a>
						<br/>
						1：单字节写入性能对比
						<br/>
						<img src="./refs/performance_comparison_of_ext3_ext4_XFS_Btrfs_file_systems/01.png">
						<br/>
						A：由于硬盘式块设备所以对于这种测试硬盘式不擅长的
						<br/>
						B：btrfs系统只有200K/SEC,xfs表现的性能比较平衡。
						<br/>
						2：块写入性能对比（由于硬盘是块设备这种对比来的更有意义）
						<br/>
						<img src="./refs/performance_comparison_of_ext3_ext4_XFS_Btrfs_file_systems/02.png">
						<br/>
						A：性能上差不多，但是效率上（CPU占用率上）来说最好的是xfs接下来依次是EXT4，EXT3，BTRFS
						<br/>
						3：直接块顺序读写（关掉任何的系统和文件缓存）
						<br/>
						<img src="./refs/performance_comparison_of_ext3_ext4_XFS_Btrfs_file_systems/03.png">
						<br/>
						A：绕过系统和文件缓冲的话（例如：视频录制，一些虚拟机软件，ECC），EXT3/ 4是最好的选择，其次是BTRFS，最后是XFS。
						<br/>
						B：没有一种文件系统可以适用于所有环境
						<br/>
						4：随机寻道
						<br/>
						<img src="./refs/performance_comparison_of_ext3_ext4_XFS_Btrfs_file_systems/04.png">
						<br/>
						A：BTRFS系能最差，不到20 seeks/sec
						<br/>
						B：EXT3性能最好，如果软件大量的随机寻址的话这个文件系统性能更好
						<br/>
						5：创建和删除大量文件（文件量一定）
						<br/>
						<img src="./refs/performance_comparison_of_ext3_ext4_XFS_Btrfs_file_systems/05_1.png">
						<br/>
						BTRFS系统性能最差，下面是去掉该系统其它3种的对比
						<br/>
						<img src="./refs/performance_comparison_of_ext3_ext4_XFS_Btrfs_file_systems/05_2.png">
						<br/>
						A：EXT4是更高效高性能的系统，接下来依次是XFS,EXT3
						<br/>
						6：顺序读写吞吐量【没有fsync的是100 writes/one fsync()，有的是1 writes/one fsync()】
						<br/>
						<img src="./refs/performance_comparison_of_ext3_ext4_XFS_Btrfs_file_systems/06.png">
						<br/>
						A：100 writes/one fsync()各个性能差不多
						<br/>
						B：1 writes/one fsync()时EXT3性能最好，接下来依次是XFS,EXT4，BTRFS
						<br/>
						C：write + fsync()在BTRFS下对读性能产生影响
						<br/>
						7：随机读写吞吐量
						<br/>
						<img src="./refs/performance_comparison_of_ext3_ext4_XFS_Btrfs_file_systems/07.png">
						<br/>
						A：100 seeks/sec每个块16 KB，我们得出最大的读取速度是1600 KB/sec，XFS，BTRFS大于了这个数值（可能数据不能随机也可能缓冲影响了结果）
						<br/>
						B：EXT3随机写入性能是最好的，适用于数据库，高容量的记录程序和虚拟机系统
						<br/>
						8：向PostgreSQL 中写入10万行数据
						<br/>
						<img src="./refs/performance_comparison_of_ext3_ext4_XFS_Btrfs_file_systems/08.png">
						<br/>
						A：BTRFS 性能是最好的，EXT4和XFS很低的cpu使用率但是性能太差
						<br/>
						9：读测试
						<br/>
						<img src="./refs/performance_comparison_of_ext3_ext4_XFS_Btrfs_file_systems/09.png">
						<br/>
						A：10万次的读测试，性能差别不大
						<br/>
						10：复杂的读写以及事务测试
						<br/>
						<img src="./refs/performance_comparison_of_ext3_ext4_XFS_Btrfs_file_systems/10.png">
						<br/>
						A：EXT3性能最好
						<br/>
						所以，数据库最好是EXT3系统，除非EXT4解决了所谓的回归问题。
						<br/>
						11：Linux kernel 2.6.36下的解包操作
						<br/>
						<img src="./refs/performance_comparison_of_ext3_ext4_XFS_Btrfs_file_systems/11_1.png">
						<br/>
						A：该操作最好的文件系统是EXT4
						<br/>
						这次操作会受到缓存和延时分配的影响，我们强制同步看看效果
						<br/>
						<img src="./refs/performance_comparison_of_ext3_ext4_XFS_Btrfs_file_systems/11_2.png">
						<br/>
						A：XFS是较慢的FS，EXT3慢于EXT4和BTRFS
						<br/>
						12：cat操作
						<br/>
						<img src="./refs/performance_comparison_of_ext3_ext4_XFS_Btrfs_file_systems/12.png">
						<br/>
						A：该操作比较有效率的系统是XFS
						<br/>
						B：该执行最快CPU占用最高的系统是BTRFS，，说明该系统有复杂的元数据操作
						<br/>
						13：解压linux核心（会产生32000 files）
						<br/>
						<img src="./refs/performance_comparison_of_ext3_ext4_XFS_Btrfs_file_systems/13.png">
						<br/>
						A：EXT3这个唯一没有延时分配能力的系统是最差的
						<br/>
						14：顺序创建128个文件，每个长16 MB（共2 GB）各种系统产生的碎片情况
						<br/>
						<img src="./refs/performance_comparison_of_ext3_ext4_XFS_Btrfs_file_systems/14_1.png">
						<br/>
						A：BTRFS系统碎片是个严重的问题（这也解释了先前的这种系统读性能低下的原因）
						<br/>
						出去BTRFS系统后的图
						<br/>
						<img src="./refs/performance_comparison_of_ext3_ext4_XFS_Btrfs_file_systems/14_2.png">
						<br/>
						A：EXT4，XFS这种有延时分配机制的系统产生的碎片少于EXT3（即使one write/one fsync()）
						<br/>
						15：随机创建128个文件，每个长16 MB（共2 GB）各种系统产生的碎片情况
						<br/>
						<img src="./refs/performance_comparison_of_ext3_ext4_XFS_Btrfs_file_systems/15.png">
						<br/>
						A：随机写入在任何系统下都会产生碎片，即使有延时分配也没用
						<br/>
						<br/>
						<br/>
						Linux kernel 自 2.6.28 开始正式支持新的文件系统 Ext4。 Ext4 是 Ext3 的改进版，修改了 Ext3 中部分重要的数据结构，而不仅仅像 Ext3 对 Ext2 那样，只是增加了一个日志功能而已。Ext4 可以提供更佳的性能和可靠性，还有更为丰富的功能：
						<br/>
						1. 与 Ext3 兼容。执行若干条命令，就能从 Ext3 在线迁移到 Ext4，而无须重新格式化磁盘或重新安装系统。原有 Ext3 数据结构照样保留，Ext4 作用于新数据，当然，整个文件系统因此也就获得了 Ext4 所支持的更大容量。
						<br/>
						2. 更大的文件系统和更大的文件。较之 Ext3 目前所支持的最大 16TB 文件系统和最大 2TB 文件，Ext4 分别支持 1EB（1,048,576TB， 1EB=1024PB， 1PB=1024TB）的文件系统，以及 16TB 的文件。
						<br/>
						3. 无限数量的子目录。Ext3 目前只支持 32,000 个子目录，而 Ext4 支持无限数量的子目录。
						<br/>
						4. Extents。Ext3 采用间接块映射，当操作大文件时，效率极其低下。比如一个 100MB 大小的文件，在 Ext3 中要建立 25,600 个数据块（每个数据块大小为 4KB）的映射表。而 Ext4 引入了现代文件系统中流行的 extents 概念，每个 extent 为一组连续的数据块，上述文件则表示为“ 该文件数据保存在接下来的 25,600 个数据块中”，提高了不少效率。
						<br/>
						5. 多块分配。当写入数据到 Ext3 文件系统中时，Ext3 的数据块分配器每次只能分配一个 4KB 的块，写一个 100MB 文件就要调用 25,600 次数据 块分配器，而 Ext4 的多块分配器“multiblock allocator”（mballoc） 支持一次调用分配多个数据块。
						<br/>
						6. 延迟分配。Ext3 的数据块分配策略是尽快分配，而 Ext4 和其它现代文件操作系统的策略是尽可能地延迟分配，直到文件在 cache 中写完才开始分配数据块并写入磁盘，这样就能优化整个文件的数据块分配，与前两种特性搭配起来可以显著提升性能。
						<br/>
						7. 快速 fsck。以前执行 fsck 第一步就会很慢，因为它要检查所有的 inode，现在 Ext4 给每个组的 inode 表中都添加了一份未使用 inode 的列表，今后 fsck Ext4 文件系统就可以跳过它们而只去检查那些在用的 inode 了。
						<br/>
						8. 日志校验。日志是最常用的部分，也极易导致磁盘硬件故障，而从损坏的日志中恢复数据会导致更多的数据损坏。Ext4 的日志校验功能可以很方便地判断日志数据是否损坏，而且它将 Ext3 的两阶段日志机制合并成一个阶段，在增加安全性的同时提高了性能。
						<br/>
						9. “无日志”（No Journaling）模式。日志总归有一些开销，Ext4 允许关闭日志，以便某些有特殊需求的用户可以借此提升性能。
						<br/>
						10. 在线碎片整理。尽管延迟分配、多块分配和 extents 能有效减少文件系统碎片，但碎片还是不可避免会产生。Ext4 支持在线碎片整理，并将提供 e4defrag 工具进行个别文件或整个文件系统的碎片整理。
						<br/>
						11. inode 相关特性。Ext4 支
						持更大的 inode，较之 Ext3 默认的 inode 大小 128 字节，Ext4 为了在 inode 中容纳更多的扩展属性（如纳秒时间戳或 inode 版本），默认 inode 大小为 256 字节。Ext4 还支持快速扩展属性（fast extended attributes） 和 inode 保留（inodes reservation）。
						<br/>
						12. 持久预分配（Persistent preallocation）。P2P 软件为了保证下载文件有足够的空间存放，常常会预先创建一个与所下载文件大小相同的空文件，以免未来的数小时或数天之内磁盘空间不足导致下载失 败。Ext4 在文件系统层面实现了持久预分配并提供相应的 API（libc 中的 posix_fallocate()），比应用软件自己实现更有效率。
						<br/>
						13. 默认启用 barrier。磁盘上配有内部缓存，以便重新调整批量数据的写操作顺序，优化写入性能，因此文件系统必须在日志数据写入磁盘之后才能写 commit 记录， 若 commit 记录写入在先，而日志有可能损坏，那么就会影响数据完整性。Ext4 默认启用 barrier，只有当 barrier 之前的数据全部写入磁盘，才能写 barrier 之后的数据。（可通过 "mount -o barrier=0" 命令禁用该特性。）
					</div>
				</div>
			</section>
			<section>
				<h3>查看文件的inode</h3>
				<div>
					<span class="shell_instruction">ls -i file_path</span>
					<br/>
					其中file_path为文件的路径, 也可以在文件所在的路径下直接
					<br/>
					<span class="shell_instruction">ls -i</span>
				</div>
			</section>
			<section>
				<h3>通过文件的inode来查找文件</h3>
				<div>
					<span class="shell_instruction">find / -inum file_inode</span>
					<br/>
					其中/为根路径, file_inode为文件的inode
				</div>
			</section>
			<section>
				<h3>查找一个文件的所有硬链接</h3>
				<div>
					先查看文件的inode
					<br/>
					在根路径下通过文件的inode进行查找
				</div>
			</section>
			<section>
				<h3>笔记本触摸板鼠标</h3>
				<div>
					开启触摸板鼠标
					<br/>
					<span class="shell_instruction">synclient touchpadoff=0</span>
					<br/>
					关闭触摸板鼠标
					<br/>
					<span class="shell_instruction">synclient touchpadoff=1</span>
				</div>
			</section>
			<section>
				<h3>修改用户账号, 如锁定解锁等The usermod command modifies the system account files to reflect the changes that are specified on the command line</h3>
				<div>
					当用户密码输入错误次数过多时用户会被锁定
					<br/>
					解锁用户密码
					<br/>
					<span class="shell_instruction">usermod -U username</span>
					<br/>
					锁定用户密码
					<br/>
					<span class="shell_instruction">usermod -U username</span>
				</div>
			</section>
			<section>
				<h3>截屏</h3>
				<div>
					gnome-screenshot软件的默认截屏图片存放在~/Pictures/下
					<br/>
					全屏截图不含鼠标:<span class="shell_instruction">gnome-screenshot</span>
					<br/>
					全屏截图含鼠标:<span class="shell_instruction">gnome-screenshot -p</span>
					<br/>
					截取鼠标选定区域:<span class="shell_instruction">gnome-screenshot -a</span>执行后会等待鼠标选择区域, 在要选择的区域的一个角处鼠标点下别松开然后移动到对着的另一个角松开鼠标, 选择完成后即截取完成.
					<br/>
					截取当前窗口:<span class="shell_instruction">gnome-screenshot -w</span>
					<br/>
					截取当前去除边框的窗口:<span class="shell_instruction">gnome-screenshot -w -B</span>
					<br/>
					截取当前窗口并换边框:<span class="shell_instruction">gnome-screenshot -wB -e border</span>用其中的B参数去掉边框再用e参数添加border样式的边框
					<br/>
					延迟截取选定窗口:<span class="shell_instruction">gnome-screenshot -d 5</span>延迟5秒后截取活动窗口
					<br/>
					打开gnome-screenshot软件图形化界面:<span class="shell_instruction">gnome-screenshot -i</span>
				</div>
			</section>
			<section>
				<h3>systemctl</h3>
				<div>
					<a target="_blank" href="https://www.cnblogs.com/zwcry/p/9602756.html">linux systemctl 指令 —— 阮一峰 - 七脉 - 博客园</a>
				</div>
			</section>
			<section>
				<h3>tmpfs, ramfs</h3>
				<div>
					tmpfs与ramfs类似, 挂载方式相似，区别如下:
					<br/>
					<br/>
					tmpfs是虚拟内存文档系统，数据存储在物理内存和交换分区(swap)。在Linux内核中，虚拟内存资源由物理内存（RAM）和交换分区组成，这些资源是由内核中的虚拟内存子系统来负责分配和管理。
					<br/>
					大小不会自动增加, 挂载的目录大小受到限制保护，即往里写入数据不会超出限定的大小, 默认权限设置任何用户均可使用
					<br/>
					<br/>
					ramfs是内存文档系统，工作于虚拟文档系统（VFS）层， 数据存储于物理内存中。
					<br/>
					大小自动增加, 挂载的目录指定大小无效，即往里写入数据会超出限定的大小, 直到内存耗尽，系统挂起, 默认权限设置只有root用户能够使用
					<br/>
					例如通过命令挂载时指定大小为1M
					<br/>
					<span class="shell_instruction">mount -t ramfs -o size=1M ramfs my_ramfs_dir</span>
					<br/>
					写入5M的数据
					<br/>
					<span class="shell_instruction">dd if=/dev/zero of=my_ramfs_div/size_test.txt bs=1M count=5</span>
					<br/>
					执行结果为成功
				</div>
			</section>
			<section>
				<h3>mount --bind 绑定挂载目录</h3>
				<div>
					将source_div目录绑定挂载到target_dir目录
					<br/>
					<span class="shell_instruction">mount --bind source_dir target_dir</span>
					<br/>
					执行后操作target_dir下的内容即为source_dir的内容, 相当与把source_dir文件(在linux中把设备如硬盘等设备均看作文件)挂载到target_dir目录下, 也类似于建立了一个硬链接
				</div>
			</section>
			<section>
				<h3>mount指定分区大小</h3>
				<div>
					<span class="shell_instruction">mount -t tmpfs -o size=4096M tmpfs ./tmp</span>
					<br/>
					其中size=4096M 为4096MB
					<br/>
					<span class="shell_instruction">mount -t tmpfs -o remount,size=80% tmpfs /dev/shm</span>
					<br/>
					size=80%为设置大小为内存的80%
				</div>
			</section>
			<section>
				<h3>/etc/fstab指定分区大小</h3>
				<div>
					tmpfs /dev/shm tmpfs defaults,size=4096M 0 0
					<br/>
					其中size=4096M 为4096MB
				</div>
			</section>
			<section>
				<h3>U盘写入文件Read-only file system错误</h3>
				<div>
					可以查看/proc/mounts文件是否U盘挂载为只读, 若有参数ro则为只读, rw为读写
					<br/>
					用如下命令重新挂载即可
					<br/>
					<span class="shell_instruction">mount -o remount -rw  usb_path/</span>
					<br/>
					其中usb_path/为U盘的挂载路径, -rw为读写
				</div>
			</section>
			<section>
				<h3>查看指定路径的man文件</h3>
				<p>
					<span class="shell_instruction">man -l &lt;filepath&gt;</span>
					<br/>
					or
					<br/>
					<span class="shell_instruction">man --local-file &lt;filepath&gt;</span>
					<br/>
					用
					<span class="shell_instruction">man man</span>
					<br/>
					查看man自身的帮助手册, 其中的参数信息如下
					<br/>
					-l, --local-file
					<br/>
Activate `local' mode.  Format and display local manual files instead of searching through the system's manual collection.  Each manual page argument will be interpreted as  an  nroff  source file  in the correct format.  No cat file is produced.  If '-' is listed as one of the arguments, input will be taken from stdin.  When this option is not used, and man fails to find the page required, before displaying the error message, it attempts to act as if this option was supplied, using the name as a filename and looking for an exact match.
				</p>
			</section>
			<section>
				<h3>tar過濾部分文件打包</h3>
				<p>
					<a target="_blank" href="refs/tar__exclude_file.pdf">參考文檔</a>
				</p>
			</section>
			<section>
				<h3>查看Linux内核版本的命令</h3>
				<p>
					<span class="shell_instruction">uname -a</span>
					<br/>
					查看系统内核版本号及系统名称
					<br/>
					or
					<br/>
					<span class="shell_instruction">cat /proc/version</span>
					<br/>
					查看目录"/proc"下version的信息，也可以得到当前系统的内核版本号及系统名称
					<br/>
					补充说明:/proc文件系统，它不是普通的文件系统，而是系统内核的映像，也就是说，该目录中的文件是存放在系统内存之中的，它以文件系统的方式为访问系统内核数 据的操作提供接口。而我们使用命令“uname -a"的信息就是从该文件获取的，当然用方法二的命令直接查看它的内容也可以达到同等效果.另外，加上参数"a"是获得详细信息，如果不加参数为查看系统名称。
				</p>
			</section>
			<section>
				<h3>關機及重啟</h3>
				<p>
					關機
					<br/>
					<span class="shell_instruction">poweroff</span>
					<br/>
					or
					<br/>
					<span class="shell_instruction">shutdown -P now</span>
					<br/>
					or
					<br/>
					<span class="shell_instruction">shutdown -h now</span>
					<br/>
					或參考
					<br/>
					<span class="shell_instruction">man shutdown</span>
					<br/>
					10分鐘後關機
					<br/>
					<span class="shell_instruction">shutdown -h +10</span>
					<br/>
					18:30關機
					<br/>
					<span class="shell_instruction">shutdown -h 18:30</span>
					<br/>

					
					<br/>
					<br/>
					重啟
					<br/>
					<span class="shell_instruction">reboot</span>
					<br/>
					or
					<br/>
					<span class="shell_instruction">shutdown -r now</span>
					<br/>
					或參考
					<br/>
					<span class="shell_instruction">man shutdown</span>
					<br/>
					10分鐘後重啟
					<br/>
					<span class="shell_instruction">shutdown -r +10</span>
					<br/>
					18:30重啟
					<br/>
					<span class="shell_instruction">shutdown -r 18:30</span>
				</p>
			</section>
			<section>
				<h3>ctrl+z(挂起),jobs(任务),fg(前台),bg(后台),kill(终止进程)</h3>
				<p>
					ctrl+z
					<br/>
					ctrl+z挂起前台命令暂停执行，回到shell命令行环境中
				</p>
				<p>
					jobs
					<br/>
					察看当前shell下运行的所有程序；带+表示最新的jobs；带-表示次新的jobs；其他jobs不带符号
				</p>
				<p>
					bg %n
					<br/>
					将第n个job放到后台运行
				</p>
				<p>
					bg
					<br/>
					将最后挂起的命令放到后台运行
				</p>
				<p>
					fg %n
					<br/>
					将第n个job返回前台运行
				</p>
				<p>
					fg
					<br/>
					将最后挂起的命令返回前台运行
				</p>
				<p>
					kill %n
					<br/>
					杀死第n个job，不再执行
				</p>
			</section>
			<section>
				<h3>mount -o loop</h3>
				<div>
					THE LOOP DEVICE
					<br/>
					One further possible type is a mount via the loop device.  For example, the command
					<br/>
					<span class="class___tab_place"></span>mount /tmp/disk.img /mnt -t vfat -o loop=/dev/loop3
					<br/>
					will set up the loop device /dev/loop3 to correspond to the file /tmp/disk.img, and then mount this device on /mnt.
					<br/>
					If no explicit loop device is mentioned (but just an option `-o loop' is given), then mount will try to find some unused loop device and use that, for example
					<br/>
					<span class="class___tab_place"></span>mount /tmp/disk.img /mnt -o loop
					<br/>
					The mount command automatically creates a loop device from a regular file if a filesystem type is not specified or the filesystem is known for libblkid, for example:
					<br/>
					<span class="class___tab_place"></span>mount /tmp/disk.img /mnt
					<br/>
					<span class="class___tab_place"></span>mount -t ext3 /tmp/disk.img /mnt
					<br/>
					This type of mount knows about three options, namely loop, offset and sizelimit, that are really options to losetup(8).  (These options can be used in addition to those specific  to  the  filesystem type.)
					<br/>
					Since Linux 2.6.25 auto-destruction of loop devices is supported, meaning that any loop device allocated by mount will be freed by umount independently of /etc/mtab.
					<br/>
					You can also free a loop device by hand, using losetup -d or umount -d.
					<br/>
					Since  util-linux  v2.29  mount  command re-uses the loop device rather than initialize a new device if the same backing file is already used for some loop device with the same offset and sizelimit.
					<br/>
					This is necessary to avoid a filesystem corruption.
				</div>
			</section>
			<section>
				<h3>创建iso文件</h3>
				<p>
					use mkisofs create iso file
				</p>
				<p>
					<span class="shell_instruction">mkisofs -r -o mongodb_linux_x86_64_4.0.7.iso mongodb_linux_x86_64_4.0.7.tgz</span>
					<br/>
					-r : 设置所有文件拥有读取权限
					<br/>
					-o : 在后面指定输出的iso文件的路径及文件名
				</p>
				<p>
					use dd copy device content to file
				</p>
				<p>
					<span class="shell_instruction">dd if=/dev/cdrom of=vcd.iso</span>
					<br/>
					if : 数据源块路径
					<br/>
					of : 输出文件的路径及文件名
				</p>
			</section>
			<section>
				<h3>查看系统配置信息</h3>
				<div>
					#硬件信息
					<br/>
					dmidecode
					<br/>
					#模块信息
					<br/>
					dmesg
					<br/>
					#查看分区信息如uuid等
					<br/>
					blkid
					<br/>
					#查看外存及分区信息
					<br/>
					lsblk
					<br/>
					#查看usb设备
					<br/>
					lsusb
				</div>
			</section>
			<section>
				<h3>设置分区的标签</h3>
				<p>
					#ext2/ext3/ext4
					<br/>
					<span class="shell_instruction">e2label [&lt;device&gt;] [&lt;new_label&gt;]</span>
					<br/>
					#xfs
					<br/>
					<span class="shell_instruction">xfs_admin -L [&lt;new_label&gt;] [&lt;device&gt;]</span>
					<br/>
					#jfs
					<br/>
					<span class="shell_instruction">jfs_tune -L [&lt;new_label&gt;] [&lt;device&gt;]</span>
					<br/>
					#Btrfs
					<br/>
					<span class="shell_instruction">btrfs filesystem label [&lt;device&gt;] [&lt;new_label&gt;]</span>
					<br/>
					#or
					<br/>
					<span class="shell_instruction">btrfs-filesystem label [&lt;device&gt;|&lt;mountpoint&gt;] [&lt;new_label&gt;]</span>
					<br/>
					#ReiserFS
					<br/>
					<span class="shell_instruction">reiserfstune -l [&lt;new_label&gt;] [&lt;device&gt;]</span>
					<br/>
					#swap
					<br/>
					<span class="shell_instruction">mkswap -L [&lt;new_label&gt;] [&lt;device&gt;]</span>
					<br/>
					#ntfs
					<br/>
					<span class="shell_instruction">ntfslabel [&lt;device&gt;] [&lt;new_label&gt;]</span>
					<br/>
					#for example set sda5 label is home
					<br/>
					<span class="shell_instruction">ntfslabel /dev/sda7 home</span>
				</p>
			</section>
			<section>
				<h3>添加和删除用户</h3>
				<p>
					#添加用户angular4
					<br/>
					<span class="shell_instruction">adduser angular4</span>
					<br/>
					#添加用户组angular
					<br/>
					<span class="shell_instruction">groupadd angular</span>
					<br/>
					#设置用户angular4所在组为angular
					<br/>
					<span class="shell_instruction">usermod -g angular angular4</span>
					<br/>
					<br/>

					#查看用户组
					<br/>
					<span class="shell_instruction">vim /etc/group</span>
					<br/>
					#删除用户组
					<br/>
					<span class="shell_instruction">groupdel angular</span>
					<br/>
					<span class="shell_instruction">groupdel angular4</span>
					<br/>
					#删除用户
					<br/>
					<span class="shell_instruction">userdel angular4</span>
					<br/>
					<span class="shell_instruction">rm -rf /home/angular4</span>
					<br/>
					#if add this user again will got error
					<br/>
					#Creating mailbox file: File exists
					<br/>
					<span class="shell_instruction">find / -name angular4</span>
					<br/>
					#the result include /var/spool/mail/angular4
					<br/>
					<span class="shell_instruction">rm -rf /var/spool/mail/angular4</span>
					<br/>
					<br/>

					#set user password
					<br/>
					<span class="shell_instruction">passwd angular4</span>
					<br/>
					<br/>

					#delete user password
					<br/>
					<span class="shell_instruction">passwd -d angular4</span>
				</p>
			</section>
			<section>
				<h3>change run level</h3>
				<p>
					#before CentOS 7 is change /etc/inittab file, but from CentOS 7 is no longer use this, the new run level is in /usr/lib/systemd/system/*.target
					<br/>
					#see current run level
					<br/>
					<span class="shell_instruction">systemctl list-units --type=target</span>
					<br/>
					#change run level to 3 level is
					<br/>
					<span class="shell_instruction">systemctl isolate multi-user.target</span>
					<br/>
					#change default run level to 3 level is
					<br/>
					<span class="shell_instruction">systemctl set-default multi-user.target</span>
					<br/>
					#old run level with new target relation is
					<br/>
					<span style="color : blue">
						runlevel0.target -&gt; poweroff.target
						<br/>
						runlevel1.target -&gt; rescue.target
						<br/>
						runlevel2.target -&gt; multi-user.target
						<br/>
						runlevel3.target -&gt; multi-user.target
						<br/>
						runlevel4.target -&gt; multi-user.target
						<br/>
						runlevel5.target -&gt; graphical.target
						<br/>
						runlevel6.target -&gt; reboot.target
					</span>
					<br/>
					#can use the follow instruction to see all the target
					<br/>
					<span class="shell_instruction">ls -lh /usr/lib/systemd/system/*.target</span>
				</p>
			</section>
			<section>
				<h3>CentOS 7 suspend and hibernate</h3>
				<div>
					<span class="shell_instruction">systemctl suspend</span>
					<br/>
					equal
					<br/>
					<span class="shell_instruction">echo "mem" &gt; /sys/power/state</span>
					<br/>
					<br/>
					<span class="shell_instruction">systemctl hibernate</span>
					<br/>
					equal
					<br/>
					<span class="shell_instruction">echo "disk" &gt; /sys/power/state</span>
					<br/>
					参考内容:
					<br/>
					<a target="_blank" href="http://www.wowotech.net/linux_kenrel/suspend_and_resume.html">Linux电源管理(6)_Generic PM之Suspend功能</a>
					<a target="_blank" href="https://blog.csdn.net/feifei_csdn/article/details/80831373">【sys/power】freeze、standby、mem、disk四个电源状态_勿于浮沙筑高台-CSDN博客</a>
					<div class="class___copy_other_people_content" style="white-space : pre;">
System Power Management Sleep States

(C) 2014 Intel Corp., Rafael J. Wysocki <rafael.j.wysocki@intel.com>

The kernel supports up to four system sleep states generically（一般）, although three
of them depend on the platform support code to implement（实行） the low-level details
for each state.

The states are represented by strings that can be read or written to the
/sys/power/state file.  Those strings may be "mem", "standby", "freeze" and
"disk", where the last three always represent(代表) Power-On Suspend (if supported待机),
Suspend-To-Idle（idle） and hibernation（冬眠） (Suspend-To-Disk), respectively（分别）.

The meaning of the "mem" string is controlled by the /sys/power/mem_sleep file.
It contains strings representing the available modes of system suspend that may
be triggered by writing "mem" to /sys/power/state.  These modes are "s2idle"
(Suspend-To-Idle), "shallow(浅睡)" (Power-On Suspend) and "deep" (Suspend-To-RAM).
The "s2idle" mode is always available, while the other ones are only available
if supported by the platform (if not supported, the strings representing them
are not present in /sys/power/mem_sleep).  The string representing the suspend
mode to be used subsequently(后来) is enclosed in square brackets.  Writing one of
the other strings present in /sys/power/mem_sleep to it causes the suspend mode
to be used subsequently to change to the one represented by that string.

Consequently, there are two ways to cause the system to go into the
Suspend-To-Idle sleep state.  The first one is to write "freeze" directly to
/sys/power/state.  The second one is to write "s2idle" to /sys/power/mem_sleep
and then to write "mem" to /sys/power/state.  Similarly, there are two ways
to cause the system to go into the Power-On Suspend sleep state (the strings to
write to the control files in that case are "standby(待机)" or "shallow" and "mem",
respectively) if that state is supported by the platform.  In turn, there is
only one way to cause the system to go into the Suspend-To-RAM state (write
"deep" into /sys/power/mem_sleep and "mem" into /sys/power/state).

The default suspend mode (ie. the one to be used without writing anything into
/sys/power/mem_sleep) is either "deep" (if Suspend-To-RAM is supported) or
"s2idle", but it can be overridden by the value of the "mem_sleep_default"
parameter in the kernel command line.

The properties of all of the sleep states are described below.


State:		Suspend-To-Idle
ACPI state:	S0
Label:		"s2idle" ("freeze")

This state is a generic, pure software, light-weight, system sleep state.
It allows more energy to be saved relative to runtime idle by freezing user
space and putting all I/O devices into low-power states (possibly
lower-power than available at run time), such that the processors can
spend more time in their idle states.

This state can be used for platforms without Power-On Suspend/Suspend-to-RAM
support, or it can be used in addition to Suspend-to-RAM to provide reduced
resume latency(延迟).  It is always supported.


State:		Standby / Power-On Suspend
ACPI State:	S1
Label:		"shallow" ("standby")

This state, if supported, offers moderate（中等）, though real, power savings, while
providing a relatively low-latency transition back to a working system.  No
operating state is lost (the CPU retains power), so the system easily starts up
again where it left off.

In addition to freezing user space and putting all I/O devices into low-power
states, which is done for Suspend-To-Idle too, nonboot CPUs are taken offline
and all low-level system functions are suspended during transitions into this
state.  For this reason, it should allow more energy to be saved relative to
Suspend-To-Idle, but the resume latency will generally be greater than for that
state.


State:		Suspend-to-RAM
ACPI State:	S3
Label:		"deep"

This state, if supported, offers significant（重大的） power savings as everything in the
system is put into a low-power state, except for memory, which should be placed
into the self-refresh mode to retain(保留) its contents.  All of the steps carried out
when entering Power-On Suspend are also carried out during transitions to STR.
Additional operations may take place depending on the platform capabilities.  In
particular, on ACPI systems the kernel passes control to the BIOS (platform
firmware) as the last step during STR transitions and that usually results in
powering down some more low-level components that aren't directly controlled by
the kernel.

System and device state is saved and kept in memory.  All devices are suspended
and put into low-power states.  In many cases, all peripheral(外围设备) buses lose power
when entering STR, so devices must be able to handle the transition back to the
"on" state.

For at least(最小的) ACPI, STR requires some minimal boot-strapping code to resume the
system from it.  This may be the case on other platforms too.


State:		Suspend-to-disk
ACPI State:	S4
Label:		"disk"

This state offers the greatest power savings, and can be used even in
the absence of low-level platform support for power management. This
state operates similarly to Suspend-to-RAM, but includes a final step
of writing memory contents to disk. On resume, this is read and memory
is restored to its pre-suspend state.

STD can be handled by the firmware or the kernel. If it is handled by
the firmware, it usually requires a dedicated partition that must be
setup via another operating system for it to use. Despite the
inconvenience, this method requires minimal work by the kernel, since
the firmware will also handle restoring memory contents on resume.

For suspend-to-disk, a mechanism called 'swsusp' (Swap Suspend) is used
to write memory contents to free swap space. swsusp has some restrictive
requirements, but should work in most cases. Some, albeit outdated,
documentation can be found in Documentation/power/swsusp.txt.
Alternatively, userspace can do most of the actual suspend to disk work,
see userland-swsusp.txt.

Once memory state is written to disk, the system may either enter a
low-power state (like ACPI S4), or it may simply power down. Powering
down offers greater savings, and allows this mechanism to work on any
system. However, entering a real low-power state allows the user to
trigger wake up events (e.g. pressing a key or opening a laptop lid).

- On (on)									S0 -  Working（s0的状态应该是freeze）

- Standby (standby)						S1 -  CPU and RAM are powered but not executed

- Suspend to RAM (mem)					S3 -  RAM is powered and the running content is saved to RAM

- Suspend to Disk，Hibernation (disk)			S4 -  All content is saved to Disk and power down

S1状态简称standby状态，此状态下CPU处于低功耗状态，并且没有数据保存到RAM或者disk中，此状态待机和恢复通常很快。

S3 aka STR(suspend to ram),挂起到内存，简称待机。计算机将目前的运行状态等数据存放在内存，关闭硬 盘、外设等设备，进入等待状态。此时内存仍然需要电力维持其数据，但整机耗电很少。恢复时计算机从内存读出数据，回到挂起前的状态，恢复速度较快。对 DDR的耗电情况进行优化是S3性能的关键，大多数手持设备都是用S3待机。此状态下计算机会冻结所有的活动并将当前工作状态保存到RAM中，然后关闭屏幕进入低功耗模式，通常睡眠和唤醒需要几秒

S4 aka STD(suspend to disk),挂起到硬盘，简称休眠。把运行状态等数据存放在硬盘上某个文件或者某个特定的区域，关闭硬盘、外设等设备，进入关机状态。此时计算机完全关闭，不耗电。恢复时计算机从休眠文件/分区中读出数据，回到休眠前的状态，恢复速度较慢。电子书项目中，见过一款索尼的电子书，没有定义关机状态，只定义了S4,从而提高开机速度。一般在window系统中常见到。此状态下计算机将所有活动的状态保存到磁盘中，然后处于关机状态，此模式下是不耗电的，而相比之前的模式，休眠和唤醒的速度都比较慢。
					</div>
				</div>
			</section>
			<section>
				<h3>open port in iptabls or firewalld</h3>
				<p>
					#iptables is(in CentOS 7 not use this):
					<br/>
					#add a data receive rule
					<br/>
					<span class="shell_instruction">iptables -A INPUT -p tcp --dport 22 -j ACCEPT</span>
					<br/>
					#add a data post rule
					<br/>
					<span class="shell_instruction">iptables -A OUTPUT -p tcp --sport 22 -j ACCEPT</span>
					<br/>
					#restart iptables service
					<br/>
					<span class="shell_instruction">service sshd restart</span>
					<br/>
					<br/>

					#firewalld is(in CentOS 7 use this):
					<br/>
					#add a rule, with option parameter --permanent to persistent the rule
					<br/>
					<span class="shell_instruction">firewall-cmd --permanent --add-port=22/tcp</span>
					<br/>
					#restart firewalld service
					<br/>
					<span class="shell_instruction">systemctl restart firewalld</span>
					<br/>
					#ensure the new rule is active
					<br/>
					<span class="shell_instruction">firewall-cmd --query-port=22/tcp</span>
					<br/>
				</p>
			</section>
			<section>
				<h3>set sshd service start with OS boot and start at now</h3>
				<p>
					#query ssdh service status
					<br/>
					<span class="shell_instruction">systemctl status sshd</span>
					<br/>
					#output the follow information
					<br/>
					<span style="color : blue">
					● sshd.service - OpenSSH server daemon
					<br/>
					&nbsp;&nbsp;&nbsp;Loaded: loaded (/usr/lib/systemd/system/sshd.service; disabled; vendor preset: enabled)
					<br/>
					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Active: inactive (dead)
					<br/>
				    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Docs: man:sshd(8)
					<br/>
				    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;man:sshd_config(5)
					</span>
					<br/>
					#so we see the Loaded: loaded (/usr/lib/systemd/system/sshd.service; disabled; vendor preset: enabled)
					<br/>
					#the service is not start with OS boot, so we set it start with OS boot
					<br/>
					<span class="shell_instruction">systemctl enable sshd</span>
					<br/>
					#we also see Active: inactive (dead), that means the service is not run at current time, we start it at now
					<br/>
					<span class="shell_instruction">systemctl start sshd</span>
					<br/>
				</p>
			</section>
			<section>
				<h3>双系统, 修复windows启动项</h3>
				<p>
					修改/boot/grub2/grub.cfg
					<br/>
					找到在两个menuentry末尾添加一个win7启动设置，具体参数是
					<br/>
					menuentry	‘win7’{
						<br/>
						<span class="class___tab_place"></span>set root=(hd0,1)
						<br/>
						<span class="class___tab_place"></span>chainloader +1 
						<br/>
					}
				</p>
			</section>
			<section>
				<h3>su</h3>
				<div>
					<span class="shell_instruction">su root</span>
					<br/>
					以root用户身份新建一个子shell并切换到这个shell进程中, 但保持当前状态的环境变量
					<br/>
					<br/>
					<span class="shell_instruction">su - root</span>
					<br/>
					新建并以root用户身份登陆一个子shell进程, 切换为root用户的环境变量
				</div>
			</section>
			<section>
				<h3>清屏命令</h3>
				<p>
					<span class="shell_instruction">clear</span>
					<br/>
					or
					<br/>
					ctrl + l
					<br/>
					刷新屏幕，本质上只是让终端显示页向后翻了一页，如果向上滚动屏幕还可以看到之前的操作信息。
				</p>
				<p>
					<span class="shell_instruction">reset</span>
					<br/>
					完全刷新终端屏幕，之前的终端输入操作信息将都会被清空，这样虽然比较清爽，但整个命令过程速度有点慢，使用较少。
					<br/>
					值得一提的是reset命令在你的终端控制错乱时非常有用。如输入字符不出现在光标的位置的情况。还有当你敲击回车键时，新提示符并没有出现在新行上而是出现在老提示符的前面。此时reset命令就能用来修正这些问题。
				</p>
				<p>
					<span class="shell_instruction">printf '\033c'</span>
					<br/>
					真正的清空了终端屏幕，它的功能跟DOS里CMD.EXE提供的CLS效果很相似。
					<br/>
					工作原理是
					<br/>
					\033  ==  \x1B == 27 == ESC
					<br/>
					于是，这个命令变成了<ESC>c，它是VT-XXX中表示“Full Reset (RIS)”的转义码。现今我们使用的所有的终端都是VT兼容的，它的另一种实现方式也可以这样：
					<br/>
					键盘上Ctrl+v---&gt;Esc--&gt;输入c再回加。但如果你发现自己使用的是一个非常奇怪的终端（如在putty上），那这个命令你可能用不了。
					<br/>
					 printf是bash里内置的命令，内置命令的优先级比其它可执行文件要高。
					<br/>
					 or
					<br/>
					<span class="shell_instruction">printf '\ec'</span>
					<br/>
					\e等价于\033
					<br/>
					 or
					<br/>
					<span class="shell_instruction">echo -e '\ec\c'</span>
					<br/>
					 or
					<br/>
					<span class="shell_instruction">echo -e '\033c\c'</span>
					<br/>
					 or
					<br/>
					<span class="shell_instruction">echo -en '\ec'</span>
					<br/>
					 or
					<br/>
					<span class="shell_instruction">echo -en '\033c'</span>
				</p>
			</section>
			<section>
				<h3>操作目录命令</h3>
				<p>
					回到刚才的目录
					<br/>
					<span class="shell_instruction">cd -</span>
				</p>
				<p>
					目录压栈
					<br/>
					<span class="shell_instruction">pushd .</span>
				</p>
				<p>
					目录出栈
					<br/>
					<span class="shell_instruction">popd</span>
				</p>
			</section>
			<section>
				<h3>查看内存</h3>
				<p>
					<span class="shell_instruction">free</span>
				</p>
			</section>
			<section>
				<h3>sync手动将存放在内存中的数据刷新到磁盘中</h3>
				<p>
					<span class="shell_instruction">sync</span>
					Linux内核为了达到最佳的磁盘操作效率，会把需要写入到磁盘的数据现在内存中缓存起来，在合适的时候才真正写入到磁盘中，这在绝大多数情况都是没有任何问题的，而且提高了系统的效率，但是如果系统当机、掉电，就会有些文件内容不会保存下来。在Linux系统关机或者重启时，会自动把缓冲区的内容自动同步到磁盘中。我们也可以手工去执行sync命令，强制将内存中的文件缓冲内容写到磁盘，这个命令是通过调用sync系统调用来实现的。（flush file system buffers。
					<br/>
					Synchronize data on disk with memory。Force changed blocks to disk, update the super block.`sync' writes any data buffered in memory out to disk.
					<br/>
					This can include (but is not limited to) modified superblocks, modified inodes, and delayed reads and writes.
					<br/>
					This must be implemented by the kernel; The `sync' program does nothing but exercise the `sync' system call.
					<br/>
					The kernel keeps data in memory to avoid doing (relatively slow) disk reads and writes.
					<br/>
					This improves performance, but if the computer crashes, data may be lost or the file system corrupted as a result.
					<br/>
					The `sync' command ensures everything in memory is written to disk.）
				</p>
			</section>
			<section>
				<h3>帮助,查找命令</h3>
				<p>
					<span class="shell_instruction">man -k key_word</span>
					<br/>
					-k : 列出包含在下一个参数中的字符的命令
				</p>
			</section>
			<section>
				<h3>生成ssh协议秘钥</h3>
				<p>
					use ssh-keygen instruction
				</p>
				<p>
					<span class="shell_instruction">ssh-keygen -t rsa -C email@domain</span>
					<br/>
					-t : 在下一个参数中指定加密算法
					<br/>
					-C : 在下一个参数中指定注释
				</p>
			</section>
			<section>
				<h3>encrypt and decrypt file with symmetric algorithm(文件加密解密使用对称算法)</h3>
				<p>
					use openssl, encrypt file by the follow instruction
				</p>
				<p>
					<span class="shell_instruction">openssl enc -des3 -a -salt -in source_file -out target_file [-pass password]</span>
					<br/>
					-des3 : 为加密算法(可以根据自己需要选择).
					<br/>
					-a : 对加密后的数据进行base64编码，或解密前，先对数据进行base64解码.
					<br/>
					-salt : 加盐,这是一个神奇的选项，加盐后，相同的明文可以得到不同的密文。默认情况下，盐值是随机生成的，可以使用-S选项明确指定盐值.
					<br/>
					-in : 在下一个参数中指定要加密的源文件.
					<br/>
					-out : 在下一个参数中指定加密后的文件.
					<br/>
					-pass : 在下一个参数中指定密码, 不加此参数则会在运行时等待用户输入密码,并以*号显示.
				</p>
				<p>
					use openssl, decrypt file by the follow instruction
				</p>
				<p>
					<span class="shell_instruction">openssl enc -d -des3 -a -salt -in source_file -out target_file [-pass password]</span>
					<br/>
					-d : 解密.
					<br/>
					-des3 : 为加密算法(可以根据自己需要选择).
					<br/>
					-a : 对加密后的数据进行base64编码，或解密前，先对数据进行base64解码.
					<br/>
					-salt : 加盐,这是一个神奇的选项，加盐后，相同的明文可以得到不同的密文。默认情况下，盐值是随机生成的，可以使用-S选项明确指定盐值.
					<br/>
					-in : 在下一个参数中指定要加密的源文件.
					<br/>
					-out : 在下一个参数中指定加密后的文件.
					<br/>
					-pass : 在下一个参数中指定密码, 不加此参数则会在运行时等待用户输入密码,并以*号显示.
				</p>
			</section>
		</article>
	</body>
</html>
