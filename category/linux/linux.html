<!doctype html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0,minimum-scale=1.0,user-scalable=0" />
		<title>Linux</title>
		<style>
			.class___line_head {
				margin-left : 2em;
			}
			.class___tab_place {
				margin-left : 2em;
			}
			.class___center {
				text-align : center;
				width : 100%;
				display : inline-block;
			}
			.class___shell, .shell_instruction {
				color : yellow;
				background-color : black;
				font-weight : 800;
				padding : 4px;
			}
			header > div {
				padding-left : 2em;
				line-height : 180%;
			}
			section > p {
				padding-left : 2em;
				line-height : 180%;
			}
			section > div {
				padding-left : 2em;
				line-height : 180%;
			}
			.class___copy_other_people_content {
				background-color : #aef5a8;
			}
		</style>
		<script>
			const add_fold = function(currentScript) {
				const cs = currentScript;
				const pn = cs.parentNode;
				const ppn = pn.parentNode;
				ppn.children[0].addEventListener('click', function(e) {
					let display = pn.style.getPropertyValue('display');
					if (display) {
						ppn.children[0].textContent = '-';
						pn.style.removeProperty('display');
					} else {
						ppn.children[0].textContent = '+';
						pn.style.setProperty('display', 'none');
					}
				});
			}
		</script>
		<style>
			.class___menu_item {
				cursor : pointer;
				color : green;
				box-shadow: 0 0 1px 1px #71f4dc;
			}
			.class___menu_item:hover {
				color : red;
				text-shadow: 2px 2px 2px gray;
				box-shadow: 0 0 4px 4px gray;
			}
			.class___menu_close_button {
				cursor : pointer;
				text-align : center;
				border : 1px solid black;
				margin-top : 10px;
				color : black;
				width: 80px;
				margin-left: calc(50% - 40px);
			}
			.class___menu_close_button:hover {
				color : red;
				text-shadow: 2px 2px 2px gray;
			}
			.class___show_menu_button {
				cursor : pointer;
				text-align : center;
				border : 1px solid black;
				color : black;
				background-color : #f0d278;
				width: 40px;
				height : 40xp;
				position : fixed;
				right : 0;
				top : 0;
			}
			.class___show_menu_button:hover {
				color : red;
				text-shadow: 2px 2px 2px gray;
				text-shadow: 2px 2px 2px gray;
			}
		</style>
		<script>
			{
				const onload_event_function_array = [];
				onload_event_function_array.push((e) => {//添加目录函数
					const dom_array = Object.values(document.body.children[0].children).slice(1);
					const dom__menu = document.createElement('div');
					dom__menu.style.cssText = `
						position: fixed;
						left: 0;
						top: 0;
						height: 100%;
						width: 100%;
						background-color: #f0d278;
						overflow: auto;
					`;
					console.log(dom__menu.style.cssText);
					dom_array.forEach((dom) => {
						const dom__menu_item = document.createElement('div');
						dom__menu_item.className = 'class___menu_item';
						dom__menu_item.textContent = dom.children[0].textContent;
						dom__menu_item.onclick = function(e) {
							dom.scrollIntoView(true);
							dom__menu.style.display = 'none';
						};
						dom__menu.appendChild(dom__menu_item);
					});
					const dom__menu_close_button = document.createElement('div');
					dom__menu_close_button.textContent = '关闭目录';
					dom__menu_close_button.className = 'class___menu_close_button';
					dom__menu_close_button.onclick = (e) => {
						dom__menu.style.display = 'none';
					}
					dom__menu.appendChild(dom__menu_close_button);

					const dom__show_menu_button = document.createElement('div');
					dom__show_menu_button.className = 'class___show_menu_button';
					dom__show_menu_button.textContent = '显示目录';
					dom__show_menu_button.onclick = (e) => {
						//dom__show_menu_button.style.display = 'none';
						dom__menu.style.display = 'block';
					}

					document.body.appendChild(dom__show_menu_button);
					document.body.appendChild(dom__menu);
				});
				window.onload = (e) => {
					onload_event_function_array.forEach((f) => {
						f(e);
					});
				}
			}
		</script>
	</head>
	<body>
		<article>
			<header>
				<h3>Linux</h3>
				<div>
					Linux spread log.
				</div>
			</header>
			<section>
				<h3>杂</h3>
				<div>
					<a target="_blank" href="https://www.cnblogs.com/persist/p/5197561.html">.bash_profile和.bashrc的区别(如何设置生效) - 雨做的云 - 博客园</a>
					<div>
						<span style="display : inline-block; border : 1px solid black; width : 14px; text-align : center;">+</span><span>为防链接失效的本地截图</span>
						<div style="display:none;">
							<script>add_fold(document.currentScript);</script>
							<img src="./refs/imgs/bash_profile和bashrc的区别.png"/>
						</div>
					</div>
				</div>
			</section>
			<section>
				<h3 class="class___copy_other_people_content">【Grub2】制作UEFI版本Grub2引导</h3>
				<div>
					<img src="./refs/制作UEFI版本Grub2引导_grub2-mkimage.png"/>
				</div>
			</section>
			<section>
				<h3>如何在Linux中查看所有正在运行的进程</h3>
				<div>

				</div>
			</section>
			<section>
				<h3>如何在Linux中查看所有正在运行的进程</h3>
				<div>

				</div>
			</section>
			<section>
				<h3>linux ps 命令参数详解</h3>
				<div>
					<div class="class___code class___copy_other_people_content">
						linux&nbsp;ps&nbsp;命令参数详解<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;-a&nbsp;&nbsp;显示所有终端机下执行的进程，除了阶段作业领导者之外。<br/>
						　　&nbsp;a&nbsp;&nbsp;显示现行终端机下的所有进程，包括其他用户的进程。<br/>
						　　-A&nbsp;&nbsp;显示所有进程。<br/>
						　　-c&nbsp;&nbsp;显示CLS和PRI栏位。<br/>
						　　&nbsp;c&nbsp;&nbsp;列出进程时，显示每个进程真正的指令名称，而不包含路径，参数或常驻服务的标示。<br/>
						　　-C&lt;指令名称&gt;&nbsp;　指定执行指令的名称，并列出该指令的进程的状况。<br/>
						　　-d&nbsp;　显示所有进程，但不包括阶段作业领导者的进程。<br/>
						　　-e&nbsp;　此参数的效果和指定"A"参数相同。<br/>
						　　&nbsp;e&nbsp;　列出进程时，显示每个进程所使用的环境变量。<br/>
						　　-f&nbsp;　显示UID,PPIP,C与STIME栏位。<br/>
						　　&nbsp;f&nbsp;　用ASCII字符显示树状结构，表达进程间的相互关系。<br/>
						　　-g&lt;群组名称&gt;&nbsp;　此参数的效果和指定"-G"参数相同，当亦能使用阶段作业领导者的名称来指定。<br/>
						　　&nbsp;g&nbsp;　显示现行终端机下的所有进程，包括群组领导者的进程。<br/>
						　　-G&lt;群组识别码&gt;&nbsp;　列出属于该群组的进程的状况，也可使用群组名称来指定。<br/>
						　　&nbsp;h&nbsp;　不显示标题列。<br/>
						　　-H&nbsp;　显示树状结构，表示进程间的相互关系。<br/>
						　　-j或j&nbsp;　采用工作控制的格式显示进程状况。<br/>
						　　-l或l&nbsp;　采用详细的格式来显示进程状况。<br/>
						　　&nbsp;L&nbsp;　列出栏位的相关信息。<br/>
						　　-m或m&nbsp;　显示所有的执行绪。<br/>
						　　&nbsp;n&nbsp;　以数字来表示USER和WCHAN栏位。<br/>
						　　-N&nbsp;　显示所有的进程，除了执行ps指令终端机下的进程之外。<br/>
						　　-p&lt;进程识别码&gt;&nbsp;　指定进程识别码，并列出该进程的状况。<br/>
						　&nbsp;　p&lt;进程识别码&gt;&nbsp;　此参数的效果和指定"-p"参数相同，只在列表格式方面稍有差异。<br/>
						　　&nbsp;r&nbsp;　只列出现行终端机正在执行中的进程。<br/>
						　　-s&lt;阶段作业&gt;&nbsp;　指定阶段作业的进程识别码，并列出隶属该阶段作业的进程的状况。<br/>
						　&nbsp;　s&nbsp;　采用进程信号的格式显示进程状况。<br/>
						　　&nbsp;S&nbsp;　列出进程时，包括已中断的子进程资料。<br/>
						　　-t&lt;终端机编号&gt;&nbsp;　指定终端机编号，并列出属于该终端机的进程的状况。<br/>
						　　&nbsp;t&lt;终端机编号&gt;&nbsp;　此参数的效果和指定"-t"参数相同，只在列表格式方面稍有差异。<br/>
						　　-T&nbsp;　显示现行终端机下的所有进程。<br/>
						　　-u&lt;用户识别码&gt;&nbsp;　此参数的效果和指定"-U"参数相同。<br/>
						　　&nbsp;u&nbsp;　以用户为主的格式来显示进程状况。<br/>
						　　-U&lt;用户识别码&gt;&nbsp;　列出属于该用户的进程的状况，也可使用用户名称来指定。<br/>
						　　&nbsp;U&lt;用户名称&gt;&nbsp;　列出属于该用户的进程的状况。<br/>
						　　&nbsp;v&nbsp;　采用虚拟内存的格式显示进程状况。<br/>
						　　-V或V&nbsp;　显示版本信息。<br/>
						　　-w或w&nbsp;　采用宽阔的格式来显示进程状况。　<br/>
						　&nbsp;　x&nbsp;　显示所有进程，不以终端机来区分。<br/>
						　　&nbsp;X&nbsp;　采用旧式的Linux&nbsp;i386登陆格式显示进程状况。<br/>
						　　&nbsp;-y&nbsp;配合参数"-l"使用时，不显示F(flag)栏位，并以RSS栏位取代ADDR栏位。<br/>
						<br/>
						常用组合<br/>
						<br/>
						ps&nbsp;-ef<br/>
						ps&nbsp;aux&nbsp;或&nbsp;ps&nbsp;-aux<br/>
						ps&nbsp;auxc&nbsp;或&nbsp;ps&nbsp;-auxc<br/>
						ps&nbsp;axjf&nbsp;或&nbsp;ps&nbsp;-axjf<br/>
						ps&nbsp;axjfc&nbsp;或&nbsp;ps&nbsp;-axjfc<br/>
					</div>
				</div>
			</section>
			<section>
				<h3>Linux下进程占用CPU100%的解决方法</h3>
				<div>
					<div class="class___code class___copy_other_people_content">
						Linux下进程占用CPU100%的解决方法<br/>
						<br/>
						linux&nbsp;也会遇到进程占用CPU100%.<br/>
						<br/>
						步骤是:<br/>
						<br/>
						1)先top,查看进程运行状况,包括进程ID,CPU占用率等.Linux还是比较友好的,他会把CPU使用率最大的放在最上面,很快我就找到了罪魁祸首:ID:20641&nbsp;...<br/>
						<br/>
						2)找到了进程,那再仔细看一下也无妨,然后ps&nbsp;ax,查看进程运行状况.可以查看到进程的ID号,那个用户在使用,进程命令是什么等.<br/>
						<br/>
						3)情况了解了,原来是vi&nbsp;init在作怪,用kill&nbsp;-9&nbsp;20641强制干掉此进程.<br/>
						<br/>
						再TOP一次.好了,CPU使用率恢复正常了.<br/>
						<br/>
						附命令用法:<br/>
						1.top<br/>
						使用权限：所有使用者<br/>
						使用方式：top&nbsp;[-][d&nbsp;delay][q][c][S][s][n]<br/>
						说明：即时显示process的动态<br/>
						参数:<br/>
						d:改变显示的更新速度，或是在交谈式指令列(interactive&nbsp;command)按s<br/>
						q:没有任何延迟的显示速度，如果使用者是有superuser的权限，则top将会以最高的优先序执行<br/>
						c:切换显示模式，共有两种模式，一是只显示执行档的名称，另一种是显示完整的路径与名称S:累积模式，会将己完成或消失的子行程&nbsp;(dead&nbsp;child&nbsp;process&nbsp;)的CPU&nbsp;time累积起来<br/>
						s:安全模式，将交谈式指令取消,避免潜在的危机<br/>
						i:不显示任何闲置(idle)或无用(zombie)的行程<br/>
						n:更新的次数，完成后将会退出top<br/>
						b:批次档模式，搭配"n"参数一起使用，可以用来将top的结果输出到档案内<br/>
						范例：<br/>
						显示更新十次后退出&nbsp;;<br/>
						top&nbsp;-n&nbsp;10<br/>
						使用者将不能利用交谈式指令来对行程下命令&nbsp;:<br/>
						top&nbsp;-s<br/>
						将更新显示二次的结果输入到名称为&nbsp;top.log&nbsp;的档案里&nbsp;:<br/>
						top&nbsp;-n&nbsp;2&nbsp;-b&nbsp;&lt;&nbsp;top.log<br/>
						2.ps<br/>
						1）ps&nbsp;a&nbsp;显示现行终端机下的所有程序，包括其他用户的程序。<br/>
						2）ps&nbsp;-A&nbsp;显示所有程序。<br/>
						3）ps&nbsp;c&nbsp;列出程序时，显示每个程序真正的指令名称，而不包含路径，参数或常驻服务的标示。<br/>
						4）ps&nbsp;-e&nbsp;此参数的效果和指定"A"参数相同。<br/>
						5）ps&nbsp;e&nbsp;列出程序时，显示每个程序所使用的环境变量。<br/>
						6）ps&nbsp;f&nbsp;用ASCII字符显示树状结构，表达程序间的相互关系。<br/>
						7）ps&nbsp;-H&nbsp;显示树状结构，表示程序间的相互关系。<br/>
						8）ps&nbsp;-N&nbsp;显示所有的程序，除了执行ps指令终端机下的程序之外。<br/>
						9）ps&nbsp;s&nbsp;采用程序信号的格式显示程序状况。<br/>
						10）ps&nbsp;S&nbsp;列出程序时，包括已中断的子程序资料。<br/>
						11）ps&nbsp;-t&lt;终端机编号&gt;&nbsp;　指定终端机编号，并列出属于该终端机的程序的状况。<br/>
						12）ps&nbsp;u&nbsp;　以用户为主的格式来显示程序状况。<br/>
						13）ps&nbsp;x&nbsp;　显示所有程序，不以终端机来区分。<br/>
						最常用的方法是ps&nbsp;-aux,然后再利用一个管道符号导向到grep去查找特定的进程,然后再对特定的进程进行操作。<br/>
					</div>
				</div>
			</section>
			<section>
				<h3>如何在Linux中查看所有正在运行的进程</h3>
				<div>
					<div class="class___code class___copy_other_people_content">
						如何在Linux中查看所有正在运行的进程<br/>
						<br/>
						你可以使用ps命令。它能显示当前运行中进程的相关信息，包括进程的PID。Linux和UNIX都支持ps命令，显示所有运行中进程的相关信息。ps命令能提供一份当前进程的快照。如果你想状态可以自动刷新，可以使用top命令。<br/>
						<br/>
						ps命令<br/>
						<br/>
						输入下面的ps命令，显示所有运行中的进程：<br/>
						<br/>
						#&nbsp;ps&nbsp;aux&nbsp;|&nbsp;less<br/>
						<br/>
						其中，<br/>
						-A：显示所有进程<br/>
						<br/>
						a：显示终端中包括其它用户的所有进程<br/>
						<br/>
						x：显示无控制终端的进程<br/>
						<br/>
						任务：查看系统中的每个进程。<br/>
						<br/>
						#&nbsp;ps&nbsp;-A<br/>
						#&nbsp;ps&nbsp;-e<br/>
						<br/>
						任务：查看非root运行的进程<br/>
						<br/>
						<br/>
						#&nbsp;ps&nbsp;-U&nbsp;root&nbsp;-u&nbsp;root&nbsp;-N<br/>
						<br/>
						<br/>
						任务：查看用户vivek运行的进程<br/>
						<br/>
						#&nbsp;ps&nbsp;-u&nbsp;vivek<br/>
						<br/>
						<br/>
						任务：top命令<br/>
						<br/>
						top命令提供了运行中系统的动态实时视图。在命令提示行中输入top：<br/>
						<br/>
						#&nbsp;top<br/>
						<br/>
						<br/>
						<br/>
						按q退出，按h进入帮助。<br/>
						<br/>
						任务：显示进程的树状图。<br/>
						<br/>
						pstree以树状显示正在运行的进程。树的根节点为pid或init。如果指定了用户名，进程树将以用户所拥有的进程作为根节点。<br/>
						<br/>
						$&nbsp;pstree<br/>
						<br/>
						<br/>
						任务：使用ps列印进程树<br/>
						<br/>
						#&nbsp;ps&nbsp;-ejH<br/>
						#&nbsp;ps&nbsp;axjf<br/>
						<br/>
						<br/>
						任务：获得线程信息<br/>
						<br/>
						输入下列命令：<br/>
						<br/>
						#&nbsp;ps&nbsp;-eLf<br/>
						#&nbsp;ps&nbsp;axms<br/>
						<br/>
						<br/>
						任务：获得安全信息<br/>
						<br/>
						输入下列命令：<br/>
						<br/>
						#&nbsp;ps&nbsp;-eo&nbsp;euser,ruser,suser,fuser,f,comm,label<br/>
						#&nbsp;ps&nbsp;axZ<br/>
						#&nbsp;ps&nbsp;-eM<br/>
						<br/>
						<br/>
						任务：将进程快照储存到文件中<br/>
						<br/>
						输入下列命令：<br/>
						<br/>
						#&nbsp;top&nbsp;-b&nbsp;-n1&nbsp;&gt;&nbsp;/tmp/process.log<br/>
						<br/>
						<br/>
						你也可以将结果通过邮件发给自己：<br/>
						<br/>
						#&nbsp;top&nbsp;-b&nbsp;-n1&nbsp;|&nbsp;mail&nbsp;-s&nbsp;'Process&nbsp;snapshot'&nbsp;you@example.com<br/>
						<br/>
						<br/>
						任务：查找进程<br/>
						<br/>
						使用pgrep命令。pgrep能查找当前正在运行的进程并列出符合条件的进程ID。例如显示firefox的进程ID：<br/>
						<br/>
						$&nbsp;pgrep&nbsp;firefox<br/>
						<br/>
						<br/>
						下面命令将显示进程名为sshd、所有者为root的进程。<br/>
						<br/>
						$&nbsp;pgrep&nbsp;-u&nbsp;root&nbsp;sshd<br/>
						<br/>
						<br/>
						向htop和atop说hello<br/>
						<br/>
						htop是一个类似top的交互式进程查看工具，但是可以垂直和水平滚动来查看所有进程和他们的命令行。进程的相关操作(killing，renicing)不需要输入PID。要安装htop输入命令：<br/>
						<br/>
						#&nbsp;apt-get&nbsp;install&nbsp;htop<br/>
						<br/>
						或<br/>
						<br/>
						#&nbsp;yum&nbsp;install&nbsp;htop<br/>
						<br/>
						在命令提示行中输入htop：<br/>
						<br/>
						#&nbsp;htop<br/>
						<br/>
						atop工具<br/>
						<br/>
						atop是一个用来查看Linux系统负载的交互式监控工具。它能展现系统层级的关键硬件资源(从性能角度)的使用情况，如CPU、内存、硬盘和网络。<br/>
						<br/>
						它也可以根据进程层级的CPU和内存负载显示哪个进程造成了特定的负载;如果已经安装内核补丁可以显示每个进程的硬盘和网络负载。输入下面的命令启动atop：<br/>
						<br/>
						#&nbsp;atop<br/>
					</div>
				</div>
			</section>
			<section>
				<h3>parted命令分区--(GPT分区)</h3>
				<div>
					<div class="class___code class___copy_other_people_content">
						parted命令分区--(GPT分区)<br/>
						<br/>
						MBR分区表(主引导记录分区表):2.1TB(1TB=1024GB).<br/>
						<br/>
						①最多支持4个主分区.<br/>
						<br/>
						②扩展分区只能有一个,并且扩展分区与主分区之和不超过4,扩展分区内不能写数据,只&nbsp;&nbsp;&nbsp;&nbsp;能写入逻辑分区.<br/>
						<br/>
						③逻辑分区可以有10个.<br/>
						<br/>
						GPT分区表(也叫GUID分区表,全局唯一标示分区表):9.4ZB(GB-TB-EB-PB-ZB&nbsp;1024进制),最多支持128个分区.其中1个作为系统保留分区,剩余127个为用户自定义分区.<br/>
						<br/>
						&nbsp;<br/>
						<br/>
						parted命令直接建立的分区是ext2格式,并且,如果通过mkfs格式化为ext4,parted进行resize动态调整分区大小会失败.parted命令能够识别MBR分区表,显示为msdos.<br/>
						<br/>
						&nbsp;<br/>
						<br/>
						&nbsp;<br/>
						<br/>
						[root@localhost&nbsp;~]#&nbsp;parted&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#进入parted命令<br/>
						<br/>
						GNU&nbsp;Parted&nbsp;2.1<br/>
						<br/>
						使用&nbsp;/dev/sda&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#一定要看清楚,这是主磁盘,不能在这里做分区和格式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;化,不然系统将会无法开机<br/>
						<br/>
						Welcome&nbsp;to&nbsp;GNU&nbsp;Parted!&nbsp;Type&nbsp;'help'&nbsp;to&nbsp;view&nbsp;a&nbsp;list&nbsp;of&nbsp;commands.<br/>
						<br/>
						(parted)&nbsp;quit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#这是输入命令的位置,立马使用quit退出<br/>
						<br/>
						&nbsp;<br/>
						<br/>
						[root@localhost&nbsp;~]#&nbsp;parted&nbsp;/dev/sdb&nbsp;&nbsp;&nbsp;&nbsp;#使用parted命令必须加入参数<br/>
						<br/>
						GNU&nbsp;Parted&nbsp;2.1<br/>
						<br/>
						使用&nbsp;/dev/sdb<br/>
						<br/>
						Welcome&nbsp;to&nbsp;GNU&nbsp;Parted!&nbsp;Type&nbsp;'help'&nbsp;to&nbsp;view&nbsp;a&nbsp;list&nbsp;of&nbsp;commands.<br/>
						<br/>
						(parted)<br/>
						<br/>
						&nbsp;<br/>
						<br/>
						接下来进行如下几个实验:<br/>
						<br/>
						①建立GPT分区<br/>
						<br/>
						②已经建立分区进行扩容<br/>
						<br/>
						③mount挂载<br/>
						<br/>
						④自动加载GPT分区<br/>
						<br/>
						&nbsp;<br/>
						<br/>
						1.建立GPT分区:<br/>
						<br/>
						[root@localhost&nbsp;~]#&nbsp;parted<br/>
						<br/>
						GNU&nbsp;Parted&nbsp;2.1<br/>
						<br/>
						使用&nbsp;/dev/sda<br/>
						<br/>
						Welcome&nbsp;to&nbsp;GNU&nbsp;Parted!&nbsp;Type&nbsp;'help'&nbsp;to&nbsp;view&nbsp;a&nbsp;list&nbsp;of&nbsp;commands.<br/>
						<br/>
						(parted)&nbsp;help<br/>
						<br/>
						&nbsp;<br/>
						<br/>
						接下来会显示一堆的命令列表和命令内容概括,主要有一下几个需要知道:<br/>
						<br/>
						①help&nbsp;&nbsp;&nbsp;&nbsp;#显示命令帮助文档,特别是命令的输入格式<br/>
						<br/>
						②mklabel&nbsp;mktable&nbsp;#2个都是建立新的分区表(硬盘标签),感觉还是mktable更加习惯,好记<br/>
						<br/>
						③mkfs&nbsp;&nbsp;&nbsp;&nbsp;#为分区写入文件系统<br/>
						<br/>
						④mkpart&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#创建新的分区<br/>
						<br/>
						⑤print&nbsp;&nbsp;&nbsp;&nbsp;#打印分区信息(已经创建的分区使用这个命令查看)<br/>
						<br/>
						⑥quit&nbsp;&nbsp;&nbsp;&nbsp;#退出parted命令<br/>
						<br/>
						⑦rm&nbsp;&nbsp;&nbsp;&nbsp;#删除分区<br/>
						<br/>
						⑧select&nbsp;&nbsp;&nbsp;&nbsp;#选择分区设备,可以切换磁盘<br/>
						<br/>
						&nbsp;<br/>
						<br/>
						(parted)&nbsp;mktable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#新建分区表<br/>
						<br/>
						新的磁盘标签类型？&nbsp;gpt&nbsp;#GPT分区表<br/>
						<br/>
						警告:&nbsp;The&nbsp;existing&nbsp;disk&nbsp;label&nbsp;on&nbsp;/dev/sdb&nbsp;will&nbsp;be&nbsp;destroyed&nbsp;and&nbsp;all&nbsp;data&nbsp;on&nbsp;this&nbsp;disk&nbsp;will&nbsp;be&nbsp;lost.&nbsp;Do&nbsp;you&nbsp;want&nbsp;to&nbsp;continue?&nbsp;&nbsp;&nbsp;&nbsp;#提示"新建分区表会摧毁所有存在磁盘中的数据",是否继续?<br/>
						<br/>
						是/Yes/否/No?&nbsp;y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#当然是啦<br/>
						<br/>
						(parted)&nbsp;print&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#显示结果<br/>
						<br/>
						Model:&nbsp;VMware,&nbsp;VMware&nbsp;Virtual&nbsp;S&nbsp;(scsi)<br/>
						<br/>
						Disk&nbsp;/dev/sdb:&nbsp;5369MB<br/>
						<br/>
						Sector&nbsp;size&nbsp;(logical/physical):&nbsp;512B/512B<br/>
						<br/>
						Partition&nbsp;Table:&nbsp;gpt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#是不是发现这里由msdos(表示MBR)变成了GPT<br/>
						<br/>
						&nbsp;<br/>
						<br/>
						(parted)&nbsp;mkpart&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#新建分区<br/>
						<br/>
						分区名称？&nbsp;[]?&nbsp;nigulasi1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#自己命名,比如说&nbsp;尼古拉斯&nbsp;哈哈<br/>
						<br/>
						文件系统类型？&nbsp;[ext2]?&nbsp;&nbsp;&nbsp;&nbsp;#只能默认ext2<br/>
						<br/>
						起始点？&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#起始点&nbsp;1M<br/>
						<br/>
						结束点？&nbsp;1G&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#结束点1G,注意下一个分区起始点不能小于1000M,也就是说要&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从1001M开始,不然会报错,告诉你已经分区了<br/>
						<br/>
						(parted)&nbsp;print&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#显示结果<br/>
						<br/>
						Model:&nbsp;VMware,&nbsp;VMware&nbsp;Virtual&nbsp;S&nbsp;(scsi)<br/>
						<br/>
						Disk&nbsp;/dev/sdb:&nbsp;5369MB<br/>
						<br/>
						Sector&nbsp;size&nbsp;(logical/physical):&nbsp;512B/512B<br/>
						<br/>
						Partition&nbsp;Table:&nbsp;gpt<br/>
						<br/>
						&nbsp;<br/>
						<br/>
						Number&nbsp;Start&nbsp;End&nbsp;Size&nbsp;File&nbsp;system&nbsp;Name&nbsp;标志<br/>
						<br/>
						1&nbsp;1049kB&nbsp;1000MB&nbsp;999MB&nbsp;ext2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nigulasi1<br/>
						<br/>
						&nbsp;<br/>
						<br/>
						2.已经建立的分区进行动态调整大小<br/>
						<br/>
						新建一个2G的分区<br/>
						<br/>
						&nbsp;<br/>
						<br/>
						(parted)&nbsp;resize&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#重新设置分区大小<br/>
						<br/>
						WARNING:&nbsp;you&nbsp;are&nbsp;attempting&nbsp;to&nbsp;use&nbsp;parted&nbsp;to&nbsp;operate&nbsp;on&nbsp;(resize)&nbsp;a&nbsp;file&nbsp;system.<br/>
						<br/>
						parted's&nbsp;file&nbsp;system&nbsp;manipulation&nbsp;code&nbsp;is&nbsp;not&nbsp;as&nbsp;robust&nbsp;as&nbsp;what&nbsp;you'll&nbsp;find&nbsp;in<br/>
						<br/>
						dedicated,&nbsp;file-system-specific&nbsp;packages&nbsp;like&nbsp;e2fsprogs.&nbsp;We&nbsp;recommend<br/>
						<br/>
						you&nbsp;use&nbsp;parted&nbsp;only&nbsp;to&nbsp;manipulate&nbsp;partition&nbsp;tables,&nbsp;whenever&nbsp;possible.<br/>
						<br/>
						Support&nbsp;for&nbsp;performing&nbsp;most&nbsp;operations&nbsp;on&nbsp;most&nbsp;types&nbsp;of&nbsp;file&nbsp;systems<br/>
						<br/>
						will&nbsp;be&nbsp;removed&nbsp;in&nbsp;an&nbsp;upcoming&nbsp;release.<br/>
						<br/>
						起始点？&nbsp;[1001MB]?&nbsp;#起始点默认回车<br/>
						<br/>
						结束点？&nbsp;[3000MB]?&nbsp;2000M&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#结束点从3G改为2G(当前默认1G=1000M,方便计算)<br/>
						<br/>
						警告:&nbsp;A&nbsp;resize&nbsp;operation&nbsp;on&nbsp;this&nbsp;file&nbsp;system&nbsp;will&nbsp;use&nbsp;EXPERIMENTAL&nbsp;code<br/>
						<br/>
						that&nbsp;MAY&nbsp;CORRUPT&nbsp;it&nbsp;(although&nbsp;no&nbsp;one&nbsp;has&nbsp;reported&nbsp;any&nbsp;such&nbsp;damage&nbsp;yet).<br/>
						<br/>
						You&nbsp;should&nbsp;at&nbsp;least&nbsp;backup&nbsp;your&nbsp;data&nbsp;first,&nbsp;and&nbsp;run&nbsp;'e2fsck&nbsp;-f'&nbsp;afterwards.<br/>
						<br/>
						确认/OK/放弃/Cancel?&nbsp;ok&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#输入ok<br/>
						<br/>
						(parted)&nbsp;print&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#显示结果已经缩减大小<br/>
						<br/>
						Model:&nbsp;VMware,&nbsp;VMware&nbsp;Virtual&nbsp;S&nbsp;(scsi)<br/>
						<br/>
						Disk&nbsp;/dev/sdb:&nbsp;5369MB<br/>
						<br/>
						Sector&nbsp;size&nbsp;(logical/physical):&nbsp;512B/512B<br/>
						<br/>
						Partition&nbsp;Table:&nbsp;gpt<br/>
						<br/>
						&nbsp;<br/>
						<br/>
						Number&nbsp;Start&nbsp;End&nbsp;Size&nbsp;File&nbsp;system&nbsp;Name&nbsp;标志<br/>
						<br/>
						1&nbsp;1049kB&nbsp;900MB&nbsp;899MB&nbsp;ext2&nbsp;nigulasi1<br/>
						<br/>
						2&nbsp;1001MB&nbsp;2000MB&nbsp;999MB&nbsp;ext2&nbsp;nigulasi2<br/>
						<br/>
						(parted)&nbsp;quit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#退出<br/>
						<br/>
						其实resize按理来说可以变小,也可以变大,但是实际上扩容会报错,操作了十几遍只有一遍成功,确实很奇葩,这个parted工具还是不够完善,比如:操作resize后显示Warning:<br/>
						<br/>
						parted's&nbsp;file&nbsp;system&nbsp;manipulation&nbsp;code&nbsp;is&nbsp;not&nbsp;as&nbsp;robust&nbsp;as&nbsp;what&nbsp;you'll&nbsp;find&nbsp;in&nbsp;dedicated,&nbsp;file-system-specific&nbsp;packages&nbsp;like&nbsp;e2fsprogs.<br/>
						<br/>
						表示parted工具没有我们想的那么完善......毕竟我们马上要学习LVM逻辑卷组,以后只能用更高级的LVM,这些就当是回忆科技的过往吧.<br/>
						<br/>
						&nbsp;<br/>
						<br/>
						3.手动挂载<br/>
						<br/>
						[root@localhost&nbsp;~]#&nbsp;mkdir&nbsp;/mnt/sdb1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#设置挂载点(挂载点就是已经建立的空目录)<br/>
						<br/>
						[root@localhost&nbsp;~]#&nbsp;mkdir&nbsp;/mnt/sdb2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#设置挂载点,新建了2个分区,需要2个挂载点<br/>
						<br/>
						[root@localhost&nbsp;~]#&nbsp;mount&nbsp;/dev/sdb1&nbsp;/mnt/sdb1/&nbsp;&nbsp;&nbsp;&nbsp;#把第二块SCSI硬盘上的第一个分区挂载&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到/mnt/sdb1目录上<br/>
						<br/>
						[root@localhost&nbsp;~]#&nbsp;mount&nbsp;/dev/sdb2&nbsp;/mnt/sdb2/&nbsp;&nbsp;&nbsp;&nbsp;#把第二块SCSI硬盘上的第二个分区挂载&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到/mnt/sdb2目录上<br/>
						<br/>
						[root@localhost&nbsp;~]#&nbsp;df&nbsp;-h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#显示(只能看已经挂载的)磁盘信息,相当于双击打&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;开"我的电脑"后的显示效果<br/>
						<br/>
						Filesystem&nbsp;Size&nbsp;Used&nbsp;Avail&nbsp;Use%&nbsp;Mounted&nbsp;on<br/>
						<br/>
						/dev/sda5&nbsp;9.8G&nbsp;2.4G&nbsp;7.0G&nbsp;26%&nbsp;/<br/>
						<br/>
						tmpfs&nbsp;495M&nbsp;0&nbsp;495M&nbsp;0%&nbsp;/dev/shm<br/>
						<br/>
						/dev/sda1&nbsp;190M&nbsp;33M&nbsp;147M&nbsp;19%&nbsp;/boot<br/>
						<br/>
						/dev/sda3&nbsp;1.9G&nbsp;3.5M&nbsp;1.8G&nbsp;1%&nbsp;/home<br/>
						<br/>
						/dev/sdb1&nbsp;804M&nbsp;13K&nbsp;761M&nbsp;1%&nbsp;/mnt/sdb1<br/>
						<br/>
						/dev/sdb2&nbsp;893M&nbsp;13K&nbsp;845M&nbsp;1%&nbsp;/mnt/sdb2<br/>
						<br/>
						&nbsp;<br/>
						<br/>
						接下来可以cd&nbsp;/mnt/sdb1/进入该分区,挂载点相当于一个进入磁盘对应分区的对应"门",不同分区不同门,进入这个目录(也就是挂载点),也就是进入了分区,新建文件,目录,包括增删改查都是在第二块SCSI硬盘的第一个分区上进行操作!<br/>
						<br/>
						命令行输入的mount命令是临时生效的,重启后将会失效,因此我们要实现永久生效,那就是把"配置信息"或者命令写入对应文档,那么来看下一小节.<br/>
						<br/>
						&nbsp;<br/>
						<br/>
						4.自动挂载(/etc/fstab)<br/>
						<br/>
						Linux开机时查看/etc/fstab这个配置文件,按照配置信息进行自动挂载.<br/>
						<br/>
						我们需要把新建分区的信息按照对应的格式填入这个文件内,即可达到自动挂载效果.<br/>
						<br/>
						vi&nbsp;/dec/fstab&nbsp;&nbsp;&nbsp;&nbsp;#进入配置文档<br/>
						<br/>
						#我们拿出一行来进行学习<br/>
						<br/>
						UUID=b9008873-894b-4586-bbd9-0690a052c5d6&nbsp;/home&nbsp;ext4&nbsp;defaults&nbsp;1&nbsp;2<br/>
						<br/>
						#第一列UUID,相当于硬盘分区的"身份证号码",通过这个号码识别硬盘,命令行模式下输入"ll&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/dev/disk/by-uuid/"查看对应分区的UUID号码.<br/>
						<br/>
						#第二列&nbsp;挂载点<br/>
						<br/>
						#第三列&nbsp;文件系统&nbsp;的格式<br/>
						<br/>
						#第四列&nbsp;&nbsp;&nbsp;&nbsp;默认参数配置,defaults就行,如果有其他功能添加,添加",功能名"即可<br/>
						<br/>
						#第五列&nbsp;是否备份,1-备份,0-不备份,默认1即可<br/>
						<br/>
						#第六列&nbsp;是开机fsck工具自检,0-不检,1-开机时检测,2-开机后检测,只有根分区默认开机自检,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其他分区默认2,有点像360优化开机选项,不然的话拖慢了开机速度.<br/>
						<br/>
						&nbsp;<br/>
						<br/>
						备注:<br/>
						<br/>
						这里存在一个很大的问题,导致很多人挂载失败!<br/>
						<br/>
						首先mount命令默认挂载的时候不需要我们手动配置信息,但是配置文件时需要UUID,这个数据是格式化后生成的,如果只是分区,但是没有格式化,一种可能是命令/"ll&nbsp;/dev/disk/by-uuid/"结果里没有你的设备对应的UUID,比如说/dev/sdb2,还有一种可能是显示的旧UUID,为什么说旧呢?因为你从最近一次文件修改时间可以看出来.<br/>
						<br/>
						因此你粘贴的UUID绝对是错的,重启后系统开机报错,说找不到UUID对应设备,谨记!<br/>
						<br/>
						如果开机报错,修复办法在上一篇文档"fdisk创建MBR分区"的末尾.<br/>
						<br/>
						&nbsp;<br/>
						<br/>
						在文档末尾添加如下内容:<br/>
						<br/>
						UUID=95988f1e-de1f-47e6-a791-4184a588d7ed&nbsp;/mnt/sdb1&nbsp;ext2&nbsp;defaults&nbsp;1&nbsp;2<br/>
						<br/>
						UUID=31f7fdbc-780b-42fd-9d3e-6764edbe68e3&nbsp;/mnt/sdb2&nbsp;ext2&nbsp;defaults&nbsp;1&nbsp;2<br/>
						<br/>
						保存,退出文档.<br/>
						<br/>
						重启.<br/>
						<br/>
						[root@localhost&nbsp;~]#&nbsp;df&nbsp;-h<br/>
						<br/>
						Filesystem&nbsp;Size&nbsp;Used&nbsp;Avail&nbsp;Use%&nbsp;Mounted&nbsp;on<br/>
						<br/>
						/dev/sda5&nbsp;9.8G&nbsp;2.4G&nbsp;7.0G&nbsp;26%&nbsp;/<br/>
						<br/>
						tmpfs&nbsp;495M&nbsp;0&nbsp;495M&nbsp;0%&nbsp;/dev/shm<br/>
						<br/>
						/dev/sda1&nbsp;190M&nbsp;33M&nbsp;147M&nbsp;19%&nbsp;/boot<br/>
						<br/>
						/dev/sda3&nbsp;1.9G&nbsp;3.5M&nbsp;1.8G&nbsp;1%&nbsp;/home<br/>
						<br/>
						/dev/sdb1&nbsp;804M&nbsp;13K&nbsp;761M&nbsp;1%&nbsp;/mnt/sdb1<br/>
						<br/>
						/dev/sdb2&nbsp;893M&nbsp;13K&nbsp;845M&nbsp;1%&nbsp;/mnt/sdb2<br/>
						<br/>
						可以看到分区已经自动挂载上来了,哇偶.<br/>
						<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;<br/>
						<br/>
						八.建立swap分区<br/>
						<br/>
						实验:<br/>
						<br/>
						①建立swap分区<br/>
						<br/>
						②挂载至系统swap中<br/>
						<br/>
						③自动挂载swap分区<br/>
						<br/>
						&nbsp;<br/>
						<br/>
						在虚拟机里新添加一个空白盘给系统,1G大小足够了,只是做实验加入到swap分区中.<br/>
						<br/>
						记得添加空白盘后用命令"fdisk&nbsp;-l"如果不显示/dev/sdc,重启.<br/>
						<br/>
						&nbsp;<br/>
						<br/>
						[root@localhost&nbsp;~]#&nbsp;fdisk&nbsp;-l<br/>
						<br/>
						&nbsp;<br/>
						<br/>
						Disk&nbsp;/dev/sda:&nbsp;21.5&nbsp;GB,&nbsp;21474836480&nbsp;bytes&nbsp;&nbsp;&nbsp;&nbsp;#当前测试Disk&nbsp;/dev/sdc,因此省略显示a/b盘<br/>
						<br/>
						Disk&nbsp;/dev/sdb:&nbsp;5368&nbsp;MB,&nbsp;5368709120&nbsp;bytes<br/>
						<br/>
						&nbsp;<br/>
						<br/>
						Disk&nbsp;/dev/sdc:&nbsp;1073&nbsp;MB,&nbsp;1073741824&nbsp;bytes&nbsp;&nbsp;&nbsp;&nbsp;#已经识别第三块SCSI硬盘了<br/>
						<br/>
						255&nbsp;heads,&nbsp;63&nbsp;sectors/track,&nbsp;130&nbsp;cylinders<br/>
						<br/>
						Units&nbsp;=&nbsp;cylinders&nbsp;of&nbsp;16065&nbsp;*&nbsp;512&nbsp;=&nbsp;8225280&nbsp;bytes<br/>
						<br/>
						Sector&nbsp;size&nbsp;(logical/physical):&nbsp;512&nbsp;bytes&nbsp;/&nbsp;512&nbsp;bytes<br/>
						<br/>
						I/O&nbsp;size&nbsp;(minimum/optimal):&nbsp;512&nbsp;bytes&nbsp;/&nbsp;512&nbsp;bytes<br/>
						<br/>
						Disk&nbsp;identifier:&nbsp;0x00000000<br/>
						<br/>
						&nbsp;<br/>
						<br/>
						1.使用fdisk工具创建swape分区:<br/>
						<br/>
						&nbsp;<br/>
						<br/>
						[root@localhost&nbsp;~]#&nbsp;fdisk&nbsp;/dev/sdc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#配置第三块硬盘,要写命令参数的<br/>
						<br/>
						Device&nbsp;contains&nbsp;neither&nbsp;a&nbsp;valid&nbsp;DOS&nbsp;partition&nbsp;table,&nbsp;nor&nbsp;Sun,&nbsp;SGI&nbsp;or&nbsp;OSF&nbsp;disklabel<br/>
						<br/>
						Building&nbsp;a&nbsp;new&nbsp;DOS&nbsp;disklabel&nbsp;with&nbsp;disk&nbsp;identifier&nbsp;0x1becc0ab.<br/>
						<br/>
						Changes&nbsp;will&nbsp;remain&nbsp;in&nbsp;memory&nbsp;only,&nbsp;until&nbsp;you&nbsp;decide&nbsp;to&nbsp;write&nbsp;them.<br/>
						<br/>
						After&nbsp;that,&nbsp;of&nbsp;course,&nbsp;the&nbsp;previous&nbsp;content&nbsp;won't&nbsp;be&nbsp;recoverable.<br/>
						<br/>
						#上面一大堆的警告意思就是:&lt;你添加的空白盘是个三不像,啥格式都没有,我给你建了个DOS分区表格式,如果你保存,那就这个样写入了,写入后你的数据就没了&gt;空白盘,不用管.<br/>
						<br/>
						Warning:&nbsp;invalid&nbsp;flag&nbsp;0x0000&nbsp;of&nbsp;partition&nbsp;table&nbsp;4&nbsp;will&nbsp;be&nbsp;corrected&nbsp;by&nbsp;w(rite)<br/>
						<br/>
						&nbsp;<br/>
						<br/>
						WARNING:&nbsp;DOS-compatible&nbsp;mode&nbsp;is&nbsp;deprecated.&nbsp;It's&nbsp;strongly&nbsp;recommended&nbsp;to<br/>
						<br/>
						switch&nbsp;off&nbsp;the&nbsp;mode&nbsp;(command&nbsp;'c')&nbsp;and&nbsp;change&nbsp;display&nbsp;units&nbsp;to<br/>
						<br/>
						sectors&nbsp;(command&nbsp;'u').<br/>
						<br/>
						&nbsp;<br/>
						<br/>
						Command&nbsp;(m&nbsp;for&nbsp;help):&nbsp;p&nbsp;&nbsp;&nbsp;&nbsp;#显示分区信息,空白盘呗,要啥没啥.<br/>
						<br/>
						&nbsp;<br/>
						<br/>
						Disk&nbsp;/dev/sdc:&nbsp;1073&nbsp;MB,&nbsp;1073741824&nbsp;bytes<br/>
						<br/>
						255&nbsp;heads,&nbsp;63&nbsp;sectors/track,&nbsp;130&nbsp;cylinders<br/>
						<br/>
						Units&nbsp;=&nbsp;cylinders&nbsp;of&nbsp;16065&nbsp;*&nbsp;512&nbsp;=&nbsp;8225280&nbsp;bytes<br/>
						<br/>
						Sector&nbsp;size&nbsp;(logical/physical):&nbsp;512&nbsp;bytes&nbsp;/&nbsp;512&nbsp;bytes<br/>
						<br/>
						I/O&nbsp;size&nbsp;(minimum/optimal):&nbsp;512&nbsp;bytes&nbsp;/&nbsp;512&nbsp;bytes<br/>
						<br/>
						Disk&nbsp;identifier:&nbsp;0x1becc0ab<br/>
						<br/>
						Device&nbsp;Boot&nbsp;Start&nbsp;End&nbsp;Blocks&nbsp;Id&nbsp;System<br/>
						<br/>
						&nbsp;<br/>
						<br/>
						Command&nbsp;(m&nbsp;for&nbsp;help):&nbsp;t&nbsp;&nbsp;&nbsp;&nbsp;#直接改系统格式会报错,因为没有任何分区啊<br/>
						<br/>
						No&nbsp;partition&nbsp;is&nbsp;defined&nbsp;yet!<br/>
						<br/>
						&nbsp;<br/>
						<br/>
						Command&nbsp;(m&nbsp;for&nbsp;help):&nbsp;n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#新建分区<br/>
						<br/>
						Command&nbsp;action<br/>
						<br/>
						e&nbsp;extended&nbsp;&nbsp;&nbsp;&nbsp;<br/>
						<br/>
						p&nbsp;primary&nbsp;partition&nbsp;(1-4)<br/>
						<br/>
						p&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#输入p,选择主分区<br/>
						<br/>
						Partition&nbsp;number&nbsp;(1-4):&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;#分区号码,挨着顺序来<br/>
						<br/>
						First&nbsp;cylinder&nbsp;(1-130,&nbsp;default&nbsp;1):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#第一个柱面,默认就是1,直接回车就行<br/>
						<br/>
						Using&nbsp;default&nbsp;value&nbsp;1<br/>
						<br/>
						Last&nbsp;cylinder,&nbsp;+cylinders&nbsp;or&nbsp;+size{K,M,G}&nbsp;(1-130,&nbsp;default&nbsp;130):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#最后一个柱面,默认回车<br/>
						<br/>
						Using&nbsp;default&nbsp;value&nbsp;130<br/>
						<br/>
						Command&nbsp;(m&nbsp;for&nbsp;help):&nbsp;p&nbsp;&nbsp;&nbsp;&nbsp;#显示分区信息<br/>
						<br/>
						&nbsp;<br/>
						<br/>
						Disk&nbsp;/dev/sdc:&nbsp;1073&nbsp;MB,&nbsp;1073741824&nbsp;bytes<br/>
						<br/>
						255&nbsp;heads,&nbsp;63&nbsp;sectors/track,&nbsp;130&nbsp;cylinders<br/>
						<br/>
						Units&nbsp;=&nbsp;cylinders&nbsp;of&nbsp;16065&nbsp;*&nbsp;512&nbsp;=&nbsp;8225280&nbsp;bytes<br/>
						<br/>
						Sector&nbsp;size&nbsp;(logical/physical):&nbsp;512&nbsp;bytes&nbsp;/&nbsp;512&nbsp;bytes<br/>
						<br/>
						I/O&nbsp;size&nbsp;(minimum/optimal):&nbsp;512&nbsp;bytes&nbsp;/&nbsp;512&nbsp;bytes<br/>
						<br/>
						Disk&nbsp;identifier:&nbsp;0x1becc0ab<br/>
						<br/>
						&nbsp;<br/>
						<br/>
						Device&nbsp;Boot&nbsp;Start&nbsp;End&nbsp;Blocks&nbsp;Id&nbsp;System<br/>
						<br/>
						/dev/sdc1&nbsp;1&nbsp;130&nbsp;1044193+&nbsp;83&nbsp;Linux<br/>
						<br/>
						#最后一列System(系统)的内容是Linux,不行,我们要建swap分区,所以得改!<br/>
						<br/>
						&nbsp;<br/>
						<br/>
						Command&nbsp;(m&nbsp;for&nbsp;help):&nbsp;l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#列举支持的系统格式(主要记swap是哪个号,恩,82)<br/>
						<br/>
						0&nbsp;Empty&nbsp;24&nbsp;NEC&nbsp;DOS&nbsp;81&nbsp;Minix&nbsp;/&nbsp;old&nbsp;Lin&nbsp;bf&nbsp;Solaris<br/>
						<br/>
						1&nbsp;FAT12&nbsp;39&nbsp;Plan&nbsp;9&nbsp;82&nbsp;Linux&nbsp;swap&nbsp;/&nbsp;So&nbsp;c1&nbsp;DRDOS/sec&nbsp;(FAT-<br/>
						<br/>
						2&nbsp;XENIX&nbsp;root&nbsp;3c&nbsp;PartitionMagic&nbsp;83&nbsp;Linux&nbsp;c4&nbsp;DRDOS/sec&nbsp;(FAT-<br/>
						<br/>
						3&nbsp;XENIX&nbsp;usr&nbsp;40&nbsp;Venix&nbsp;80286&nbsp;84&nbsp;OS/2&nbsp;hidden&nbsp;C:&nbsp;c6&nbsp;DRDOS/sec&nbsp;(FAT-<br/>
						<br/>
						4&nbsp;FAT16&nbsp;&lt;32M&nbsp;41&nbsp;PPC&nbsp;PReP&nbsp;Boot&nbsp;85&nbsp;Linux&nbsp;extended&nbsp;c7&nbsp;Syrinx<br/>
						<br/>
						5&nbsp;Extended&nbsp;42&nbsp;SFS&nbsp;86&nbsp;NTFS&nbsp;volume&nbsp;set&nbsp;da&nbsp;Non-FS&nbsp;data<br/>
						<br/>
						6&nbsp;FAT16&nbsp;4d&nbsp;QNX4.x&nbsp;87&nbsp;NTFS&nbsp;volume&nbsp;set&nbsp;db&nbsp;CP/M&nbsp;/&nbsp;CTOS&nbsp;/&nbsp;.<br/>
						<br/>
						7&nbsp;HPFS/NTFS&nbsp;4e&nbsp;QNX4.x&nbsp;2nd&nbsp;part&nbsp;88&nbsp;Linux&nbsp;plaintext&nbsp;de&nbsp;Dell&nbsp;Utility<br/>
						<br/>
						8&nbsp;AIX&nbsp;4f&nbsp;QNX4.x&nbsp;3rd&nbsp;part&nbsp;8e&nbsp;Linux&nbsp;LVM&nbsp;df&nbsp;BootIt<br/>
						<br/>
						9&nbsp;AIX&nbsp;bootable&nbsp;50&nbsp;OnTrack&nbsp;DM&nbsp;93&nbsp;Amoeba&nbsp;e1&nbsp;DOS&nbsp;access<br/>
						<br/>
						a&nbsp;OS/2&nbsp;Boot&nbsp;Manag&nbsp;51&nbsp;OnTrack&nbsp;DM6&nbsp;Aux&nbsp;94&nbsp;Amoeba&nbsp;BBT&nbsp;e3&nbsp;DOS&nbsp;R/O<br/>
						<br/>
						b&nbsp;W95&nbsp;FAT32&nbsp;52&nbsp;CP/M&nbsp;9f&nbsp;BSD/OS&nbsp;e4&nbsp;SpeedStor<br/>
						<br/>
						c&nbsp;W95&nbsp;FAT32&nbsp;(LBA)&nbsp;53&nbsp;OnTrack&nbsp;DM6&nbsp;Aux&nbsp;a0&nbsp;IBM&nbsp;Thinkpad&nbsp;hi&nbsp;eb&nbsp;BeOS&nbsp;fs<br/>
						<br/>
						e&nbsp;W95&nbsp;FAT16&nbsp;(LBA)&nbsp;54&nbsp;OnTrackDM6&nbsp;a5&nbsp;FreeBSD&nbsp;ee&nbsp;GPT<br/>
						<br/>
						f&nbsp;W95&nbsp;Ext'd&nbsp;(LBA)&nbsp;55&nbsp;EZ-Drive&nbsp;a6&nbsp;OpenBSD&nbsp;ef&nbsp;EFI&nbsp;(FAT-12/16/<br/>
						<br/>
						10&nbsp;OPUS&nbsp;56&nbsp;Golden&nbsp;Bow&nbsp;a7&nbsp;NeXTSTEP&nbsp;f0&nbsp;Linux/PA-RISC&nbsp;b<br/>
						<br/>
						11&nbsp;Hidden&nbsp;FAT12&nbsp;5c&nbsp;Priam&nbsp;Edisk&nbsp;a8&nbsp;Darwin&nbsp;UFS&nbsp;f1&nbsp;SpeedStor<br/>
						<br/>
						12&nbsp;Compaq&nbsp;diagnost&nbsp;61&nbsp;SpeedStor&nbsp;a9&nbsp;NetBSD&nbsp;f4&nbsp;SpeedStor<br/>
						<br/>
						14&nbsp;Hidden&nbsp;FAT16&nbsp;&lt;3&nbsp;63&nbsp;GNU&nbsp;HURD&nbsp;or&nbsp;Sys&nbsp;ab&nbsp;Darwin&nbsp;boot&nbsp;f2&nbsp;DOS&nbsp;secondary<br/>
						<br/>
						16&nbsp;Hidden&nbsp;FAT16&nbsp;64&nbsp;Novell&nbsp;Netware&nbsp;af&nbsp;HFS&nbsp;/&nbsp;HFS+&nbsp;fb&nbsp;VMware&nbsp;VMFS<br/>
						<br/>
						17&nbsp;Hidden&nbsp;HPFS/NTF&nbsp;65&nbsp;Novell&nbsp;Netware&nbsp;b7&nbsp;BSDI&nbsp;fs&nbsp;fc&nbsp;VMware&nbsp;VMKCORE<br/>
						<br/>
						18&nbsp;AST&nbsp;SmartSleep&nbsp;70&nbsp;DiskSecure&nbsp;Mult&nbsp;b8&nbsp;BSDI&nbsp;swap&nbsp;fd&nbsp;Linux&nbsp;raid&nbsp;auto<br/>
						<br/>
						1b&nbsp;Hidden&nbsp;W95&nbsp;FAT3&nbsp;75&nbsp;PC/IX&nbsp;bb&nbsp;Boot&nbsp;Wizard&nbsp;hid&nbsp;fe&nbsp;LANstep<br/>
						<br/>
						1c&nbsp;Hidden&nbsp;W95&nbsp;FAT3&nbsp;80&nbsp;Old&nbsp;Minix&nbsp;be&nbsp;Solaris&nbsp;boot&nbsp;ff&nbsp;BBT<br/>
						<br/>
						1e&nbsp;Hidden&nbsp;W95&nbsp;FAT1<br/>
						<br/>
						&nbsp;<br/>
						<br/>
						Command&nbsp;(m&nbsp;for&nbsp;help):&nbsp;t&nbsp;&nbsp;&nbsp;&nbsp;#这回有分区了,再次修改系统格式&nbsp;&nbsp;&nbsp;&nbsp;<br/>
						<br/>
						Selected&nbsp;partition&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#只有一个分区,所以没得选,只能是1<br/>
						<br/>
						Hex&nbsp;code&nbsp;(type&nbsp;L&nbsp;to&nbsp;list&nbsp;codes):&nbsp;82&nbsp;&nbsp;&nbsp;&nbsp;#这里输入82,意思就是改为swap格式<br/>
						<br/>
						Changed&nbsp;system&nbsp;type&nbsp;of&nbsp;partition&nbsp;1&nbsp;to&nbsp;82&nbsp;(Linux&nbsp;swap&nbsp;/&nbsp;Solaris)<br/>
						<br/>
						&nbsp;<br/>
						<br/>
						Command&nbsp;(m&nbsp;for&nbsp;help):&nbsp;p&nbsp;&nbsp;&nbsp;&nbsp;#显示结果<br/>
						<br/>
						&nbsp;<br/>
						<br/>
						Disk&nbsp;/dev/sdc:&nbsp;1073&nbsp;MB,&nbsp;1073741824&nbsp;bytes<br/>
						<br/>
						255&nbsp;heads,&nbsp;63&nbsp;sectors/track,&nbsp;130&nbsp;cylinders<br/>
						<br/>
						Units&nbsp;=&nbsp;cylinders&nbsp;of&nbsp;16065&nbsp;*&nbsp;512&nbsp;=&nbsp;8225280&nbsp;bytes<br/>
						<br/>
						Sector&nbsp;size&nbsp;(logical/physical):&nbsp;512&nbsp;bytes&nbsp;/&nbsp;512&nbsp;bytes<br/>
						<br/>
						I/O&nbsp;size&nbsp;(minimum/optimal):&nbsp;512&nbsp;bytes&nbsp;/&nbsp;512&nbsp;bytes<br/>
						<br/>
						Disk&nbsp;identifier:&nbsp;0x1becc0ab<br/>
						<br/>
						&nbsp;<br/>
						<br/>
						Device&nbsp;Boot&nbsp;Start&nbsp;End&nbsp;Blocks&nbsp;Id&nbsp;System<br/>
						<br/>
						/dev/sdc1&nbsp;1&nbsp;130&nbsp;1044193+&nbsp;82&nbsp;Linux&nbsp;swap&nbsp;/&nbsp;Solaris<br/>
						<br/>
						#这里显示的效果就是我们要的swap分区了,仔细核对最后一列系统格式,别搞错了.<br/>
						<br/>
						#一定一定一定要保存,重要的事情说三遍,输入&nbsp;w<br/>
						<br/>
						Command&nbsp;(m&nbsp;for&nbsp;help):&nbsp;w&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#!!!!重要<br/>
						<br/>
						The&nbsp;partition&nbsp;table&nbsp;has&nbsp;been&nbsp;altered!&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#意思就是磁盘的分区表已经改了<br/>
						<br/>
						Calling&nbsp;ioctl()&nbsp;to&nbsp;re-read&nbsp;partition&nbsp;table.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#调用ioctl()函数可以得到磁盘信息,除非你做&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;开发,不然用不到<br/>
						<br/>
						Syncing&nbsp;disks.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#信息已经同步到了磁盘<br/>
						<br/>
						&nbsp;<br/>
						<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;挂载至swap分区中:<br/>
						<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
						<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;分区后,该做什么?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;格式化啊啊啊啊&nbsp;!<br/>
						<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
						<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;[root@localhost&nbsp;~]#&nbsp;mkswap&nbsp;/dev/sdc1&nbsp;#用mkswap格式化/dev/sdc1分区<br/>
						<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;Setting&nbsp;up&nbsp;swapspace&nbsp;version&nbsp;1,&nbsp;size&nbsp;=&nbsp;1044188&nbsp;KiB<br/>
						<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;no&nbsp;label,&nbsp;UUID=0ccb15e6-af00-475c-93b6-56cd1f543ccb&nbsp;&nbsp;&nbsp;&nbsp;#说好的格式化后生成UUID,信!<br/>
						<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;[root@localhost&nbsp;~]#&nbsp;free&nbsp;-h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#记录当前swap分区信息,不然你咋知道增大了没有?<br/>
						<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;total&nbsp;used&nbsp;free&nbsp;shared&nbsp;buffers&nbsp;cached<br/>
						<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;Mem:&nbsp;988M&nbsp;279M&nbsp;709M&nbsp;260K&nbsp;19M&nbsp;108M<br/>
						<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;-/+&nbsp;buffers/cache:&nbsp;150M&nbsp;837M<br/>
						<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;Swap:&nbsp;7.8G&nbsp;0B&nbsp;7.8G<br/>
						<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;[root@localhost&nbsp;~]#&nbsp;swapon&nbsp;/dev/sdc1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#手工把/dev/sdc1加入swap分区,没报错<br/>
						<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;[root@localhost&nbsp;~]#&nbsp;free&nbsp;-h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#对照下,恩,确实变大了1G,成功!<br/>
						<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;total&nbsp;used&nbsp;free&nbsp;shared&nbsp;buffers&nbsp;cached<br/>
						<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;Mem:&nbsp;988M&nbsp;279M&nbsp;708M&nbsp;260K&nbsp;19M&nbsp;108M<br/>
						<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;-/+&nbsp;buffers/cache:&nbsp;151M&nbsp;836M<br/>
						<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;Swap:&nbsp;8.8G&nbsp;0B&nbsp;8.8G<br/>
						<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;自动挂载swap<br/>
						<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
						<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;vi&nbsp;/etc/fstab<br/>
						<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;文档末尾加入下面一行信息:<br/>
						<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;UUID=0ccb15e6-af00-475c-93b6-56cd1f543ccb&nbsp;swap&nbsp;swap&nbsp;defaults&nbsp;0&nbsp;0<br/>
						<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;保存退出.<br/>
						<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;重启.<br/>
						<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;开机后检查是否正常:<br/>
						<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;Last&nbsp;login:&nbsp;Fri&nbsp;Apr&nbsp;13&nbsp;17:12:05&nbsp;2018&nbsp;from&nbsp;192.168.41.1<br/>
						<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;[root@localhost&nbsp;~]#&nbsp;free&nbsp;-h<br/>
						<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;total&nbsp;used&nbsp;free&nbsp;shared&nbsp;buffers&nbsp;cached<br/>
						<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;Mem:&nbsp;988M&nbsp;231M&nbsp;757M&nbsp;260K&nbsp;18M&nbsp;58M<br/>
						<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;-/+&nbsp;buffers/cache:&nbsp;153M&nbsp;834M<br/>
						<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;Swap:&nbsp;8.8G&nbsp;0B&nbsp;8.8G<br/>
						<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;内存大小直接存7.8G变成了8.8G,不用再手动添加了,哈哈,省事.<br/>
					</div>
				</div>
			</section>
			<section>
				<h3 class="class___copy_other_people_content">Linux分区工具Fdisk与Parted以及GParted</h3>
				<div>
					<img src="./refs/Linux分区工具Fdisk与Parted以及GParted.png"/>
				</div>
			</section>
			<section>
				<h3>如何在 Linux 中使用 parted 对磁盘分区</h3>
				<div>
					<div class="class___code class___copy_other_people_content">
						如何在&nbsp;Linux&nbsp;中使用&nbsp;parted&nbsp;对磁盘分区<br/>
						<br/>
						在&nbsp;Linux&nbsp;中创建和删除分区是一种常见的操作，因为存储设备（如硬盘驱动器和&nbsp;USB&nbsp;驱动器）在使用之前必须以某种方式进行结构化。在大多数情况下，大型存储设备被分为称为&nbsp;分区(partition)的独立部分。分区操作允许您将硬盘分割成独立的部分，每个部分都像是一个硬盘驱动器一样。如果您运行多个操作系统，那么分区是非常有用的。<br/>
						<br/>
						在&nbsp;Linux&nbsp;中有许多强大的工具可以创建、删除和操作磁盘分区。在本文中，我将解释如何使用&nbsp;parted&nbsp;命令，这对于大型磁盘设备和许多磁盘分区尤其有用。parted&nbsp;与更常见的&nbsp;fdisk&nbsp;和&nbsp;cfdisk&nbsp;命令之间的区别包括:<br/>
						<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;GPT&nbsp;格式：parted&nbsp;命令可以创建全局惟一的标识符分区表&nbsp;GPT，而&nbsp;fdisk&nbsp;和&nbsp;cfdisk&nbsp;则仅限于&nbsp;DOS&nbsp;分区表<br/>
						<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;。<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;更大的磁盘：&nbsp;DOS&nbsp;分区表可以格式化最多&nbsp;2TB&nbsp;的磁盘空间，尽管在某些情况下最多可以达到&nbsp;16TB。然而，一个&nbsp;GPT&nbsp;分区表可以处理最多&nbsp;8ZiB&nbsp;的空间。<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;更多的分区：&nbsp;使用主分区和扩展分区，DOS&nbsp;分区表只允许&nbsp;16&nbsp;个分区。在&nbsp;GPT&nbsp;中，默认情况下您可以得到&nbsp;128&nbsp;个分区，并且可以选择更多的分区。<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;可靠性：&nbsp;在&nbsp;DOS&nbsp;分区表中，只保存了一份分区表备份，在&nbsp;GPT&nbsp;中保留了两份分区表的备份（在磁盘的起始和结束部分），同时&nbsp;GPT&nbsp;还使用了&nbsp;CRC&nbsp;校验和来检查分区表的完整性，在&nbsp;DOS&nbsp;分区中并没有实现。<br/>
						<br/>
						由于现在的磁盘更大，需要更灵活地使用它们，建议使用&nbsp;parted&nbsp;来处理磁盘分区。大多数时候，磁盘分区表是作为操作系统安装过程的一部分创建的。在向现有系统添加存储设备时，直接使用&nbsp;parted&nbsp;命令非常有用。<br/>
						尝试一下&nbsp;parted<br/>
						<br/>
						下面解释了使用&nbsp;parted&nbsp;命令对存储设备进行分区的过程。为了尝试这些步骤，我强烈建议使用一块全新的存储设备或一种您不介意将其内容删除的设备。<br/>
						1、列出分区<br/>
						<br/>
						使用&nbsp;parted&nbsp;-l&nbsp;来标识你要进行分区的设备。一般来说，第一个硬盘&nbsp;（/dev/sda&nbsp;或&nbsp;/dev/vda&nbsp;）保存着操作系统，&nbsp;因此要寻找另一个磁盘，以找到你想要分区的磁盘&nbsp;(例如，/dev/sdb、/dev/sdc、&nbsp;/dev/vdb、/dev/vdc&nbsp;等)。<br/>
						<br/>
						$&nbsp;sudo&nbsp;parted&nbsp;-l<br/>
						[sudo]&nbsp;password&nbsp;for&nbsp;daniel:&nbsp;<br/>
						Model:&nbsp;ATA&nbsp;RevuAhn_850X1TU5&nbsp;(scsi)<br/>
						Disk&nbsp;/dev/vdc:&nbsp;512GB<br/>
						Sector&nbsp;size&nbsp;(logical/physical):&nbsp;512B/512B<br/>
						Partition&nbsp;Table:&nbsp;msdos<br/>
						<br/>
						<br/>
						Disk&nbsp;Flags:&nbsp;<br/>
						<br/>
						Number&nbsp;&nbsp;Start&nbsp;&nbsp;&nbsp;End&nbsp;&nbsp;&nbsp;&nbsp;Size&nbsp;&nbsp;&nbsp;Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;File&nbsp;system&nbsp;&nbsp;Flags<br/>
						&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1049kB&nbsp;&nbsp;525MB&nbsp;&nbsp;524MB&nbsp;&nbsp;primary&nbsp;&nbsp;ext4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boot<br/>
						&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;525MB&nbsp;&nbsp;&nbsp;512GB&nbsp;&nbsp;512GB&nbsp;&nbsp;primary&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lvm<br/>
						<br/>
						<br/>
						2、打开存储设备<br/>
						<br/>
						使用&nbsp;parted&nbsp;选中您要分区的设备。在这里例子中，是虚拟系统上的第三个磁盘（/dev/vdc）。指明你要使用哪一个设备非常重要。&nbsp;如果你仅仅输入了&nbsp;parted&nbsp;命令而没有指定设备名字，&nbsp;它会随机选择一个设备进行操作。<br/>
						<br/>
						$&nbsp;sudo&nbsp;parted&nbsp;/dev/vdc<br/>
						GNU&nbsp;Parted&nbsp;3.2<br/>
						Using&nbsp;/dev/vdc<br/>
						Welcome&nbsp;to&nbsp;GNU&nbsp;Parted!&nbsp;Type&nbsp;'help'&nbsp;to&nbsp;view&nbsp;a&nbsp;list&nbsp;of&nbsp;commands.<br/>
						(parted)<br/>
						<br/>
						3、&nbsp;设定分区表<br/>
						<br/>
						设置分区表为&nbsp;GPT&nbsp;，然后输入&nbsp;Yes&nbsp;开始执行。<br/>
						<br/>
						(parted)&nbsp;mklabel<br/>
						<br/>
						&nbsp;gpt&nbsp;<br/>
						Warning:&nbsp;the&nbsp;existing&nbsp;disk&nbsp;label&nbsp;on&nbsp;/dev/vdc&nbsp;will&nbsp;be&nbsp;destroyed&nbsp;<br/>
						and&nbsp;all&nbsp;data&nbsp;on&nbsp;this&nbsp;disk&nbsp;will&nbsp;be&nbsp;lost.&nbsp;Do&nbsp;you&nbsp;want&nbsp;to&nbsp;continue?&nbsp;<br/>
						Yes/No?&nbsp;Yes<br/>
						<br/>
						mklabel&nbsp;和&nbsp;mktable&nbsp;命令用于相同的目的（在存储设备上创建分区表）。支持的分区表有：aix、amiga、bsd、dvh、gpt、mac、ms-dos、pc98、sun&nbsp;和&nbsp;loop。记住&nbsp;mklabel&nbsp;不会创建一个分区，而是创建一个分区表。<br/>
						4、&nbsp;检查分区表<br/>
						<br/>
						查看存储设备信息:<br/>
						<br/>
						(parted)&nbsp;print&nbsp;<br/>
						Model:&nbsp;Virtio&nbsp;Block&nbsp;Device&nbsp;(virtblk)&nbsp;<br/>
						Disk&nbsp;/dev/vdc:&nbsp;1396MB&nbsp;<br/>
						Sector&nbsp;size&nbsp;(logical/physical):&nbsp;512B/512B&nbsp;<br/>
						Partition&nbsp;Table:&nbsp;gpt&nbsp;<br/>
						Disk&nbsp;Flags:&nbsp;<br/>
						Number&nbsp;Start&nbsp;End&nbsp;Size&nbsp;File&nbsp;system&nbsp;Name&nbsp;Flags<br/>
						<br/>
						5、&nbsp;获取帮助<br/>
						<br/>
						为了知道如何去创建一个新分区，输入：&nbsp;(parted)&nbsp;help&nbsp;mkpart<br/>
						<br/>
						。<br/>
						<br/>
						(parted)&nbsp;help&nbsp;mkpart&nbsp;<br/>
						&nbsp;&nbsp;mkpart&nbsp;PART-TYPE&nbsp;[FS-TYPE]&nbsp;START&nbsp;END&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;make&nbsp;a&nbsp;partition<br/>
						<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PART-TYPE&nbsp;is&nbsp;one&nbsp;of:&nbsp;primary,&nbsp;logical,&nbsp;extended<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FS-TYPE&nbsp;is&nbsp;one&nbsp;of:&nbsp;btrfs,&nbsp;nilfs2,&nbsp;ext4,&nbsp;ext3,&nbsp;ext2,&nbsp;fat32,&nbsp;fat16,&nbsp;hfsx,&nbsp;hfs+,&nbsp;hfs,&nbsp;jfs,&nbsp;swsusp,<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;linux-swap(v1),&nbsp;linux-swap(v0),&nbsp;ntfs,&nbsp;reiserfs,&nbsp;hp-ufs,&nbsp;sun-ufs,&nbsp;xfs,&nbsp;apfs2,&nbsp;apfs1,&nbsp;asfs,&nbsp;amufs5,<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;amufs4,&nbsp;amufs3,&nbsp;amufs2,&nbsp;amufs1,&nbsp;amufs0,&nbsp;amufs,&nbsp;affs7,&nbsp;affs6,&nbsp;affs5,&nbsp;affs4,&nbsp;affs3,&nbsp;affs2,&nbsp;affs1,<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;affs0,&nbsp;linux-swap,&nbsp;linux-swap(new),&nbsp;linux-swap(old)<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;START&nbsp;and&nbsp;END&nbsp;are&nbsp;disk&nbsp;locations,&nbsp;such&nbsp;as&nbsp;4GB&nbsp;or&nbsp;10%.&nbsp;&nbsp;Negative&nbsp;values&nbsp;count&nbsp;from&nbsp;the&nbsp;end&nbsp;of&nbsp;the<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;disk.&nbsp;&nbsp;For&nbsp;example,&nbsp;-1s&nbsp;specifies&nbsp;exactly&nbsp;the&nbsp;last&nbsp;sector.<br/>
						<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'mkpart'&nbsp;makes&nbsp;a&nbsp;partition&nbsp;without&nbsp;creating&nbsp;a&nbsp;new&nbsp;file&nbsp;system&nbsp;on&nbsp;the&nbsp;partition.&nbsp;&nbsp;FS-TYPE&nbsp;may&nbsp;be<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;specified&nbsp;to&nbsp;set&nbsp;an&nbsp;appropriate&nbsp;partition&nbsp;ID.<br/>
						<br/>
						6、&nbsp;创建分区<br/>
						<br/>
						为了创建一个新分区（在这个例子中，分区&nbsp;0&nbsp;有&nbsp;1396MB），输入下面的命令：<br/>
						<br/>
						(parted)&nbsp;mkpart&nbsp;primary&nbsp;0&nbsp;1396MB&nbsp;<br/>
						<br/>
						Warning:&nbsp;The&nbsp;resulting&nbsp;partition&nbsp;is&nbsp;not&nbsp;properly&nbsp;aligned&nbsp;for&nbsp;best&nbsp;performance&nbsp;<br/>
						Ignore/Cancel?&nbsp;I&nbsp;<br/>
						<br/>
						(parted)&nbsp;print&nbsp;<br/>
						Model:&nbsp;Virtio&nbsp;Block&nbsp;Device&nbsp;(virtblk)&nbsp;<br/>
						Disk&nbsp;/dev/vdc:&nbsp;1396MB&nbsp;<br/>
						Sector&nbsp;size&nbsp;(logical/physical):&nbsp;512B/512B&nbsp;<br/>
						Partition&nbsp;Table:&nbsp;gpt&nbsp;<br/>
						Disk&nbsp;Flags:&nbsp;<br/>
						Number&nbsp;Start&nbsp;&nbsp;&nbsp;End&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Size&nbsp;&nbsp;&nbsp;&nbsp;File&nbsp;system&nbsp;Name&nbsp;Flags&nbsp;<br/>
						1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4kB&nbsp;&nbsp;1396MB&nbsp;&nbsp;1396MB&nbsp;&nbsp;primary<br/>
						<br/>
						文件系统类型（fstype）并不是在&nbsp;/dev/vdc1上创建&nbsp;ext4&nbsp;文件系统。&nbsp;DOS&nbsp;分区表的分区类型是&nbsp;主分区(primary)、&nbsp;逻辑分区(logical)和&nbsp;扩展分区(extended)。&nbsp;在&nbsp;GPT&nbsp;分区表中，分区类型用作分区名称。&nbsp;在&nbsp;GPT&nbsp;下必须提供分区名称；在上例中，primary&nbsp;是分区名称，而不是分区类型。<br/>
						7、&nbsp;保存退出<br/>
						<br/>
						当你退出&nbsp;parted&nbsp;时，修改会自动保存。退出请输入如下命令：<br/>
						<br/>
						(parted)&nbsp;quit<br/>
						Information:&nbsp;You&nbsp;may&nbsp;need&nbsp;to&nbsp;update&nbsp;/etc/fstab<br/>
						<br/>
						<br/>
						谨记<br/>
						<br/>
						当您添加新的存储设备时，请确保在开始更改其分区表之前确定正确的磁盘。如果您错误地更改了包含计算机操作系统的磁盘分区，会使您的系统无法启动。<br/>
					</div>
				</div>
			</section>
			<section>
				<h3> Linux里设置环境变量的方法（export PATH）</h3>
				<div>
					<div class="class___code class___copy_other_people_content">
						Linux里设置环境变量的方法（export&nbsp;PATH）<br/>
						&nbsp;<br/>
						&nbsp;<br/>
						&nbsp;<br/>
						1.动态库路径的设置<br/>
						<br/>
						Linux下调用动态库和windows不一样.linux&nbsp;可执行程序是靠配置文件去读取路径的,因此有些时候需要设置路径<br/>
						具体操作如下<br/>
						<br/>
						export&nbsp;LD_LIBRARY_PATH=/home/.....(动态库的目录)<br/>
						<br/>
						不过这种设置方法只是在当前的session中有效<br/>
						<br/>
						你可以修改配置文件实现任何session都有效<br/>
						2.环境变量的设置<br/>
						<br/>
						一般来说，配置交叉编译工具链的时候需要指定编译工具的路径，此时就需要设置环境变量。例如我的mips-linux-gcc编译器在“/opt&nbsp;/au1200_rm/build_tools/bin”目录下，build_tools就是我的编译工具，则有如下三种方法来设置环境变量：<br/>
						2.1、直接用export命令：<br/>
						<br/>
						#export&nbsp;PATH=$PATH:/opt/au1200_rm/build_tools/bin<br/>
						查看是否已经设好，可用命令export查看：<br/>
						可以看到，环境变量已经设好，PATH里面已经有了我要加的编译器的路径。<br/>
						2.2、修改profile文件：<br/>
						<br/>
						#vi&nbsp;/etc/profile<br/>
						在里面加入:<br/>
						export&nbsp;PATH="$PATH:/opt/au1200_rm/build_tools/bin"<br/>
						<br/>
						让环境变量立即生效需要执行如下命令：<br/>
						<br/>
						#source&nbsp;/etc/profile<br/>
						2.3.&nbsp;修改.bashrc文件：<br/>
						<br/>
						#&nbsp;vi&nbsp;/root/.bashrc<br/>
						在里面加入：<br/>
						export&nbsp;PATH="$PATH:/opt/au1200_rm/build_tools/bin"<br/>
						<br/>
						后两种方法一般需要重新注销系统才能生效，最后可以通过echo命令测试一下：<br/>
						#&nbsp;echo&nbsp;$PATH<br/>
						看看输出里面是不是已经有了/my_new_path这个路径了。<br/>
						-----------------------------------------------------------------------------------<br/>
						<br/>
						“/bin”、“/sbin”、“/usr/bin”、“/usr/sbin”、“/usr/local/bin”等路径已经在系统环境变量中了，如果可执行文件在这几个标准位置，在终端命令行输入该软件可执行文件的文件名和参数(如果需要参数)，回车即可。<br/>
						<br/>
						如果不在标准位置，文件名前面需要加上完整的路径。不过每次都这样跑就太麻烦了，一个“一劳永逸”的办法是把这个路径加入环境变量。命令&nbsp;“PATH=$PATH:路径”可以把这个路径加入环境变量，但是退出这个命令行就失效了。要想永久生效，需要把这行添加到环境变量文件里。有两个文件可选：“/etc/profile”和用户主目录下的“.bash_profile”，“/etc/profile”对系统里所有用户都有效，用户主目录下的“.bash_profile”只对这个用户有效。<br/>
						<br/>
						“PATH=PATH:路径1:路径2:...:路径n”，意思是可执行文件的路径包括原先设定的路径，也包括从“路径1”到“路径n”的所有路径。当用户输入一个一串字符并按回车后，shell会依次在这些路径里找对应的可执行文件并交给系统核心执行。那个“<br/>
						<br/>
						PATH”表示原先设定的路径仍然有效，注意不要漏掉。某些软件可能还有“PATH”以外类型的环境变量需要添加，但方法与此相同，并且也需要注意“$”。<br/>
						<br/>
						注意，与DOS/Window不同，UNIX类系统环境变量中路径名用冒号分隔，不是分号。另外，软件越装越多，环境变量越添越多，为了避免造成混乱，建议所有语句都添加在文件结尾，按软件的安装顺序添加。<br/>
						<br/>
						格式如下()：<br/>
						<br/>
						#&nbsp;软件名-版本号<br/>
						<br/>
						PATH=$PATH:路径1:路径2:...:路径n<br/>
						<br/>
						其他环境变量=$其他环境变量:...<br/>
						<br/>
						在“profile”和“.bash_profile”中，“#”是注释符号，写在这里除了视觉分隔外没有任何效果。<br/>
						<br/>
						设置完毕，注销并重新登录，设置就生效了。如果不注销，直接在shell里执行这些语句，也能生效，但是作用范围只限于执行了这些语句的shell。<br/>
						<br/>
						相关的环境变量生效后，就不必老跑到软件的可执行文件目录里去操作了。<br/>
						<br/>
						from:&nbsp;http://blog.csdn.net/kpgood/archive/2009/03/07/3965446.aspx<br/>
						<br/>
						&nbsp;<br/>
						<br/>
						使用linux的朋友越来越多了，在linux下做开发首先就是需要配置环境变量，下面以配置Java环境变量为例介绍三种配置环境变量的方法。<br/>
						1.修改/etc/profile文件<br/>
						<br/>
						如果你的计算机仅仅作为开发使用时推荐使用这种方法，因为所有用户的shell都有权使用这些环境变量，可能会给系统带来安全性问题。<br/>
						<br/>
						(1)用文本编辑器打开/etc/profile<br/>
						<br/>
						(2)在profile文件末尾加入：<br/>
						<br/>
						JAVA_HOME=/usr/share/jdk1.5.0_05<br/>
						<br/>
						PATH=JAVAHOME/bin:<br/>
						<br/>
						PATH<br/>
						<br/>
						CLASSPATH=.:JAVAHOME/lib/dt.jar:<br/>
						<br/>
						JAVA_HOME/lib/tools.jar<br/>
						<br/>
						export&nbsp;JAVA_HOME<br/>
						<br/>
						export&nbsp;PATH<br/>
						<br/>
						export&nbsp;CLASSPATH<br/>
						<br/>
						(3)重新登录<br/>
						<br/>
						注解：<br/>
						<br/>
						a.&nbsp;你要将&nbsp;/usr/share/jdk1.5.0_05jdk&nbsp;改为你的jdk安装目录<br/>
						<br/>
						b.&nbsp;linux下用冒号“:”来分隔路径<br/>
						<br/>
						c.&nbsp;PATH/<br/>
						<br/>
						CLASSPATH&nbsp;/&nbsp;$JAVA_HOME&nbsp;是用来引用原来的环境变量的值,在设置环境变量时特别要注意不能把原来的值给覆盖掉了，这是一种常见的错误。<br/>
						<br/>
						d.&nbsp;CLASSPATH中当前目录“.”不能丢,把当前目录丢掉也是常见的错误。<br/>
						<br/>
						e.&nbsp;export是把这三个变量导出为全局变量。<br/>
						<br/>
						f.&nbsp;大小写必须严格区分。<br/>
						2.&nbsp;修改.bashrc文件<br/>
						<br/>
						这种方法更为安全，它可以把使用这些环境变量的权限控制到用户级别，如果你需要给某个用户权限使用这些环境变量，你只需要修改其个人用户主目录下的.bashrc文件就可以了。<br/>
						<br/>
						(1)用文本编辑器打开用户目录下的.bashrc文件<br/>
						<br/>
						(2)在.bashrc文件末尾加入：<br/>
						<br/>
						set&nbsp;JAVA_HOME=/usr/share/jdk1.5.0_05<br/>
						<br/>
						export&nbsp;JAVA_HOME<br/>
						<br/>
						set&nbsp;PATH=JAVAHOME/bin:<br/>
						<br/>
						PATH<br/>
						<br/>
						export&nbsp;PATH<br/>
						<br/>
						set&nbsp;CLASSPATH=.:JAVAHOME/lib/dt.jar:<br/>
						<br/>
						JAVA_HOME/lib/tools.jar<br/>
						<br/>
						export&nbsp;CLASSPATH<br/>
						<br/>
						(3)重新登录<br/>
						3.&nbsp;直接在shell下设置变量<br/>
						<br/>
						不赞成使用这种方法，因为换个shell，你的设置就无效了，因此这种方法仅仅是临时使用，以后要使用的时候又要重新设置，比较麻烦。<br/>
						<br/>
						只需在shell终端执行下列命令：<br/>
						<br/>
						export&nbsp;JAVA_HOME=/usr/share/jdk1.5.0_05<br/>
						<br/>
						export&nbsp;PATH=JAVAHOME/bin:<br/>
						<br/>
						PATH<br/>
						<br/>
						export&nbsp;CLASSPATH=.:JAVAHOME/lib/dt.jar:<br/>
						<br/>
						JAVA_HOME/lib/tools.jar<br/>
						<br/>
						在&nbsp;linux系统&nbsp;下，如果你下载并安装了应用程序，很有可能在键入它的名称时出现“&nbsp;command&nbsp;not&nbsp;found&nbsp;”的提示内容。如果每次都到安装目标文件夹内，找到可执行文件来进行操作就太繁琐了。这涉及到环境变量&nbsp;PATH&nbsp;的设置问题，而&nbsp;PATH&nbsp;的设置也是在&nbsp;linux&nbsp;下定制环境变量的一个组成部分。本文基于&nbsp;RedHat&nbsp;9.0&nbsp;，详细讲解了环境变量定制的问题。<br/>
						<br/>
						2、变量简介<br/>
						<br/>
						Linux&nbsp;是一个多用户的操作系统。每个用户登录系统后，都会有一个专用的运行环境。通常每个用户默认的环境都是相同的，这个默认环境实际上就是一组环境变量的定义。用户可以对自己的运行环境进行定制，其方法就是修改相应的系统环境变量。<br/>
						<br/>
						3、常见的环境变量<br/>
						<br/>
						$PATH：决定了shell将到哪些目录中寻找命令或程序<br/>
						<br/>
						$HOME：当前用户主目录<br/>
						<br/>
						$MAIL：是指当前用户的邮件存放目录。<br/>
						<br/>
						$SHELL：是指当前用户用的是哪种Shell。<br/>
						<br/>
						$HISTSIZE：是指保存历史命令记录的条数<br/>
						<br/>
						$LOGNAME：是指当前用户的登录名。<br/>
						<br/>
						$HOSTNAME：是指主机的名称，许多应用程序如果要用到主机名的话，通常是从这个环境变量中来取得的。<br/>
						<br/>
						$LANG/LANGUGE：是和语言相关的环境变量，使用多种语言的用户可以修改此环境变量。<br/>
						<br/>
						PS1：是基本提示符，对于root用户是#，对于普通用户是<br/>
						<br/>
						，也可以使用一些更复杂的值。<br/>
						<br/>
						$PS2：是附属提示符，默认是“&gt;”。可以通过修改此环境变量来修改当前的命令符，比如下列命令会将提示符修改成字符串“Hello,My&nbsp;NewPrompt&nbsp;:)&nbsp;”。<br/>
						<br/>
						#&nbsp;PS1="&nbsp;Hello,My&nbsp;NewPrompt&nbsp;:)&nbsp;"<br/>
						<br/>
						$IFS：输入域分隔符。当shell读取输入时，用来分隔单词的一组字符，它们通常是空格、制表符和换行符。<br/>
						<br/>
						$0：shell脚本的名字。<br/>
						<br/>
						例如，在我的Linux系统中：<br/>
						<br/>
						echo<br/>
						<br/>
						0<br/>
						<br/>
						/bin/bash<br/>
						<br/>
						$#：传递给脚本的参数个数。<br/>
						<br/>
						：shell脚本的进程号，脚本程序通常会用它生成一个唯一的临时文件，如/tmp/tmfile_<br/>
						<br/>
						例如，在我的Linux系统中：<br/>
						<br/>
						echo<br/>
						<br/>
						$<br/>
						<br/>
						31038&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#表示当前shell进程号为31038<br/>
						<br/>
						4、export命令<br/>
						<br/>
						export命令将作为他参数的变量导入到子shell中，并使之在子shell中有效。export命令把自己的参数创建为一个环境变量，而这个环境变量可以被其他脚本和当前程序调用的程序看见。<br/>
						<br/>
						4.1&nbsp;实验&nbsp;导出变量<br/>
						<br/>
						（1）我们先列出脚本程序export2<br/>
						<br/>
						#！/bin/sh<br/>
						<br/>
						echo&nbsp;"$foo"<br/>
						<br/>
						echo&nbsp;"$bar"<br/>
						<br/>
						（2）然后是脚本export1。在这个脚本的结尾，我们调用export2：<br/>
						<br/>
						#!/bin/sh<br/>
						<br/>
						foo="The&nbsp;first&nbsp;meta-syntactic&nbsp;variable"<br/>
						<br/>
						export&nbsp;bar="The&nbsp;second&nbsp;meta-syntactic&nbsp;variable"<br/>
						<br/>
						export2<br/>
						<br/>
						运行这个脚本,将得到如下的输出：<br/>
						<br/>
						$&nbsp;export1<br/>
						<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#这是个空格，是因为变量foo在export2中不可用，所以$foo被复制为空<br/>
						<br/>
						The&nbsp;second&nbsp;meta-syntactic&nbsp;variable<br/>
						<br/>
						$<br/>
						<br/>
						4.2&nbsp;设置一个新的环境变量WELCOME<br/>
						<br/>
						exportWELCOME="Hello!"<br/>
						<br/>
						echo&nbsp;$WELCOME<br/>
						Hello!<br/>
						<br/>
						5、定制环境变量<br/>
						<br/>
						环境变量是和&nbsp;Shell&nbsp;紧密相关的，用户登录系统后就启动了一个&nbsp;Shell&nbsp;。对于&nbsp;Linux&nbsp;来说一般是&nbsp;bash&nbsp;，但也可以重新设定或切换到其它的&nbsp;Shell&nbsp;。根据发行版本的情况，&nbsp;bash&nbsp;有两个基本的系统级配置文件：&nbsp;/etc/bashrc&nbsp;和&nbsp;/etc/profile&nbsp;。这些配置文件包含两组不同的变量：&nbsp;shell&nbsp;变量和环境变量。前者只是在特定的&nbsp;shell&nbsp;中固定（如&nbsp;bash&nbsp;），后者在不同&nbsp;shell&nbsp;中固定。很明显，&nbsp;shell&nbsp;变量是局部的，而环境变量是全局的。环境变量是通过&nbsp;Shell&nbsp;命令来设置的，设置好的环境变量又可以被所有当前用户所运行的程序所使用。对于&nbsp;bash&nbsp;这个&nbsp;Shell&nbsp;程序来说，可以通过变量名来访问相应的环境变量，通过&nbsp;export&nbsp;来设置环境变量。下面通过几个实例来说明。<br/>
						<br/>
						5.1&nbsp;使用命令echo&nbsp;显示环境变量<br/>
						<br/>
						#本例使用echo显示常见的变量HOME<br/>
						<br/>
						echo<br/>
						<br/>
						HOME<br/>
						<br/>
						/home/lqm<br/>
						<br/>
						5.2&nbsp;设置一个新的环境变量<br/>
						<br/>
						$&nbsp;export&nbsp;HELLO=“Hello!”<br/>
						<br/>
						echo<br/>
						<br/>
						HELLO<br/>
						<br/>
						Hello!<br/>
						<br/>
						5.3&nbsp;使用&nbsp;env&nbsp;命令显示所有的环境变量<br/>
						<br/>
						$&nbsp;env<br/>
						<br/>
						SSH_AGENT_PID=1875<br/>
						<br/>
						HOSTNAME=lqm<br/>
						<br/>
						SHELL=/bin/bash<br/>
						<br/>
						TERM=xterm<br/>
						<br/>
						HISTSIZE=1000<br/>
						<br/>
						……<br/>
						<br/>
						5.4&nbsp;&nbsp;使用set&nbsp;命令显示所有本地定义的Shell&nbsp;变量<br/>
						<br/>
						$&nbsp;set<br/>
						<br/>
						BASH=/bin/bash<br/>
						<br/>
						……<br/>
						<br/>
						5.5&nbsp;&nbsp;使用&nbsp;unset&nbsp;命令来清除环境变量<br/>
						<br/>
						$&nbsp;export&nbsp;TEST=“test”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;增加一个环境变量&nbsp;TEST<br/>
						<br/>
						$&nbsp;env&nbsp;|&nbsp;grep&nbsp;TEST&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;此命令有输出，证明环境变量&nbsp;TEST&nbsp;已经存在了<br/>
						<br/>
						TEST=test<br/>
						<br/>
						unset<br/>
						<br/>
						TEST&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#删除环境变量TEST<br/>
						<br/>
						$&nbsp;env&nbsp;|&nbsp;grep&nbsp;TEST&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;此命令无输出，证明环境变量&nbsp;TEST&nbsp;已经存在了<br/>
						<br/>
						5.6&nbsp;&nbsp;使用&nbsp;readonly&nbsp;命令设置只读变量<br/>
						<br/>
						如果使用了&nbsp;readonly&nbsp;命令的话，变量就不可以被修改或清除了。示例如下：<br/>
						<br/>
						$&nbsp;export&nbsp;TEST="Test"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;增加一个环境变量&nbsp;TEST<br/>
						<br/>
						$&nbsp;readonly&nbsp;TEST&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#将环境变量TEST设为只读<br/>
						<br/>
						$&nbsp;unset&nbsp;TEST&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#会发现此变量不能被删除<br/>
						<br/>
						-bash:&nbsp;unset:&nbsp;TEST:&nbsp;cannot&nbsp;unset:&nbsp;readonly&nbsp;variable<br/>
						<br/>
						$&nbsp;TEST="New"&nbsp;#会发现此变量不能被修改<br/>
						<br/>
						-bash:&nbsp;TEST:&nbsp;readonly&nbsp;variable<br/>
						<br/>
						5.7&nbsp;&nbsp;用C&nbsp;程序来访问和设置环境变量<br/>
						<br/>
						对于&nbsp;C&nbsp;程序的用户来说，可以使用下列三个函数来设置或访问一个环境变量。<br/>
						<br/>
						getenv()&nbsp;访问一个环境变量。输入参数是需要访问的变量名字，返回值是一个字符串。如果所访问的环境变量不存在，则会返回&nbsp;NULL&nbsp;。<br/>
						<br/>
						setenv()&nbsp;在程序里面设置某个环境变量的函数。<br/>
						<br/>
						unsetenv()&nbsp;清除某个特定的环境变量的函数。<br/>
						<br/>
						另外，还有一个指针变量&nbsp;environ&nbsp;，它指向的是包含所有的环境变量的一个列表。下面的程序可以打印出当前运行环境里面的所有环境变量：<br/>
						<br/>
						#include&nbsp;&lt;stdio.h&gt;<br/>
						<br/>
						extern&nbsp;char**environ;<br/>
						<br/>
						int&nbsp;main&nbsp;()<br/>
						<br/>
						{<br/>
						<br/>
						char**var;<br/>
						<br/>
						for&nbsp;(var&nbsp;=environ;*var&nbsp;!=NULL;++var)<br/>
						<br/>
						printf&nbsp;("%s&nbsp;\n&nbsp;",*var);<br/>
						<br/>
						return&nbsp;0;<br/>
						<br/>
						}<br/>
						<br/>
						5.8&nbsp;通过修改环境变量定义文件来修改环境变量。<br/>
						<br/>
						需要注意的是，一般情况下，这仅仅对于普通用户适用，避免修改根用户的环境定义文件，因为那样可能会造成潜在的危险。<br/>
						<br/>
						$vi&nbsp;/etc/bashrc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#修改shell变量<br/>
						<br/>
						$vi&nbsp;/etc/profile&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#修改环境变量定义文件<br/>
						<br/>
						然后编辑你的&nbsp;PATH&nbsp;声明，其格式为：<br/>
						<br/>
						PATH=$PATH:&lt;PATH&nbsp;1&gt;:&lt;PATH&nbsp;2&gt;:&lt;PATH&nbsp;3&gt;:------:&lt;PATH&nbsp;N&gt;<br/>
						<br/>
						你可以自己加上指定的路径，中间用冒号隔开。环境变量更改后，在用户下次登陆时生效，如果想立刻生效，则可执行下面的语句：$&nbsp;source&nbsp;.bash_profile<br/>
						<br/>
						需要注意的是，最好不要把当前路径&nbsp;“./”&nbsp;放到&nbsp;PATH&nbsp;里，这样可能会受到意想不到的攻击。完成后，可以通过&nbsp;echo<br/>
						PATH&nbsp;查看当前的搜索路径。这样定制后，就可以避免频繁的启动位于&nbsp;shell&nbsp;搜索的路径之外的程序了。<br/>
					</div>
				</div>
			</section>
			<section>
				<h3>用wget做站点镜像</h3>
				<div>
					<div class="class___code class___copy_other_people_content">
						用wget做站点镜像<br/>
						<br/>
						<br/>
						<br/>
						#&nbsp;wget&nbsp;-r&nbsp;-p&nbsp;-np&nbsp;-k<br/>
						<br/>
						-r&nbsp;表示递归下载,会下载所有的链接,不过要注意的是,不要单独使用这个参数,因为如果你要下载的网站也有别的网站的链接,wget也会把别的网站的东西下载下来,所以要加上-np这个参数,表示不下载别的站点的链接.<br/>
						-np&nbsp;表示不下载别的站点的链接.<br/>
						-k&nbsp;表示将下载的网页里的链接修改为本地链接.<br/>
						-p&nbsp;获得所有显示网页所需的元素,比如图片什么的.<br/>
						<br/>
						-E&nbsp;&nbsp;或&nbsp;--html-extension&nbsp;&nbsp;&nbsp;将保存的URL的文件后缀名设定为“.html”<br/>
						<br/>
						+++++++++++++++++++++++++++++++++++++++<br/>
						#&nbsp;wget&nbsp;-c&nbsp;-t&nbsp;0&nbsp;-O&nbsp;rhel6_x86_64.iso<br/>
						<br/>
						-c&nbsp;断点续传<br/>
						-t&nbsp;0&nbsp;反复尝试的次数，0为不限次数<br/>
						-O&nbsp;rhel6_x86_64.iso&nbsp;把下载的文件命名为rhel6_x86_64.iso<br/>
						要下载的文件的网址<br/>
						<br/>
						<br/>
						+++++++++++++++++++++++++++++++++++++++<br/>
						<br/>
						wget高级用法<br/>
						<br/>
						http://blog168.chinaunix.net/space.php?uid=26050273&amp;do=blog&amp;id=1742503<br/>
						<br/>
						摘要：本文讲述了wget的一些高级用法，比如另存为，后台下载，断点下载。批量下载。<br/>
						增加下载尝试次数和测试下载链接是否生效。<br/>
						记录下载日志，下载和排除指定类型文&nbsp;件。<br/>
						<br/>
						<br/>
						1、下载单个文件<br/>
						wget&nbsp;url+filename<br/>
						<br/>
						下载过程中同时可以看到四项信息<br/>
						已经下载的比例<br/>
						已经下载的大小<br/>
						当前下载的速度<br/>
						剩余的时间<br/>
						<br/>
						2、使用一个大写O做参数表示另存为<br/>
						wget&nbsp;-O&nbsp;save_name&nbsp;url<br/>
						<br/>
						这种方法适用于对应链接中没有显式文件名的情况。<br/>
						<br/>
						例如：&nbsp;wget&nbsp;-O&nbsp;xx.zip&nbsp;php?src_id=7701<br/>
						<br/>
						再用不带-O参数的下载一次。<br/>
						<br/>
						ls&nbsp;-al<br/>
						总计&nbsp;132<br/>
						drwxr-xr-x&nbsp;2&nbsp;root&nbsp;root&nbsp;&nbsp;4096&nbsp;07-12&nbsp;10:43&nbsp;.<br/>
						drwxr-xr-x&nbsp;4&nbsp;root&nbsp;root&nbsp;&nbsp;4096&nbsp;07-11&nbsp;16:26&nbsp;..<br/>
						-rw-r--r--&nbsp;1&nbsp;root&nbsp;root&nbsp;50243&nbsp;07-12&nbsp;10:43&nbsp;download_script.php?src_id=7701<br/>
						-rw-r--r--&nbsp;1&nbsp;root&nbsp;root&nbsp;50243&nbsp;07-12&nbsp;10:43&nbsp;xx.zip<br/>
						<br/>
						我们发现，下载的大小都是一样。但是不带-O参数的，文件名还要转换一次。不如用-O参数方便。<br/>
						<br/>
						mv&nbsp;"download_script.php?src_id=7701"&nbsp;yy.zip<br/>
						<br/>
						3、指定下载速率<br/>
						方法是使用wget&nbsp;--limit-rate<br/>
						<br/>
						wget程序默认是使用所有的带宽，如果<br/>
						是在生产服务器上下载很大的文件就不可接受了。<br/>
						为了避免这种情况使用--limit-rate参数<br/>
						wget&nbsp;--limit-rate=200k<br/>
						<br/>
						<br/>
						4、断点下载<br/>
						<br/>
						使用wget&nbsp;-c完成未完成的下载<br/>
						<br/>
						下载到一半需要停下来干别的事情，用^c就可以停顿住。<br/>
						<br/>
						回来后，继续下载可以加一个-c参数。<br/>
						<br/>
						注意：如果不加入-c，那么下载的文件会多出一个.1的后缀。<br/>
						<br/>
						<br/>
						5、在后台下载<br/>
						方法：加一个-b的参数<br/>
						<br/>
						wget&nbsp;-b&nbsp;url/filename<br/>
						为后台下载。下载经过写入到wget-log文件中。<br/>
						<br/>
						用tail&nbsp;-f&nbsp;wget-log查看下载日志<br/>
						<br/>
						6、模拟在浏览器下下载<br/>
						<br/>
						有的网站不允许客户在非浏览器环境下下载。使用--user-agent来设置<br/>
						<br/>
						wget&nbsp;--user-agent="Mozilla/5.0&nbsp;(X11;&nbsp;U;&nbsp;Linux&nbsp;i686;&nbsp;en-US;&nbsp;rv:1.9.0.3)&nbsp;Gecko/2008092416&nbsp;Firefox/3.0.3"&nbsp;URL-TO-DOWNLOAD<br/>
						<br/>
						7、测试下载链接<br/>
						方法:使用--spider<br/>
						<br/>
						试图做计划下载时候，需要先检查一下下载链接是否有效。<br/>
						<br/>
						wget&nbsp;--spider&nbsp;DOWNLOAD-URL<br/>
						<br/>
						如果返回OK，则表示下载链接是正确的！<br/>
						<br/>
						例如<br/>
						wget&nbsp;--spider&nbsp;""<br/>
						Spider&nbsp;mode&nbsp;enabled.&nbsp;Check&nbsp;if&nbsp;remote&nbsp;file&nbsp;exists.<br/>
						--2010-07-12&nbsp;11:36:32--&nbsp;&nbsp;<br/>
						正在解析主机&nbsp;ip138.com...&nbsp;221.5.47.136<br/>
						Connecting&nbsp;to&nbsp;ip138.com|221.5.47.136|:80...&nbsp;已连接。<br/>
						已发出&nbsp;HTTP&nbsp;请求，正在等待回应...&nbsp;200&nbsp;OK<br/>
						长度：7817&nbsp;(7.6K)&nbsp;[text/html]<br/>
						Remote&nbsp;file&nbsp;exists&nbsp;and&nbsp;could&nbsp;contain&nbsp;further&nbsp;links,<br/>
						but&nbsp;recursion&nbsp;is&nbsp;disabled&nbsp;--&nbsp;not&nbsp;retrieving.<br/>
						<br/>
						<br/>
						8、增加尝试次数<br/>
						方法：--tries=1000<br/>
						如果网速有问题，下载大文件的时候可能会发生错误，<br/>
						默认wget尝试20次链接。<br/>
						<br/>
						如果尝试75次，可以<br/>
						wget&nbsp;--tires=75&nbsp;DOWNLOAD-URL<br/>
						<br/>
						<br/>
						9、下载多个文件使用wget&nbsp;-i<br/>
						将多个下载链接写入到一个download-file-list.txt文件中，而后用<br/>
						<br/>
						wget&nbsp;-i&nbsp;download-file-list.txt<br/>
						<br/>
						10、下载整站<br/>
						方法：用--mirror参数<br/>
						<br/>
						当你要下载一个完整站点并实现本地浏览的时候，<br/>
						wget&nbsp;--mirror&nbsp;-p&nbsp;--convert-links&nbsp;-P&nbsp;./LOCAL-DIR&nbsp;WEBSITE-URL<br/>
						<br/>
						参数讲解：<br/>
						--mirror：设置这个参数用来建立本地镜像<br/>
						-p：下载所有html文件适合显示的元素<br/>
						--convert-links：下载完成后，将文档链接都转换成本地的<br/>
						-P&nbsp;./LOCAL-DIR：保存所有的文件和目录到指定文件夹下<br/>
						<br/>
						11、下载时候禁止下载指定类型的文件<br/>
						<br/>
						例如下载站点时候，不打算下载gif动画图片。<br/>
						<br/>
						wget&nbsp;--reject=gif&nbsp;WEBSITE-TO-BE-DOWNLOADED<br/>
						<br/>
						<br/>
						12、记录下载日志<br/>
						方法：使用小写字母o<br/>
						<br/>
						wget&nbsp;-o&nbsp;xx.html.log&nbsp;-O&nbsp;xx.html&nbsp;""<br/>
						<br/>
						检查一下日志：<br/>
						[root@localhost&nbsp;opt]#&nbsp;cat&nbsp;xx.html.log<br/>
						--2010-07-12&nbsp;11:57:22--&nbsp;&nbsp;<br/>
						正在解析主机&nbsp;ip138.com...&nbsp;221.5.47.136<br/>
						Connecting&nbsp;to&nbsp;ip138.com|221.5.47.136|:80...&nbsp;已连接。<br/>
						已发出&nbsp;HTTP&nbsp;请求，正在等待回应...&nbsp;200&nbsp;OK<br/>
						长度：7817&nbsp;(7.6K)&nbsp;[text/html]<br/>
						Saving&nbsp;to:&nbsp;`xx.html'<br/>
						<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0K&nbsp;.......&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;100%&nbsp;65.5K=0.1s<br/>
						<br/>
						2010-07-12&nbsp;11:57:22&nbsp;(65.5&nbsp;KB/s)&nbsp;-&nbsp;`xx.html'&nbsp;saved&nbsp;[7817/7817]<br/>
						<br/>
						<br/>
						<br/>
						<br/>
						13、是第9条的增强版。可以限制下载容量<br/>
						<br/>
						wget&nbsp;-Q5m&nbsp;-i&nbsp;FILE-WHICH-HAS-URLS<br/>
						<br/>
						当下载的文件达到5兆的时候，停止下载。<br/>
						注意：如果不是对一个文件下载链接清单，对单个文件，<br/>
						这个限制不会生效的。<br/>
						<br/>
						<br/>
						<br/>
						<br/>
						14、和第11条正好相反，<br/>
						这条技巧是讲述如何仅仅下载指定类型的文件<br/>
						<br/>
						从一个网站中下载所有的pdf文件<br/>
						<br/>
						wget&nbsp;-r&nbsp;-A.pdf&nbsp;webpage-with-pdfs/<br/>
						<br/>
						<br/>
						<br/>
						<br/>
						15、使用wget完成ftp下&nbsp;载<br/>
						<br/>
						匿名ftp下载类似于http下载<br/>
						wget&nbsp;ftp-url即可。<br/>
						<br/>
						如果是需要输入用户名和密码，则是<br/>
						<br/>
						wget&nbsp;--ftp-user=USERNAME&nbsp;--ftp-password=PASSWORD&nbsp;DOWNLOAD-URL<br/>
						<br/>
						<br/>
						<br/>
						<br/>
						+++++++++++++++++++++++++++++++++++++++<br/>
						WEB采集研究之&nbsp;WGET&nbsp;使用手册<br/>
						http://stream2080.blog.163.com/blog/static/299032852008769409368/<br/>
						<br/>
						WEB采集也快3年了，多多少少碰到不少问题，总结总结牢骚一下～有用人得到那更好<br/>
						<br/>
						今天上经典工具wget的使用吧(奇怪blog的附件该怎么放？)<br/>
						<br/>
						WGET&nbsp;手册<br/>
						适用于版本&nbsp;wget&nbsp;1.1<br/>
						<br/>
						1.&nbsp;WGet的功能<br/>
						(1)&nbsp;后台工作<br/>
						(2)&nbsp;支持HTTP、HTTPS、FTP<br/>
						(3)&nbsp;支持HTTP&nbsp;Proxy<br/>
						(4)&nbsp;跟踪HTML、XHTML中的超链接<br/>
						(5)&nbsp;创建远程站点为本地镜像<br/>
						(6)&nbsp;转换下载后HTML文件的链接<br/>
						(7)&nbsp;下载FTP文件时支持含通配符的文件名<br/>
						(8)&nbsp;慢网速、不稳定网络支持<br/>
						(9)&nbsp;支持IPv6<br/>
						2.&nbsp;WGet命令&nbsp;wget&nbsp;[option]...&nbsp;[URL]...<br/>
						(1)&nbsp;URL格式<br/>
						<br/>
						<br/>
						<br/>
						<br/>
						*可以对URL中的不安全字符进行“%编码”<br/>
						<br/>
						*“type=a”表示以ASCII格式下载FTP文件<br/>
						*“type=i”表示以Binary格式下载FTP文件<br/>
						(2)&nbsp;Option语法<br/>
						使用GNU&nbsp;getopt处理命令行参数，每个选项都有简写形式（以“-”开头）和完<br/>
						整形式（以“--”开头），如：<br/>
						wget&nbsp;-r&nbsp;--tries=10&nbsp;-o&nbsp;log<br/>
						可以将不需要额外参数的选项连接在一起，如：<br/>
						wget&nbsp;-drc&nbsp;URL&nbsp;等效于&nbsp;wget&nbsp;-d&nbsp;-r&nbsp;-c&nbsp;URL<br/>
						可以用“--”来结束选项，如：<br/>
						wget&nbsp;-o&nbsp;log&nbsp;--&nbsp;-x<br/>
						中的“-x”被当作URL来解析。<br/>
						大多数选项因为是开关参数而不接受参数<br/>
						(3)&nbsp;WGet基本启动选项<br/>
						-V<br/>
						--version<br/>
						显示wget的版本号<br/>
						-h<br/>
						--help<br/>
						打印描述wget所有选项的帮助信息<br/>
						-b<br/>
						--background<br/>
						启动后立即转到后台执行；若未使用“-o”选项指定输出文件名，则输出重定向到<br/>
						2&nbsp;/&nbsp;13<br/>
						“wget-log”文件中<br/>
						-e&nbsp;command<br/>
						--execute&nbsp;command<br/>
						执行.wgetrc配置文件中的命令，关于.wgetrc配置文件的详细内容见后面的“启动文<br/>
						件”部分<br/>
						(4)&nbsp;日志记录及输入文件选项<br/>
						-o&nbsp;logfile<br/>
						--output-file=logfile<br/>
						将所有信息记录到日志文件logfile中<br/>
						-a&nbsp;logfile<br/>
						--append-output=logfile<br/>
						将日志内容添加到logfile尾部，而不是覆盖旧的logfile<br/>
						-d<br/>
						--debug<br/>
						打开调试输出信息，该选项对于wget的开发者非常有用。若wget编译时未打开调试<br/>
						支持，则此选项无效<br/>
						-q<br/>
						--quiet<br/>
						关闭wget的输出<br/>
						-v<br/>
						--verbose<br/>
						打开详细输出，显示所有变化信息，默认此选项是打开的<br/>
						-nv<br/>
						--non-verbose<br/>
						关闭详细输出，但仍然会输出错误信息和基本信息<br/>
						-i&nbsp;file<br/>
						--input-file=file<br/>
						从文件file中读URL，若这里“file”=“-”，则URL从标准输入读取，请使用“./-”来读取<br/>
						文件名为“-”的文件<br/>
						-F<br/>
						--force-html<br/>
						当URL输入是从一个文件中读取时，可以强制指定该文件为HTML文件，而不管此<br/>
						文件实际是什么格式的。这样使您可以下载现有HTML文件中的相对链接到本地，<br/>
						但需要添加“”到HTML中，或使用--base&nbsp;command-line选项。<br/>
						-B&nbsp;URL<br/>
						--base=URL<br/>
						与“-F”选项协同工作，相当于添加“”到“-i”指定的文件中<br/>
						(5)&nbsp;下载选项<br/>
						--bind-address=ADDRESS<br/>
						当建立客户端TCP/IP连接时，将ADDRESS绑定到本地机器，ADDRESS可以是主机<br/>
						名或IP地址，当您的主机绑定了多个IP时，该选项非常有用<br/>
						-t&nbsp;number<br/>
						--tries=number<br/>
						设定网络不好时wget的重连次数，默认是20次，当number&nbsp;=0时代表无限次重连，<br/>
						3&nbsp;/&nbsp;13<br/>
						当遇到致命错误如“connection&nbsp;refused”或“not&nbsp;found”（404），则停止自动重连<br/>
						-O&nbsp;file<br/>
						--output-document=file<br/>
						将下载的文件全部连接在一起写入文件file<br/>
						-nc<br/>
						--no-clobber<br/>
						若同一路径下存在相同文件名的文件则不再下载，这里clobber有点用词不当<br/>
						-c<br/>
						--continue<br/>
						继续下载未完成的下载，例如<br/>
						wget&nbsp;-c<br/>
						如果本地存在的ls-lR.Z这个文件的长度小于对应的远程文件，则wget将从本地文件<br/>
						长度的偏移量处开始下载远程同名文件<br/>
						--progress=type<br/>
						选择下载进度条的形式，合法的type有“dot”和“bar”（默认）两种<br/>
						-N<br/>
						--timestamping<br/>
						打开时戳，详见“时戳”部分<br/>
						-S<br/>
						--server-response<br/>
						打印HTTP服务器发送的HTTP头部及FTP服务器发送的响应<br/>
						--spider<br/>
						当打开此选项，wget将工作在Web&nbsp;Spider模式下。Wget不下载页面，仅仅是检查这<br/>
						些页面是否还存在。例如，可以使用wget来检查您的书签：<br/>
						wget&nbsp;--spider&nbsp;--force-html&nbsp;-i&nbsp;bookmarks.html<br/>
						-T&nbsp;seconds<br/>
						--timeout=seconds<br/>
						设定网络超时时间为seconds秒，等效于同时设定“--dns-timeout”，“--connect-timeout”<br/>
						以及“--read-timeout”。默认是900秒读超时，超时相关选项仅接受十进制数值，支<br/>
						持小数（如0.1秒）<br/>
						--dns-timeout=seconds<br/>
						设定DNS查询超时时间，默认无DNS超时时间<br/>
						--connect-timeout=seconds<br/>
						设定连接超时时间，默认无DNS超时时间<br/>
						--read-timeout=seconds<br/>
						设定读写超时时间（即进程挂起时间），该选项不直接影响整个下载过程，默认读<br/>
						超时时间是900秒<br/>
						waitretry=seconds<br/>
						若不需要在重新获取页面时等待，而仅当下载失败时等待指定时间。在默认的<br/>
						wgetrc配置文件中此选项是关闭的<br/>
						--random-wait<br/>
						在0~2倍等待时间之间随机选择重新获取文件的等待时间，以躲过网站日志分析。<br/>
						--no-proxy<br/>
						不使用代理（即使定义了*_proxy环境变量）<br/>
						4&nbsp;/&nbsp;13<br/>
						-Q&nbsp;quota<br/>
						--quota=quota<br/>
						指定自动下载的限额，quota值是字节数；配额不影响单个文件的下载，主要用于<br/>
						回归下载和URL输入是文件时<br/>
						--no-dns-cache<br/>
						关闭DNS查询缓冲<br/>
						--restrict-file-names=mode<br/>
						替换远端URL中在本机受限制的字符，例如，用%编码替换。默认情况下，wget<br/>
						是跳过这些字符（包括控制字符）。当设定mode为“unix”时，wget跳过字符“/”以及<br/>
						ASCII值在0–31和128–159之间的控制字符，这在unix类操作系统中的默认规定；当<br/>
						设定mode为“windows”时，wget跳过的字符包括“\”、“|”、“/”、“:”、“?”“"”、“*”、“&lt;”、<br/>
						“&gt;”，以及与unix系统中相同的控制字符。在windows模式中，wget使用“+”代替“:”<br/>
						以分隔本地文件名中的主机和端口；使用“@”代替“?”以分隔文件名中的查询参数。<br/>
						例如：在unix模式下的URL：，在windows<br/>
						模式下则表示为：。若要跳过控制字符，<br/>
						则可以使用：--restrict-file-names=nocontrol<br/>
						-4<br/>
						--inet4-only<br/>
						-6<br/>
						--inet6-only<br/>
						强制连接IPv4地址或IPv6地址<br/>
						--prefer-family=IPv4/IPv6/none<br/>
						指定优先考虑特定地址族，默认是IPv4<br/>
						--retry-connrefused<br/>
						把“connection&nbsp;refused”当成是暂态错误并再次尝试<br/>
						--user=user<br/>
						--password=password<br/>
						为HTTP或FTP文件获取指定用户名密码<br/>
						(6)&nbsp;目录选项<br/>
						-nd<br/>
						--no-directories<br/>
						当递归地获取文件是，不创建分层的目录<br/>
						-x<br/>
						--force-directories<br/>
						强迫创建一个分层目录，即使该目录本地不存在<br/>
						-nH<br/>
						--no-host-directories<br/>
						禁用主机名前缀的目录<br/>
						--protocol-directories<br/>
						使用协议名作为本地文件名的一个路径项<br/>
						--cut-dirs=number<br/>
						忽略number部分的目录成分，例如：<br/>
						无选项&nbsp;-&gt;<br/>
						-nH&nbsp;-&gt;&nbsp;pub/xemacs/<br/>
						5&nbsp;/&nbsp;13<br/>
						-nH&nbsp;--cut-dirs=1&nbsp;-&gt;&nbsp;xemacs/<br/>
						-nH&nbsp;--cut-dirs=2&nbsp;-&gt;&nbsp;.<br/>
						无选项&nbsp;-&gt;<br/>
						--cut-dirs=1&nbsp;-&gt;<br/>
						-P&nbsp;prefix<br/>
						--directory-prefix=prefix<br/>
						设定目录前缀为prefix。默认是“.”<br/>
						(7)&nbsp;HTTP选项<br/>
						-E<br/>
						--html-extension<br/>
						将保存的URL的文件后缀名设定为“.html”<br/>
						--http-user=user<br/>
						--http-password=password<br/>
						指定某个HTTP服务器上的用户名和密码，wget使用基本授权方案或消息摘要方案<br/>
						对用户名和密码进行加密<br/>
						--no-cache<br/>
						禁用Server端的cache，这对从代理服务器上重新获取本地已经过期的文档非常有效。<br/>
						wget默认是允许使用cache<br/>
						--no-cookies<br/>
						禁用cookie；wget默认允许使用cookie<br/>
						--load-cookies&nbsp;file<br/>
						在第一次的HTTP重新获取前，从txt文件file中加载cookie<br/>
						--save-cookies&nbsp;file<br/>
						退出前将cookie保存到file文件中，但不保存已过期的cookie和无有效期的cookie（会<br/>
						话cookie）<br/>
						--keep-session-cookies<br/>
						若设定此项，则--save-cookies&nbsp;file也保存会话cookie<br/>
						--ignore-length<br/>
						忽略HTTP中的Content-Length头，不仅仅下载Content-Length指定的长度<br/>
						--header=header-line<br/>
						在下载的HTML文件中添加头部header-line，例如：<br/>
						wget&nbsp;--header='Accept-Charset:&nbsp;iso-8859-2'&nbsp;\<br/>
						--header='Accept-Language:&nbsp;hr'&nbsp;\<br/>
						<br/>
						wget&nbsp;--header="Host:&nbsp;foo.bar"&nbsp;意义是：<br/>
						wget连接到localhost，但是在Host头部指定foo.bar<br/>
						--proxy-user=user<br/>
						--proxy-password=password<br/>
						为代理服务器的授权指定用户名和密码，wget采用基本授权方法对用户名和密码编<br/>
						码<br/>
						--referer=url<br/>
						在HTTP请求中添加“Referer:&nbsp;url”<br/>
						--save-headers<br/>
						6&nbsp;/&nbsp;13<br/>
						保存HTTP发送的头部到文件中<br/>
						-U&nbsp;agent-string<br/>
						--user-agent=agent-string<br/>
						将自己标识为agent-string<br/>
						--post-data=string<br/>
						--post-file=file<br/>
						使用POST方法在HTTP请求中发送特定数据。注意，wget需要事先知道数据长度应<br/>
						用举例：<br/>
						#登陆到服务器<br/>
						wget&nbsp;--save-cookies&nbsp;cookies.txt&nbsp;\<br/>
						--post-data&nbsp;'user=foo&amp;password=bar'&nbsp;\<br/>
						<br/>
						#开始“爬”网页<br/>
						wget&nbsp;--load-cookies&nbsp;cookies.txt&nbsp;\<br/>
						-p<br/>
						(8)&nbsp;HTTPS&nbsp;(SSL/TLS)选项<br/>
						--secure-protocol=protocol<br/>
						选择使用的安全协议，protocol合法值包括：auto，SSLv2，SSLv3及TLSv1<br/>
						--no-check-certificate<br/>
						不按照有效证书授权检查服务器授权证书<br/>
						--certificate=file<br/>
						使用客户端保存在file中的证书<br/>
						--certificate-type=type<br/>
						设定客户端认证方式，默认方式是PEM以及DER（也就是ASN1）<br/>
						--private-key=file<br/>
						从文件中读取私钥<br/>
						--private-key-type=type<br/>
						设定私钥类型，合法值包括：PEM（默认）和DER<br/>
						--ca-certificate=file<br/>
						用指定文件对对等端（peer）进行CA（certificate&nbsp;authorities）认证<br/>
						--ca-directory=directory<br/>
						指定包含PEM格式的CA认证目录<br/>
						--random-file=file<br/>
						指定特定文件为伪随机数生成器的数据源<br/>
						--egd-file=file<br/>
						指定特定文件为EGD（Entropy&nbsp;Gathering&nbsp;Daemon）&nbsp;socket<br/>
						(9)&nbsp;FTP选项<br/>
						--ftp-user=user<br/>
						--ftp-password=password<br/>
						指定某个FTP服务器上的用户名和密码<br/>
						--no-remove-listing<br/>
						不删除在获取FTP文件时生成的临时的.listing文件<br/>
						--no-glob<br/>
						关闭FTP通配符，默认允许使用通配符<br/>
						7&nbsp;/&nbsp;13<br/>
						--no-passive-ftp<br/>
						禁用被动FTP传输模式<br/>
						--retr-symlinks<br/>
						转换符号链接，并指向下载的文件<br/>
						--no-http-keep-alive<br/>
						关闭HTTP下载的“keep-alive”特性<br/>
						(10)&nbsp;递归获取选项<br/>
						-r<br/>
						--recursive<br/>
						打开递归获取选项<br/>
						-l&nbsp;depth<br/>
						--level=depth<br/>
						指定递归的最大深度，默认最大深度是5<br/>
						--delete-after<br/>
						在单一文档下载后立即删除<br/>
						-k<br/>
						--convert-links<br/>
						下载完成后，转换页面中的链接以方便本地浏览<br/>
						链接转换的两种方式：<br/>
						a.&nbsp;指向已下载文件的链接，则转换为相对链接<br/>
						b.&nbsp;指向未能下载成功的文件的链接，转换为“”形式<br/>
						-K<br/>
						--backup-converted<br/>
						转换链接前将原始文件备份（后缀为.orig）<br/>
						-m<br/>
						--mirror<br/>
						打开适合与做镜像的选项（recursion、time-stamping等）<br/>
						-p<br/>
						--page-requisites<br/>
						下载能够完全显示一个给定的HTML网页的所有文件<br/>
						--strict-comments<br/>
						精确解析HTML注释，默认是遇到第一个“--&gt;”即终止解析<br/>
						(11)&nbsp;递归接受/拒绝选项<br/>
						-A&nbsp;acclist<br/>
						--accept&nbsp;acclist<br/>
						-R&nbsp;rejlist<br/>
						--reject&nbsp;rejlist<br/>
						设定接受/拒绝递归下载以逗号分开的文件名前缀或模式列表<br/>
						-D&nbsp;domain-list<br/>
						--domains=domain-list<br/>
						设定要追踪的域<br/>
						--exclude-domains&nbsp;domain-list<br/>
						指定不要求追踪的域<br/>
						8&nbsp;/&nbsp;13<br/>
						--follow-ftp<br/>
						追踪HTML文档中的FTP链接，默认忽略所有FTP链接<br/>
						--follow-tags=list<br/>
						Wget包含一个HTML标记/属性对列表，按照list列表文件追踪HTML标记<br/>
						--ignore-tags=list<br/>
						不追踪list列表文件指定的HTML标记<br/>
						-H<br/>
						--span-hosts<br/>
						允许跨越服务器进行递归下载<br/>
						-L<br/>
						--relative<br/>
						仅追踪相对链接<br/>
						-I&nbsp;list<br/>
						--include-directories=list<br/>
						指定追踪目录<br/>
						-X&nbsp;list<br/>
						--exclude-directories=list<br/>
						指定不追踪的目录<br/>
						-np<br/>
						--no-parent<br/>
						不向上追踪到父目录<br/>
						3.&nbsp;递归下载<br/>
						(1)&nbsp;遍历万维网的一部分或一台HTTP服务器或FTP服务器<br/>
						(2)&nbsp;追踪链接或目录结构<br/>
						(3)&nbsp;利用输入的URL或文件解析HTML<br/>
						(4)&nbsp;HTTP递归下载采用广度优先算法，最大深度可以设定（默认为5）<br/>
						(5)&nbsp;FTP递归下载采用深度优先算法，能够下载FTP服务器直到给定深度的所有数据<br/>
						(6)&nbsp;能够镜像FTP站点<br/>
						(7)&nbsp;默认按照远程站点目录结构创建本地目录<br/>
						(8)&nbsp;使用递归下载时注意使用延时操作<br/>
						(9)&nbsp;一些例子<br/>
						?&nbsp;下载单一网页，使用--page-requisites选项<br/>
						?&nbsp;下载单一目录下的某些文件，使用-np选项<br/>
						?&nbsp;下载单一目录下的所有文件，使用-l&nbsp;1选项<br/>
						4.&nbsp;链接追踪&nbsp;如何避免下载不想要的链接<br/>
						(1)&nbsp;访问主机的树型扩展（默认情况下，每次下载仅访问一台主机）<br/>
						?&nbsp;扩展至任何关联主机XX-H选项<br/>
						?&nbsp;限制扩展至某些域XX-D选项<br/>
						例如：wget&nbsp;-rH&nbsp;-Dserver.com<br/>
						可以从所有*.server.com域下载文件<br/>
						?&nbsp;禁止扩展至某些域XX--exclude-domains选项<br/>
						例如：wget&nbsp;-rH&nbsp;-Dfoo.edu&nbsp;--exclude-domains&nbsp;sunsite.foo.edu&nbsp;\<br/>
						9&nbsp;/&nbsp;13<br/>
						<br/>
						从所有foo.edu域下载文件，而禁止从sunsite.foo.edu下载文件<br/>
						(2)&nbsp;文件类型限制<br/>
						-A&nbsp;acclist<br/>
						--accept&nbsp;acclist<br/>
						accept&nbsp;=&nbsp;acclist<br/>
						--accept选项的参数是一个文件名后缀（如gif或.gif）或字符串模式列表（如czy*<br/>
						or&nbsp;czyBear*196[0-9]*）<br/>
						-R&nbsp;rejlist<br/>
						--reject&nbsp;rejlist<br/>
						reject&nbsp;=&nbsp;rejlist<br/>
						--reject选项与--accept选项工作方式相同，但逻辑相反<br/>
						注意：这两个选项不影响HTML文件下载<br/>
						(3)&nbsp;基于目录的限制<br/>
						-I&nbsp;list<br/>
						--include&nbsp;list<br/>
						include_directories&nbsp;=&nbsp;list<br/>
						下载目录列表中的目录<br/>
						-X&nbsp;list<br/>
						--exclude&nbsp;list<br/>
						exclude_directories&nbsp;=&nbsp;list<br/>
						禁止下载目录列表中的目录<br/>
						-np<br/>
						--no-parent<br/>
						no_parent&nbsp;=&nbsp;on<br/>
						禁止访问远端当前目录的上层<br/>
						(4)&nbsp;相对链接<br/>
						打开-L选项可以仅下载超链接中的相对链接，而不下载绝对链接<br/>
						(5)&nbsp;追踪FTP链接<br/>
						由于FTP与HTTP协议的不同，所以要追踪FTP链接请使用--follow-ftp选项<br/>
						5.&nbsp;使用时戳对下载的文件进行增量更新<br/>
						使用-S选项可以在本地保留页面对应的时戳，进行增量下载是使用-N选项，例如：<br/>
						初次下载网页使用：wget&nbsp;-S<br/>
						以后更新网页使用：wget&nbsp;-N<br/>
						对于HTTP协议，时戳需要“Last-Modified”头部支持，而对于FTP协议，取决于wget<br/>
						能够解析获得目录列表中包含的日期的格式<br/>
						6.&nbsp;启动文件（wgetrc）<br/>
						(1)&nbsp;Wgetrc的位置<br/>
						wget启动时，将查找全局的启动配置文件，默认情况下，这个文件位于：<br/>
						“/usr/local/etc/wgetrc”；若该位置不存在此文件，则查找环境变量WGETRC指定的<br/>
						位置；若WGETRC环境变量未设定，wget会加载$HOME/.wgetrc；否则报错！<br/>
						10&nbsp;/&nbsp;13<br/>
						(2)&nbsp;Wgetrc语法<br/>
						wgetrc命令行的语法非常简单：“variable&nbsp;=&nbsp;value”。wgetcrc命令行语法不区分<br/>
						大小写，不区分有无下划线，忽略空行和以“#”开头的行<br/>
						(3)&nbsp;Wgetrc命令<br/>
						wgetrc命令全集如下表：<br/>
						一些说明：&nbsp;合法值都列在“=”后面；<br/>
						Bool值得设定可以用on/off或1/0；<br/>
						某些命令使用了伪随机数；<br/>
						“address”可以是主机名或以点分十进制表示的IP地址；<br/>
						“n”可以是正整数或无穷大（inf）<br/>
						“string”可以是任何非空字符串<br/>
						命令&nbsp;说明<br/>
						accept/reject&nbsp;=&nbsp;string&nbsp;相当于-A/-R<br/>
						add_hostdir&nbsp;=&nbsp;on/off&nbsp;允许/禁止使用主机名前缀的文件名；可以用-nH禁用<br/>
						continue&nbsp;=&nbsp;on/off&nbsp;允许/禁止继续完成下载部分完成的文件<br/>
						background&nbsp;=&nbsp;on/off&nbsp;允许/禁止后台运行；相当于-b<br/>
						backup_converted&nbsp;=<br/>
						on/off<br/>
						允许/禁止用后缀名.orig保存转换前的文件；相当于-K<br/>
						base&nbsp;=&nbsp;string&nbsp;用于绝对地址于相对地址的替换；相当于--base=string<br/>
						bind_address&nbsp;=&nbsp;address&nbsp;地址绑定；相当于--bind-address=address<br/>
						ca_certificate&nbsp;=&nbsp;file&nbsp;设定权限认证文件；相当于--ca-certificate=file<br/>
						ca_directory&nbsp;=&nbsp;directory&nbsp;设定权限认证文件的目录；相当于--ca-directory=directory<br/>
						cache&nbsp;=&nbsp;on/off&nbsp;打开/关闭服务器cache；相当于--no-cache<br/>
						certificate&nbsp;=&nbsp;file&nbsp;设定客户端认证文件；相当于--certificate=file<br/>
						certificate_type&nbsp;=&nbsp;string&nbsp;设定认证类型；相当于--certificate-type=string<br/>
						check_certificate&nbsp;=<br/>
						on/off<br/>
						设定是否进行授权确认；相当于--check-certificate<br/>
						convert_links&nbsp;=&nbsp;on/off&nbsp;是否转换非相对链接；相当于-k<br/>
						cookies&nbsp;=&nbsp;on/off&nbsp;是否允许cookies；相当于--cookies<br/>
						connect_timeout&nbsp;=&nbsp;n&nbsp;设定连接超时时间；相当于--connect-timeout<br/>
						cut_dirs&nbsp;=&nbsp;n&nbsp;忽略远程第n层目录成分；相当于--cut-dirs=n<br/>
						debug&nbsp;=&nbsp;on/off&nbsp;调试模式；相当于-d<br/>
						delete_after&nbsp;=&nbsp;on/off&nbsp;下载后是否删除；相当于--delete-after<br/>
						dir_prefix&nbsp;=&nbsp;string&nbsp;设定目录树的最顶级目录名；相当于-P&nbsp;string<br/>
						dirstruct&nbsp;=&nbsp;on/off&nbsp;打开/关闭目录结构；相当于-x&nbsp;或&nbsp;-nd<br/>
						dns_cache&nbsp;=&nbsp;on/off&nbsp;打开/关闭DNS&nbsp;cache；相当于--no-dns-cache<br/>
						dns_timeout&nbsp;=&nbsp;n&nbsp;设定DNS超时时间；相当于--dns-timeout<br/>
						domains&nbsp;=&nbsp;string&nbsp;相当于-D<br/>
						dot_bytes&nbsp;=&nbsp;n&nbsp;进度条使用点时，设定每个点代表的Byte数（默认1024）<br/>
						dots_in_line&nbsp;=&nbsp;n&nbsp;进度条使用点时，设定每行的点数（默认50）<br/>
						11&nbsp;/&nbsp;13<br/>
						dot_spacing&nbsp;=&nbsp;n&nbsp;设定一串中点的个数（默认10）<br/>
						egd_file&nbsp;=&nbsp;file&nbsp;设定EGD&nbsp;socket文件名为file；相当于--egd-file=file<br/>
						exclude_directories&nbsp;=<br/>
						string<br/>
						设定不用下载的目录；相当于-X<br/>
						exclude_domains&nbsp;=<br/>
						string<br/>
						相当于--exclude-domains=string<br/>
						follow_ftp&nbsp;=&nbsp;on/off&nbsp;是否追踪HTML文件中的FTP链接；相当于--follow-ftp<br/>
						follow_tags&nbsp;=&nbsp;string&nbsp;仅追踪指定的HTML标记；相当于--follow-tags=string<br/>
						force_html&nbsp;=&nbsp;on/off&nbsp;是否强制将输入文件名的对应文件当成HTML文件（-F）<br/>
						ftp_password&nbsp;=&nbsp;string&nbsp;设定FTP密码<br/>
						ftp_proxy&nbsp;=&nbsp;string&nbsp;将string当作FTP下载的代理<br/>
						ftp_user&nbsp;=&nbsp;string&nbsp;设定FTP用户名<br/>
						glob&nbsp;=&nbsp;on/off&nbsp;打开或关闭成团下载；相当于--glob和--no-glob<br/>
						header&nbsp;=&nbsp;string&nbsp;为下载的HTTP文件添加头部；相当于--header=string<br/>
						html_extension&nbsp;=&nbsp;on/off&nbsp;在text/html或application/xhtml+xml类无后缀名的文件名后添加<br/>
						“.html”后缀；相当于-E<br/>
						http_keep_alive&nbsp;=&nbsp;on/off&nbsp;是否保持HTTP链接活跃；相当于--no-http-keep-alive<br/>
						http_password&nbsp;=&nbsp;string&nbsp;设定HTTP下载用的密码；相当于--http-password=string<br/>
						http_proxy&nbsp;=&nbsp;string&nbsp;设定HTTP代理<br/>
						http_user&nbsp;=&nbsp;string&nbsp;设定HTTP&nbsp;下载用户名；相当于--http-user=string<br/>
						ignore_length&nbsp;=&nbsp;on/off&nbsp;是否忽略Content-Length头部；相当于--ignore-length<br/>
						ignore_tags&nbsp;=&nbsp;string&nbsp;递归下载时忽略某些标记；相当于--ignore-tags=string<br/>
						include_directories&nbsp;=<br/>
						string<br/>
						设定下载时追踪的目录；相当于-I&nbsp;string<br/>
						inet4_only&nbsp;=&nbsp;on/off&nbsp;强制连接IPv4地址；相当于--inet4-only或-4<br/>
						inet6_only&nbsp;=&nbsp;on/off&nbsp;强制连接IPv6地址；相当于--inet6-only或-6<br/>
						input&nbsp;=&nbsp;file&nbsp;从文件中读取URL；相当于-i&nbsp;file<br/>
						kill_longer&nbsp;=&nbsp;on/off&nbsp;是否将超出Content-Length头部值的数据当作无效数据<br/>
						limit_rate&nbsp;=&nbsp;rate&nbsp;限定下载速率；相当于--limit-rate=rate<br/>
						load_cookies&nbsp;=&nbsp;file&nbsp;从文件中加载cookie；相当于--load-cookies&nbsp;file<br/>
						logfile&nbsp;=&nbsp;file&nbsp;设定日志文件；相当于-o&nbsp;file<br/>
						mirror&nbsp;=&nbsp;on/off&nbsp;打开/关闭镜像功能；相当于-m<br/>
						netrc&nbsp;=&nbsp;on/off&nbsp;是否读netrc文件<br/>
						noclobber&nbsp;=&nbsp;on/off&nbsp;相当于-nc<br/>
						no_parent&nbsp;=&nbsp;on/off&nbsp;是否允许下载当前目录的上层；相当于--no-parent<br/>
						no_proxy&nbsp;=&nbsp;string&nbsp;避免某些代理的加载<br/>
						output_document&nbsp;=&nbsp;file&nbsp;设定输出文件名；相当于-O&nbsp;file<br/>
						page_requisites&nbsp;=&nbsp;on/off&nbsp;是否下载用于完全显示页面的元素；相当于-p<br/>
						passive_ftp&nbsp;=<br/>
						on/off/always/never<br/>
						更改被动FTP的设定；相当于--passive-ftp<br/>
						password&nbsp;=&nbsp;string&nbsp;同时设定FTP和HTTP下载的密码<br/>
						12&nbsp;/&nbsp;13<br/>
						post_data&nbsp;=&nbsp;string&nbsp;用POST方法发送所有HTTP请求，此请求的内容为一个字符串；<br/>
						相当于--post-data=string<br/>
						post_file&nbsp;=&nbsp;file&nbsp;用POST方法发送所有HTTP请求，此请求的内容为一个文件；相<br/>
						当于--post-file=file<br/>
						prefer_family&nbsp;=<br/>
						IPv4/IPv6/none<br/>
						设定优先考虑的地址族；相当于--prefer-family<br/>
						private_key&nbsp;=&nbsp;file&nbsp;设定私钥文件；相当于--private-key=file<br/>
						private_key_type&nbsp;=<br/>
						string<br/>
						设定私钥类型；相当于--private-type=string<br/>
						progress&nbsp;=&nbsp;string&nbsp;设定进度条类型；相当于--progress=string<br/>
						protocol_directories&nbsp;=<br/>
						on/off<br/>
						是否用协议名作为目录成分；相当于--protocol-directories<br/>
						proxy_user&nbsp;=&nbsp;string&nbsp;设定代理授权用户名；相当于--proxy-user=string<br/>
						proxy_password&nbsp;=&nbsp;string&nbsp;设定代理授权密码；相当于--proxy-password=string<br/>
						quiet&nbsp;=&nbsp;on/off&nbsp;是否打开安静模式；相当于-q<br/>
						quota&nbsp;=&nbsp;quota&nbsp;设定下载限额<br/>
						random_file&nbsp;=&nbsp;file&nbsp;在系统无/dev/random的情况下，设定随机数生成目录<br/>
						read_timeout&nbsp;=&nbsp;n&nbsp;设定读超时时间；相当于--read-timeout=n<br/>
						reclevel&nbsp;=&nbsp;n&nbsp;设定递归下载的深度；相当于-l&nbsp;n<br/>
						recursive&nbsp;=&nbsp;on/off&nbsp;打开或关闭递归下载；相当于-r<br/>
						referer&nbsp;=&nbsp;string&nbsp;设定HTTP&nbsp;Referer，相当于--referer=string<br/>
						relative_only&nbsp;=&nbsp;on/off&nbsp;是否仅追踪相对链接；相当于-L<br/>
						remove_listing&nbsp;=&nbsp;on/off&nbsp;是否删除wget&nbsp;下载过程中生成的&nbsp;FTP&nbsp;列表；&nbsp;相当于<br/>
						--no-remove-listing<br/>
						restrict_file_names&nbsp;=<br/>
						unix/windows<br/>
						相当于--restrict-file-names<br/>
						retr_symlinks&nbsp;=&nbsp;on/off&nbsp;当下在普通页面文件时，&nbsp;是否获取符号链接；&nbsp;相当于<br/>
						--retr-symlinks<br/>
						retry_connrefused&nbsp;=<br/>
						on/off<br/>
						是否将“connection&nbsp;refused”&nbsp;当作暂时错误；&nbsp;相当于<br/>
						--retry-connrefused<br/>
						robots&nbsp;=&nbsp;on/off&nbsp;设定是否参考智能机器人的设定，默认是启用<br/>
						save_cookies&nbsp;=&nbsp;file&nbsp;将cookies保存到文件中；相当于--save-cookies&nbsp;file<br/>
						secure_protocol&nbsp;=&nbsp;string&nbsp;设定使用的安全协议；相当于--secure-protocol=string<br/>
						server_response&nbsp;=&nbsp;on/off&nbsp;设定是否打印服务器响应；相当于-S<br/>
						span_hosts&nbsp;=&nbsp;on/off&nbsp;是否对主机名进行扩展；相当于-H<br/>
						strict_comments&nbsp;=&nbsp;on/off&nbsp;相当于--strict-comments<br/>
						timeout&nbsp;=&nbsp;n&nbsp;设定超时时间；相当于-T&nbsp;n<br/>
						timestamping&nbsp;=&nbsp;on/off&nbsp;设定是否打开时戳功能；相当于-N<br/>
						tries&nbsp;=&nbsp;n&nbsp;设定下载每个URL的最大尝试次数；相当于-t&nbsp;n<br/>
						use_proxy&nbsp;=&nbsp;on/off&nbsp;设定是否使用代理；相当于--no-proxy<br/>
						user&nbsp;=&nbsp;string&nbsp;同时设定下载HTTP和FTP文件的用户名<br/>
						verbose&nbsp;=&nbsp;on/off&nbsp;打开或关闭详细输出结果；相当于-v/-nv<br/>
						13&nbsp;/&nbsp;13<br/>
						wait&nbsp;=&nbsp;n&nbsp;设定两次下载之间的间隔；相当于-w&nbsp;n<br/>
						waitretry&nbsp;=&nbsp;n&nbsp;设定下载尝试失败时等待的时间；相当于--waitretry=n<br/>
						randomwait&nbsp;=&nbsp;on/off&nbsp;是否设定请求之间的等待时间为随机数<br/>
					</div>
				</div>
			</section>
			<section>
				<h3>Linux上的基础网络设备详解</h3>
				<div>
					<div class="class___code class___copy_other_people_content">
						Linux上的基础网络设备详解<br/>
						<br/>
						网络虚拟化是&nbsp;Cloud&nbsp;中的一个重要部分。作为基础知识，本文详细讲述&nbsp;Linux&nbsp;抽象出来的各种网络设备的原理、用法、数据流向。您通过此文，能够知道如何使用&nbsp;Linux&nbsp;的基础网络设备进行配置以达到特定的目的，分析出&nbsp;Linux&nbsp;可能的网络故障原因。<br/>
						　　Linux&nbsp;抽象网络设备简介<br/>
						<br/>
						　　和磁盘设备类似，Linux&nbsp;用户想要使用网络功能，不能通过直接操作硬件完成，而需要直接或间接的操作一个&nbsp;Linux&nbsp;为我们抽象出来的设备，既通用的&nbsp;Linux&nbsp;网络设备来完成。一个常见的情况是，系统里装有一个硬件网卡，Linux&nbsp;会在系统里为其生成一个网络设备实例，如&nbsp;eth0，用户需要对&nbsp;eth0&nbsp;发出命令以配置或使用它了。更多的硬件会带来更多的设备实例，虚拟的硬件也会带来更多的设备实例。随着网络技术，虚拟化技术的发展，更多的高级网络设备被加入了到了&nbsp;Linux&nbsp;中，使得情况变得更加复杂。在以下章节中，将一一分析在虚拟化技术中经常使用的几种&nbsp;Linux&nbsp;网络设备抽象类型：Bridge、802.1.q&nbsp;VLAN&nbsp;device、VETH、TAP，详细解释如何用它们配合&nbsp;Linux&nbsp;中的&nbsp;Route&nbsp;table、IP&nbsp;table&nbsp;简单的创建出本地虚拟网络。<br/>
						　　相关网络设备工作原理<br/>
						　　Bridge<br/>
						<br/>
						　　Bridge（桥）是&nbsp;Linux&nbsp;上用来做&nbsp;TCP/IP&nbsp;二层协议交换的设备，与现实世界中的交换机功能相似。Bridge&nbsp;设备实例可以和&nbsp;Linux&nbsp;上其他网络设备实例连接，既&nbsp;attach&nbsp;一个从设备，类似于在现实世界中的交换机和一个用户终端之间连接一根网线。当有数据到达时，Bridge&nbsp;会根据报文中的&nbsp;MAC&nbsp;信息进行广播、转发、丢弃处理。<br/>
						　　图&nbsp;1.&nbsp;Bridge&nbsp;设备工作过程<br/>
						<img src="./refs/Linux上的基础网络设备详解/1.jpg"/>
						<br/>
						　　如图所示，Bridge&nbsp;的功能主要在内核里实现。当一个从设备被&nbsp;attach&nbsp;到&nbsp;Bridge&nbsp;上时，相当于现实世界里交换机的端口被插入了一根连有终端的网线。这时在内核程序里，netdev_rx_handler_register()被调用，一个用于接受数据的回调函数被注册。以后每当这个从设备收到数据时都会调用这个函数可以把数据转发到&nbsp;Bridge&nbsp;上。当&nbsp;Bridge&nbsp;接收到此数据时，br_handle_frame()被调用，进行一个和现实世界中的交换机类似的处理过程：判断包的类别（广播/单点），查找内部&nbsp;MAC&nbsp;端口映射表，定位目标端口号，将数据转发到目标端口或丢弃，自动更新内部&nbsp;MAC&nbsp;端口映射表以自我学习。<br/>
						<br/>
						　　Bridge&nbsp;和现实世界中的二层交换机有一个区别，图中左侧画出了这种情况：数据被直接发到&nbsp;Bridge&nbsp;上，而不是从一个端口接受。这种情况可以看做&nbsp;Bridge&nbsp;自己有一个&nbsp;MAC&nbsp;可以主动发送报文，或者说&nbsp;Bridge&nbsp;自带了一个隐藏端口和寄主&nbsp;Linux&nbsp;系统自动连接，Linux&nbsp;上的程序可以直接从这个端口向&nbsp;Bridge&nbsp;上的其他端口发数据。所以当一个&nbsp;Bridge&nbsp;拥有一个网络设备时，如&nbsp;bridge0&nbsp;加入了&nbsp;eth0&nbsp;时，实际上&nbsp;bridge0&nbsp;拥有两个有效&nbsp;MAC&nbsp;地址，一个是&nbsp;bridge0&nbsp;的，一个是&nbsp;eth0&nbsp;的，他们之间可以通讯。由此带来一个有意思的事情是，Bridge&nbsp;可以设置&nbsp;IP&nbsp;地址。通常来说&nbsp;IP&nbsp;地址是三层协议的内容，不应该出现在二层设备&nbsp;Bridge&nbsp;上。但是&nbsp;Linux&nbsp;里&nbsp;Bridge&nbsp;是通用网络设备抽象的一种，只要是网络设备就能够设定&nbsp;IP&nbsp;地址。当一个&nbsp;bridge0&nbsp;拥有&nbsp;IP&nbsp;后，Linux&nbsp;便可以通过路由表或者&nbsp;IP&nbsp;表规则在三层定位&nbsp;bridge0，此时相当于&nbsp;Linux&nbsp;拥有了另外一个隐藏的虚拟网卡和&nbsp;Bridge&nbsp;的隐藏端口相连，这个网卡就是名为&nbsp;bridge0&nbsp;的通用网络设备，IP&nbsp;可以看成是这个网卡的。当有符合此&nbsp;IP&nbsp;的数据到达&nbsp;bridge0&nbsp;时，内核协议栈认为收到了一包目标为本机的数据，此时应用程序可以通过&nbsp;Socket&nbsp;接收到它。一个更好的对比例子是现实世界中的带路由的交换机设备，它也拥有一个隐藏的&nbsp;MAC&nbsp;地址，供设备中的三层协议处理程序和管理程序使用。设备里的三层协议处理程序，对应名为&nbsp;bridge0&nbsp;的通用网络设备的三层协议处理程序，即寄主&nbsp;Linux&nbsp;系统内核协议栈程序。设备里的管理程序，对应&nbsp;bridge0&nbsp;寄主&nbsp;Linux&nbsp;系统里的应用程序。<br/>
						<br/>
						　　Bridge&nbsp;的实现当前有一个限制：当一个设备被&nbsp;attach&nbsp;到&nbsp;Bridge&nbsp;上时，那个设备的&nbsp;IP&nbsp;会变的无效，Linux&nbsp;不再使用那个&nbsp;IP&nbsp;在三层接受数据。举例如下：如果&nbsp;eth0&nbsp;本来的&nbsp;IP&nbsp;是&nbsp;192.168.1.2，此时如果收到一个目标地址是&nbsp;192.168.1.2&nbsp;的数据，Linux&nbsp;的应用程序能通过&nbsp;Socket&nbsp;操作接受到它。而当&nbsp;eth0&nbsp;被&nbsp;attach&nbsp;到一个&nbsp;bridge0&nbsp;时，尽管&nbsp;eth0&nbsp;的&nbsp;IP&nbsp;还在，但应用程序是无法接受到上述数据的。此时应该把&nbsp;IP&nbsp;192.168.1.2&nbsp;赋予&nbsp;bridge0。<br/>
						<br/>
						　　另外需要注意的是数据流的方向。对于一个被&nbsp;attach&nbsp;到&nbsp;Bridge&nbsp;上的设备来说，只有它收到数据时，此包数据才会被转发到&nbsp;Bridge&nbsp;上，进而完成查表广播等后续操作。当请求是发送类型时，数据是不会被转发到&nbsp;Bridge&nbsp;上的，它会寻找下一个发送出口。用户在配置网络时经常忽略这一点从而造成网络故障。<br/>
						　　VLAN&nbsp;device&nbsp;for&nbsp;802.1.q<br/>
						<br/>
						　　VLAN&nbsp;又称虚拟网络，是一个被广泛使用的概念，有些应用程序把自己的内部网络也称为&nbsp;VLAN。此处主要说的是在物理世界中存在的，需要协议支持的&nbsp;VLAN。它的种类很多，按照协议原理一般分为：MACVLAN、802.1.q&nbsp;VLAN、802.1.qbg&nbsp;VLAN、802.1.qbh&nbsp;VLAN。其中出现较早，应用广泛并且比较成熟的是&nbsp;802.1.q&nbsp;VLAN，其基本原理是在二层协议里插入额外的&nbsp;VLAN&nbsp;协议数据（称为&nbsp;802.1.q&nbsp;VLAN&nbsp;Tag)，同时保持和传统二层设备的兼容性。Linux&nbsp;里的&nbsp;VLAN&nbsp;设备是对&nbsp;802.1.q&nbsp;协议的一种内部软件实现，模拟现实世界中的&nbsp;802.1.q&nbsp;交换机。<br/>
						图&nbsp;2&nbsp;.VLAN&nbsp;设备工作过程<br/>
						<img src="./refs/Linux上的基础网络设备详解/2.jpg"/>
						<br/>
						　　如图所示，Linux&nbsp;里&nbsp;802.1.q&nbsp;VLAN&nbsp;设备是以母子关系成对出现的，母设备相当于现实世界中的交换机&nbsp;TRUNK&nbsp;口，用于连接上级网络，子设备相当于普通接口用于连接下级网络。当数据在母子设备间传递时，内核将会根据&nbsp;802.1.q&nbsp;VLAN&nbsp;Tag&nbsp;进行对应操作。母子设备之间是一对多的关系，一个母设备可以有多个子设备，一个子设备只有一个母设备。当一个子设备有一包数据需要发送时，数据将被加入&nbsp;VLAN&nbsp;Tag&nbsp;然后从母设备发送出去。当母设备收到一包数据时，它将会分析其中的&nbsp;VLAN&nbsp;Tag，如果有对应的子设备存在，则把数据转发到那个子设备上并根据设置移除&nbsp;VLAN&nbsp;Tag，否则丢弃该数据。<br/>
						<br/>
						　　在某些设置下，VLAN&nbsp;Tag&nbsp;可以不被移除以满足某些监听程序的需要，如&nbsp;DHCP&nbsp;服务程序。举例说明如下：eth0&nbsp;作为母设备创建一个&nbsp;ID&nbsp;为&nbsp;100&nbsp;的子设备&nbsp;eth0.100。此时如果有程序要求从&nbsp;eth0.100&nbsp;发送一包数据，数据将被打上&nbsp;VLAN&nbsp;100&nbsp;的&nbsp;Tag&nbsp;从&nbsp;eth0&nbsp;发送出去。如果&nbsp;eth0&nbsp;收到一包数据，VLAN&nbsp;Tag&nbsp;是&nbsp;100，数据将被转发到&nbsp;eth0.100&nbsp;上，并根据设置决定是否移除&nbsp;VLAN&nbsp;Tag。如果&nbsp;eth0&nbsp;收到一包包含&nbsp;VLAN&nbsp;Tag&nbsp;101&nbsp;的数据，其将被丢弃。上述过程隐含以下事实：对于寄主&nbsp;Linux&nbsp;系统来说，母设备只能用来收数据，子设备只能用来发送数据。和&nbsp;Bridge&nbsp;一样，母子设备的数据也是有方向的，子设备收到的数据不会进入母设备，同样母设备上请求发送的数据不会被转到子设备上。可以把&nbsp;VLAN&nbsp;母子设备作为一个整体想象为现实世界中的&nbsp;802.1.q&nbsp;交换机，下级接口通过子设备连接到寄主&nbsp;Linux&nbsp;系统网络里，上级接口同过主设备连接到上级网络，当母设备是物理网卡时上级网络是外界真实网络，当母设备是另外一个&nbsp;Linux&nbsp;虚拟网络设备时上级网络仍然是寄主&nbsp;Linux&nbsp;系统网络。<br/>
						<br/>
						　　需要注意的是母子&nbsp;VLAN&nbsp;设备拥有相同的&nbsp;MAC&nbsp;地址，可以把它当成现实世界中&nbsp;802.1.q&nbsp;交换机的&nbsp;MAC，因此多个&nbsp;VLAN&nbsp;设备会共享一个&nbsp;MAC。当一个母设备拥有多个&nbsp;VLAN&nbsp;子设备时，子设备之间是隔离的，不存在&nbsp;Bridge&nbsp;那样的交换转发关系，原因如下：802.1.q&nbsp;VLAN&nbsp;协议的主要目的是从逻辑上隔离子网。现实世界中的&nbsp;802.1.q&nbsp;交换机存在多个&nbsp;VLAN，每个&nbsp;VLAN&nbsp;拥有多个端口，同一&nbsp;VLAN&nbsp;端口之间可以交换转发，不同&nbsp;VLAN&nbsp;端口之间隔离，所以其包含两层功能：交换与隔离。Linux&nbsp;VLAN&nbsp;device&nbsp;实现的是隔离功能，没有交换功能。一个&nbsp;VLAN&nbsp;母设备不可能拥有两个相同&nbsp;ID&nbsp;的&nbsp;VLAN&nbsp;子设备，因此也就不可能出现数据交换情况。如果想让一个&nbsp;VLAN&nbsp;里接多个设备，就需要交换功能。在&nbsp;Linux&nbsp;里&nbsp;Bridge&nbsp;专门实现交换功能，因此将&nbsp;VLAN&nbsp;子设备&nbsp;attach&nbsp;到一个&nbsp;Bridge&nbsp;上就能完成后续的交换功能。总结起来，Bridge&nbsp;加&nbsp;VLAN&nbsp;device&nbsp;能在功能层面完整模拟现实世界里的&nbsp;802.1.q&nbsp;交换机。<br/>
						<br/>
						　　Linux&nbsp;支持&nbsp;VLAN&nbsp;硬件加速，在安装有特定硬件情况下，图中所述内核处理过程可以被放到物理设备上完成。<br/>
						　　TAP&nbsp;设备与&nbsp;VETH&nbsp;设备<br/>
						<br/>
						　　TUN/TAP&nbsp;设备是一种让用户态程序向内核协议栈注入数据的设备，一个工作在三层，一个工作在二层，使用较多的是&nbsp;TAP&nbsp;设备。VETH&nbsp;设备出现较早，它的作用是反转通讯数据的方向，需要发送的数据会被转换成需要收到的数据重新送入内核网络层进行处理，从而间接的完成数据的注入。<br/>
						图&nbsp;3&nbsp;.TAP&nbsp;设备和&nbsp;VETH&nbsp;设备工作过程<br/>
						<img src="./refs/Linux上的基础网络设备详解/3.jpg"/>
						<br/>
						　　如图所示，当一个&nbsp;TAP&nbsp;设备被创建时，在&nbsp;Linux&nbsp;设备文件目录下将会生成一个对应&nbsp;char&nbsp;设备，用户程序可以像打开普通文件一样打开这个文件进行读写。当执行&nbsp;write()操作时，数据进入&nbsp;TAP&nbsp;设备，此时对于&nbsp;Linux&nbsp;网络层来说，相当于&nbsp;TAP&nbsp;设备收到了一包数据，请求内核接受它，如同普通的物理网卡从外界收到一包数据一样，不同的是其实数据来自&nbsp;Linux&nbsp;上的一个用户程序。Linux&nbsp;收到此数据后将根据网络配置进行后续处理，从而完成了用户程序向&nbsp;Linux&nbsp;内核网络层注入数据的功能。<br/>
						<br/>
						　　当用户程序执行&nbsp;read()请求时，相当于向内核查询&nbsp;TAP&nbsp;设备上是否有需要被发送出去的数据，有的话取出到用户程序里，完成&nbsp;TAP&nbsp;设备的发送数据功能。针对&nbsp;TAP&nbsp;设备的一个形象的比喻是：使用&nbsp;TAP&nbsp;设备的应用程序相当于另外一台计算机，TAP&nbsp;设备是本机的一个网卡，他们之间相互连接。应用程序通过&nbsp;read()/write()操作，和本机网络核心进行通讯。<br/>
						<br/>
						　　VETH&nbsp;设备总是成对出现，送到一端请求发送的数据总是从另一端以请求接受的形式出现。该设备不能被用户程序直接操作，但使用起来比较简单。创建并配置正确后，向其一端输入数据，VETH&nbsp;会改变数据的方向并将其送入内核网络核心，完成数据的注入。在另一端能读到此数据。<br/>
						　　网络设置举例说明<br/>
						<br/>
						　　为了更好的说明&nbsp;Linux&nbsp;网络设备的用法，下面将用一系列的例子，说明在一个复杂的&nbsp;Linux&nbsp;网络元素组合出的虚拟网络里，数据的流向。网络设置简介如下：一个中心&nbsp;Bridge：bridge0&nbsp;下&nbsp;attach&nbsp;了&nbsp;4&nbsp;个网络设备，包括&nbsp;2&nbsp;个&nbsp;VETH&nbsp;设备，1&nbsp;个&nbsp;TAP&nbsp;设备&nbsp;tap0，1&nbsp;个物理网卡&nbsp;eth0。在&nbsp;VETH&nbsp;的另外一端又创建了&nbsp;VLAN&nbsp;子设备。Linux&nbsp;上共存在&nbsp;2&nbsp;个&nbsp;VLAN&nbsp;网络，既&nbsp;vlan100&nbsp;与&nbsp;vlan200。物理网卡和外部网络相连，并且在它之下创建了一个&nbsp;VLAN&nbsp;ID&nbsp;为&nbsp;200&nbsp;的&nbsp;VLAN&nbsp;子设备。<br/>
						　　从&nbsp;vlan100&nbsp;子设备发送&nbsp;ARP&nbsp;报文<br/>
						图&nbsp;4&nbsp;.ARP&nbsp;from&nbsp;vlan100&nbsp;child&nbsp;device<br/>
						<img src="./refs/Linux上的基础网络设备详解/4.jpg"/>
						<br/>
						　　如图所示，当用户尝试&nbsp;ping&nbsp;192.168.100.3&nbsp;时，Linux&nbsp;将会根据路由表，从&nbsp;vlan100&nbsp;子设备发出&nbsp;ARP&nbsp;报文，具体过程如下：<br/>
						<br/>
						　　1)&nbsp;用户&nbsp;ping&nbsp;192.168.100.3<br/>
						<br/>
						　　2)&nbsp;Linux&nbsp;向&nbsp;vlan100&nbsp;子设备发送&nbsp;ARP&nbsp;信息。<br/>
						<br/>
						　　3)&nbsp;ARP&nbsp;报文被打上&nbsp;VLAN&nbsp;ID&nbsp;100&nbsp;的&nbsp;Tag&nbsp;成为&nbsp;ARP@vlan100，转发到母设备上。<br/>
						<br/>
						　　4)&nbsp;VETH&nbsp;设备将这一发送请求转变方向，成为一个需要接受处理的报文送入内核网络模块。<br/>
						<br/>
						　　5)&nbsp;由于对端的&nbsp;VETH&nbsp;设备被加入到了&nbsp;bridge0&nbsp;上，并且内核发现它收到一个报文，于是报文被转发到&nbsp;bridge0&nbsp;上。<br/>
						<br/>
						　　6)&nbsp;bridge0&nbsp;处理此&nbsp;ARP@vlan100&nbsp;信息，根据&nbsp;TCP/IP&nbsp;二层协议发现是一个广播请求，于是向它所知道的所有端口广播此报文，其中一路进入另一对&nbsp;VETH&nbsp;设备的一端，一路进入&nbsp;TAP&nbsp;设备&nbsp;tap0，一路进入物理网卡设备&nbsp;eth0。此时在&nbsp;tap0&nbsp;上，用户程序可以通过&nbsp;read()操作读到&nbsp;ARP@vlan100，eth0&nbsp;将会向外界发送&nbsp;ARP@vlan100，但&nbsp;eth0&nbsp;的&nbsp;VLAN&nbsp;子设备不会收到它，因为此数据方向为请求发送而不是请求接收。<br/>
						<br/>
						　　7)&nbsp;VETH&nbsp;将请求方向转换，此时在另一端得到请求接受的&nbsp;ARP@vlan100&nbsp;报文。<br/>
						<br/>
						　　8)&nbsp;对端&nbsp;VETH&nbsp;设备发现有数据需要接受，并且自己有两个&nbsp;VLAN&nbsp;子设备，于是执行&nbsp;VLAN&nbsp;处理逻辑。其中一个子设备是&nbsp;vlan100，与&nbsp;ARP@vlan100&nbsp;吻合，于是去除&nbsp;VLAN&nbsp;ID&nbsp;100&nbsp;的&nbsp;Tag&nbsp;转发到这个子设备上，重新成为标准的以太网&nbsp;ARP&nbsp;报文。另一个子设备由于&nbsp;ID&nbsp;不吻合，不会得到此报文。<br/>
						<br/>
						　　9)&nbsp;此&nbsp;VLAN&nbsp;子设备又被&nbsp;attach&nbsp;到另一个桥&nbsp;bridge1&nbsp;上，于是转发自己收到的&nbsp;ARP&nbsp;报文。<br/>
						<br/>
						　　10)&nbsp;bridge1&nbsp;广播&nbsp;ARP&nbsp;报文。<br/>
						<br/>
						　　11)&nbsp;最终另外一个&nbsp;TAP&nbsp;设备&nbsp;tap1&nbsp;收到此请求发送报文，用户程序通过&nbsp;read()可以得到它。<br/>
						　　从&nbsp;vlan200&nbsp;子设备发送&nbsp;ARP&nbsp;报文<br/>
						图&nbsp;5&nbsp;.ARP&nbsp;from&nbsp;vlan200&nbsp;child&nbsp;device<br/>
						<img src="./refs/Linux上的基础网络设备详解/5.jpg"/>
						<br/>
						　　和前面情况类似，区别是&nbsp;VLAN&nbsp;ID&nbsp;是&nbsp;200，对端的&nbsp;vlan200&nbsp;子设备设置为&nbsp;reorder_hdr&nbsp;=&nbsp;0，表示此设备被要求保留收到的报文中的&nbsp;VLAN&nbsp;Tag。此时子设备会收到&nbsp;ARP&nbsp;报文，但是带了&nbsp;VLAN&nbsp;ID&nbsp;200&nbsp;的&nbsp;Tag，既&nbsp;ARP@vlan200。<br/>
						　　从中心&nbsp;bridge&nbsp;发送&nbsp;ARP&nbsp;报文<br/>
						图&nbsp;5&nbsp;.ARP&nbsp;from&nbsp;central&nbsp;bridge<br/>
						<img src="./refs/Linux上的基础网络设备详解/5_1.jpg"/>
						<br/>
						　　当&nbsp;bridge0&nbsp;拥有&nbsp;IP&nbsp;时，通过&nbsp;Linux&nbsp;路由表用户程序可以直接将&nbsp;ARP&nbsp;报文发向&nbsp;bridge0。这时&nbsp;tap0&nbsp;和外部网络都能收到&nbsp;ARP，但&nbsp;VLAN&nbsp;子设备由于&nbsp;VLAN&nbsp;ID&nbsp;过滤的原因，将收不到&nbsp;ARP&nbsp;信息。<br/>
						　　从外部网络向物理网卡发送&nbsp;ARP@vlan200&nbsp;报文<br/>
						　　图&nbsp;6&nbsp;.ARP&nbsp;from&nbsp;external&nbsp;network<br/>
						<img src="./refs/Linux上的基础网络设备详解/6.jpg"/>
						<br/>
						　　当外部网络连接在一个支持&nbsp;VLAN&nbsp;并且对应端口为&nbsp;vlan200&nbsp;时，此情况会发生。此时所有的&nbsp;VLAN&nbsp;ID&nbsp;为&nbsp;200&nbsp;的&nbsp;VLAN&nbsp;子设备都将接受到报文，如果设置&nbsp;reorder_hdr=0&nbsp;则会收到带&nbsp;Tag&nbsp;的&nbsp;ARP@vlan200。<br/>
						　　从&nbsp;TAP&nbsp;设备以&nbsp;ping&nbsp;方式发送&nbsp;ARP<br/>
						图&nbsp;7&nbsp;.ping&nbsp;from&nbsp;TAP&nbsp;device<br/>
						<img src="./refs/Linux上的基础网络设备详解/7.jpg"/>
						<br/>
						　　给&nbsp;tap0&nbsp;赋予&nbsp;IP&nbsp;并加入路由，此时再&nbsp;Ping&nbsp;其对应网段的未知&nbsp;IP&nbsp;会产生&nbsp;ARP&nbsp;发送请求。需要注意的是此时由于&nbsp;tap0&nbsp;上存在的是发送而不是接收请求，因此&nbsp;ARP&nbsp;报文不会被转发到桥上，从而什么也不会发生。图中右边画了一个类似情况：从&nbsp;vlan200&nbsp;子设备发送&nbsp;ARP&nbsp;请求。由于缺少&nbsp;VETH&nbsp;设备反转请求方向，因此报文也不会被转发到桥上，而是直接通过物理网卡发往外部网络。<br/>
						　　以文件操作方式从&nbsp;TAP&nbsp;设备发送报文<br/>
						图&nbsp;8&nbsp;.file&nbsp;operation&nbsp;on&nbsp;TAP&nbsp;device<br/>
						<img src="./refs/Linux上的基础网络设备详解/8.jpg"/>
						<br/>
						　　用户程序指定&nbsp;tap0&nbsp;设备发送报文有两种方式：socket&nbsp;和&nbsp;file&nbsp;operation。当用&nbsp;socket_raw&nbsp;标志新建&nbsp;socket&nbsp;并指定设备编号时，可以要求内核将报文从&nbsp;tap0&nbsp;发送。但和前面的&nbsp;ping&nbsp;from&nbsp;tap0&nbsp;情况类似，由于报文方向问题，消息并不会被转发到&nbsp;bridge0&nbsp;上。当用&nbsp;open()方式打开&nbsp;tap&nbsp;设备文件时，情况有所不同。当执行&nbsp;write()操作时，内核认为&nbsp;tap0&nbsp;收到了报文，从而会触发转发动作，bridge0&nbsp;将收到它。如果发送的报文如图所示，是一个以&nbsp;A&nbsp;为目的地的携带&nbsp;VLAN&nbsp;ID&nbsp;100&nbsp;Tag&nbsp;的单点报文，bridge0&nbsp;将会找到对应的设备进行转发，对应的&nbsp;VLAN&nbsp;子设备将收到没有&nbsp;VLAN&nbsp;ID&nbsp;100&nbsp;Tag&nbsp;的报文。<br/>
						　　Linux&nbsp;上配置网络设备命令举例<br/>
						<br/>
						　　以&nbsp;Redhat6.2&nbsp;红帽&nbsp;Linux&nbsp;发行版为例，如果已安装&nbsp;VLAN&nbsp;内核模块和管理工具&nbsp;vconfig，TAP/TUN&nbsp;设备管理工具&nbsp;tunctl，那么可以用以下命令设置前述网络设备：<br/>
						<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;创建&nbsp;Bridge：brctl&nbsp;addbr&nbsp;[BRIDGE&nbsp;NAME]<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;删除&nbsp;Bridge：brctl&nbsp;delbr&nbsp;[BRIDGE&nbsp;NAME]<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;attach&nbsp;设备到&nbsp;Bridge：brctl&nbsp;addif&nbsp;[BRIDGE&nbsp;NAME]&nbsp;[DEVICE&nbsp;NAME]<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;从&nbsp;Bridge&nbsp;detach&nbsp;设备：brctl&nbsp;delif&nbsp;[BRIDGE&nbsp;NAME]&nbsp;[DEVICE&nbsp;NAME]<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;查询&nbsp;Bridge&nbsp;情况：brctl&nbsp;show<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;创建&nbsp;VLAN&nbsp;设备：vconfig&nbsp;add&nbsp;[PARENT&nbsp;DEVICE&nbsp;NAME]&nbsp;[VLAN&nbsp;ID]<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;删除&nbsp;VLAN&nbsp;设备：vconfig&nbsp;rem&nbsp;[VLAN&nbsp;DEVICE&nbsp;NAME]<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;设置&nbsp;VLAN&nbsp;设备&nbsp;flag：vconfig&nbsp;set_flag&nbsp;[VLAN&nbsp;DEVICE&nbsp;NAME]&nbsp;[FLAG]&nbsp;[VALUE]<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;设置&nbsp;VLAN&nbsp;设备&nbsp;qos：<br/>
						<br/>
						　　vconfig&nbsp;set_egress_map&nbsp;[VLAN&nbsp;DEVICE&nbsp;NAME]&nbsp;[SKB_PRIORITY]&nbsp;[VLAN_QOS]<br/>
						<br/>
						　　vconfig&nbsp;set_ingress_map&nbsp;[VLAN&nbsp;DEVICE&nbsp;NAME]&nbsp;[SKB_PRIORITY]&nbsp;[VLAN_QOS]<br/>
						<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;查询&nbsp;VLAN&nbsp;设备情况：cat&nbsp;/proc/net/vlan/[VLAN&nbsp;DEVICE&nbsp;NAME]<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;创建&nbsp;VETH&nbsp;设备：ip&nbsp;link&nbsp;add&nbsp;link&nbsp;[DEVICE&nbsp;NAME]&nbsp;type&nbsp;veth<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;创建&nbsp;TAP&nbsp;设备：tunctl&nbsp;-p&nbsp;[TAP&nbsp;DEVICE&nbsp;NAME]<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;删除&nbsp;TAP&nbsp;设备：tunctl&nbsp;-d&nbsp;[TAP&nbsp;DEVICE&nbsp;NAME]<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;查询系统里所有二层设备，包括&nbsp;VETH/TAP&nbsp;设备：ip&nbsp;link&nbsp;show<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;删除普通二层设备：ip&nbsp;link&nbsp;delete&nbsp;[DEVICE&nbsp;NAME]&nbsp;type&nbsp;[TYPE]<br/>
						<br/>
						　　小结<br/>
						<br/>
						　　综上所述，Linux&nbsp;已经提供一套基本工具供用户创建出各种内部网络，利用这些工具可以方便的创建出特定网络给应用程序使用，包括云计算中的初级内部虚拟网络。<br/>
					</div>
				</div>
			</section>
			<section>
				<h3>硬盘分区的UUID</h3>
				<div>
					<div class="class___code class___copy_other_people_content">
						硬盘分区的UUID<br/>
						<br/>
						<br/>
						Universally&nbsp;Unique&nbsp;IDentifier,&nbsp;是一种获取全局唯一命名的标准。<br/>
						1&nbsp;UUID的来历<br/>
						<br/>
						要为一个对象进行命名，并要求这个名字在时间和空间上都是唯一的，这在计算机领域是一个很重要的问题。目前已经存在很多成熟的解决方案，例如IP地址，MAC地址，DNS域名等。但这些方案都存在一个问题，那就是需要一个中央管理机构来批准和统一管理。这样就会带来两个问题：（1）需要一定费用；（2）数量受限。<br/>
						<br/>
						为了解决这个问题，UUID诞生了。它采用128位长度来表示一个名字，且同时考虑了时间和空间的唯一性，最重要的是它不需要申请注册，任何人都可以使用本地计算机运行程序自动生成。<br/>
						<br/>
						UUID最早出现在Apollo&nbsp;Network&nbsp;Computing&nbsp;System，后来被用到了OSF的DCE环境，然后被微软拿去使用，并改名GUID。相信大家都记得微软注册表里的奇怪长串数字吧，还有COM组件的名字，都是GUID。<br/>
						2&nbsp;硬盘分区命名现状<br/>
						2.1&nbsp;卷标名存在的问题<br/>
						<br/>
						大多数文件系统的元数据部分都会记录硬盘分区的名字。对于如何命名这个分区，也有很多方法，如采用卷标。<br/>
						<br/>
						这里写图片描述<br/>
						<br/>
						上面的“系统”，“软件”，“文档”就是分区的卷标名。几乎所有的文件系统类型都对卷标名进行支持。然而卷标名长度有限，并且重复的可能性比较大。可能很多人都给自己的系统分区命名为“系统”。<br/>
						<br/>
						名字重复会导致一些问题，例如把当把一个硬盘HD1，转移到另外一台带有硬盘HD2的机器上时，如果HD1和HD2存在卷标名相同的分区，那么就会给依赖于卷标名的程序带来问题。<br/>
						2.2&nbsp;Linux对分区命名的问题<br/>
						<br/>
						Linux系统对识别出的硬盘分区采用类似&nbsp;/dev/sda1，/dev/sdb1这样的格式进行动态命名。假设机器装有两块串口硬盘，Linux会按照识别顺序对第一个识别出的硬盘命名为/dev/sda，对第二块识别出的硬盘命名为/dev/sdb。而问题是识别顺序是随机的，所以启动机器之前不能确定/dev/sda到底是哪块硬盘。<br/>
						<br/>
						最常见的使用这种名称的地方就是/etc/fstab文件，它被用来设置自动挂载硬盘分区。下面是一个真实系统中的fstab文件中的一行：<br/>
						<br/>
						/dev/sda1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/store&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ext4&nbsp;&nbsp;&nbsp;&nbsp;defaults&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;0<br/>
						<br/>
						如果系统有多块硬盘，那么下次启动的时候，/store就不能确定到底挂载了哪个硬盘的第一分区，如果这个挂载点对系统运行非常重要，那么就有可能出现问题。<br/>
						2.3&nbsp;GRUB对分区命名的问题<br/>
						<br/>
						GRUB对分区命名与Linux类似，hd0表示发现的第一块硬盘，hd1表示第二块。存在的问题也与Linux相同。<br/>
						2.4&nbsp;UUID在文件系统中的使用<br/>
						<br/>
						为解决上述问题，UUID被文件系统设计者采用，使其可以持久唯一标识一个硬盘分区。其实方式很简单，就是在文件系统的超级块中使用128位存放UUID。这个UUID是在使用文件系统格式化分区时计算生成的，例如Linux下的文件系统工具mkfs就在格式化分区的同时，生成UUID并把它记录到超级块的固定区域中。<br/>
						<br/>
						下面是ext2文件系统超级块结构：<br/>
						<br/>
						struct&nbsp;ext2_super_block<br/>
						&nbsp;{&nbsp;__u32&nbsp;&nbsp;&nbsp;s_inodes_count;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;文件系统中索引节点总数&nbsp;*/<br/>
						&nbsp;&nbsp;&nbsp;__u32&nbsp;&nbsp;&nbsp;s_blocks_count;&nbsp;&nbsp;&nbsp;&nbsp;/*文件系统中总块数&nbsp;*/<br/>
						&nbsp;&nbsp;&nbsp;__u32&nbsp;&nbsp;&nbsp;s_r_blocks_count;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;为超级用户保留的块数&nbsp;*/<br/>
						&nbsp;&nbsp;&nbsp;__u32&nbsp;&nbsp;&nbsp;s_free_blocks_count;&nbsp;&nbsp;&nbsp;/*文件系统中空闲块总数&nbsp;*/<br/>
						&nbsp;&nbsp;&nbsp;__u32&nbsp;&nbsp;&nbsp;s_free_inodes_count;&nbsp;&nbsp;&nbsp;/*文件系统中空闲索引节点总数*/<br/>
						&nbsp;&nbsp;&nbsp;__u32&nbsp;&nbsp;&nbsp;s_first_data_block;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;文件系统中第一个数据块&nbsp;*/<br/>
						&nbsp;&nbsp;&nbsp;__u32&nbsp;&nbsp;&nbsp;s_log_block_size;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;用于计算逻辑块大小&nbsp;*/<br/>
						&nbsp;&nbsp;&nbsp;__s32&nbsp;&nbsp;&nbsp;s_log_frag_size;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;用于计算片大小&nbsp;*/<br/>
						&nbsp;&nbsp;&nbsp;__u32&nbsp;&nbsp;&nbsp;s_blocks_per_group;&nbsp;/*&nbsp;每组中块数&nbsp;*/<br/>
						&nbsp;&nbsp;&nbsp;__u32&nbsp;&nbsp;&nbsp;s_frags_per_group;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;每组中片数&nbsp;*/<br/>
						&nbsp;&nbsp;&nbsp;__u32&nbsp;&nbsp;&nbsp;s_inodes_per_group;&nbsp;/*&nbsp;每组中索引节点数&nbsp;*/<br/>
						&nbsp;&nbsp;&nbsp;__u32&nbsp;&nbsp;&nbsp;s_mtime;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*最后一次安装操作的时间&nbsp;*/<br/>
						&nbsp;&nbsp;&nbsp;__u32&nbsp;&nbsp;&nbsp;s_wtime;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*最后一次对该超级块进行写操作的时间&nbsp;*/<br/>
						&nbsp;&nbsp;&nbsp;__u16&nbsp;&nbsp;&nbsp;s_mnt_count;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;安装计数&nbsp;*/<br/>
						&nbsp;&nbsp;&nbsp;__s16&nbsp;&nbsp;&nbsp;s_max_mnt_count;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;最大可安装计数&nbsp;*/<br/>
						&nbsp;&nbsp;&nbsp;__u16&nbsp;&nbsp;&nbsp;s_magic;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;用于确定文件系统版本的标志&nbsp;*/<br/>
						&nbsp;&nbsp;&nbsp;__u16&nbsp;&nbsp;&nbsp;s_state;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;文件系统的状态*/<br/>
						&nbsp;&nbsp;&nbsp;__u16&nbsp;&nbsp;&nbsp;s_errors;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;当检测到有错误时如何处理&nbsp;*/<br/>
						&nbsp;&nbsp;&nbsp;__u16&nbsp;&nbsp;&nbsp;s_minor_rev_level;&nbsp;&nbsp;/*&nbsp;次版本号&nbsp;*/<br/>
						&nbsp;&nbsp;&nbsp;__u32&nbsp;&nbsp;&nbsp;s_lastcheck;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;最后一次检测文件系统状态的时间&nbsp;*/<br/>
						&nbsp;&nbsp;&nbsp;__u32&nbsp;&nbsp;&nbsp;s_checkinterval;&nbsp;/*&nbsp;两次对文件系统状态进行检测的间隔时间&nbsp;*/<br/>
						&nbsp;&nbsp;&nbsp;__u32&nbsp;&nbsp;&nbsp;s_rev_level;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;版本号&nbsp;*/<br/>
						&nbsp;&nbsp;&nbsp;__u16&nbsp;&nbsp;&nbsp;s_def_resuid;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;保留块的默认用户标识号&nbsp;*/<br/>
						&nbsp;&nbsp;&nbsp;__u16&nbsp;&nbsp;&nbsp;s_def_resgid;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;保留块的默认用户组标识号*/&nbsp;<br/>
						<br/>
						&nbsp;/*<br/>
						&nbsp;&nbsp;*&nbsp;These&nbsp;fields&nbsp;are&nbsp;for&nbsp;EXT2_DYNAMIC_REV&nbsp;superblocks&nbsp;only.<br/>
						&nbsp;&nbsp;*<br/>
						&nbsp;&nbsp;*&nbsp;Note:&nbsp;the&nbsp;difference&nbsp;between&nbsp;the&nbsp;compatible&nbsp;feature&nbsp;set&nbsp;and<br/>
						&nbsp;&nbsp;*&nbsp;the&nbsp;incompatible&nbsp;feature&nbsp;set&nbsp;is&nbsp;that&nbsp;if&nbsp;there&nbsp;is&nbsp;a&nbsp;bit&nbsp;set<br/>
						&nbsp;&nbsp;*&nbsp;in&nbsp;the&nbsp;incompatible&nbsp;feature&nbsp;set&nbsp;that&nbsp;the&nbsp;kernel&nbsp;doesn't<br/>
						&nbsp;&nbsp;*&nbsp;know&nbsp;about,&nbsp;it&nbsp;should&nbsp;refuse&nbsp;to&nbsp;mount&nbsp;the&nbsp;filesystem.<br/>
						&nbsp;&nbsp;*<br/>
						&nbsp;&nbsp;*&nbsp;e2fsck's&nbsp;requirements&nbsp;are&nbsp;more&nbsp;strict;&nbsp;if&nbsp;it&nbsp;doesn't&nbsp;know<br/>
						&nbsp;&nbsp;*&nbsp;about&nbsp;a&nbsp;feature&nbsp;in&nbsp;either&nbsp;the&nbsp;compatible&nbsp;or&nbsp;incompatible<br/>
						&nbsp;&nbsp;*&nbsp;feature&nbsp;set,&nbsp;it&nbsp;must&nbsp;abort&nbsp;and&nbsp;not&nbsp;try&nbsp;to&nbsp;meddle&nbsp;with<br/>
						&nbsp;&nbsp;*&nbsp;things&nbsp;it&nbsp;doesn't&nbsp;understand...<br/>
						&nbsp;&nbsp;*/<br/>
						__u32&nbsp;&nbsp;&nbsp;s_first_ino;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;第一个非保留的索引节点&nbsp;*/<br/>
						__u16&nbsp;&nbsp;&nbsp;s_inode_size;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;索引节点的大小&nbsp;*/<br/>
						&nbsp;&nbsp;__u16&nbsp;&nbsp;&nbsp;s_block_group_nr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;该超级块的块组号&nbsp;*/<br/>
						&nbsp;&nbsp;__u32&nbsp;&nbsp;&nbsp;s_feature_compat;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;兼容特点的位图*/<br/>
						&nbsp;&nbsp;__u32&nbsp;&nbsp;&nbsp;s_feature_incompat;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;非兼容特点的位图&nbsp;*/<br/>
						&nbsp;&nbsp;__u32&nbsp;&nbsp;&nbsp;s_feature_ro_compat;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;只读兼容特点的位图*/<br/>
						&nbsp;&nbsp;__u8&nbsp;&nbsp;&nbsp;&nbsp;s_uuid[16];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;128位的文件系统标识号*/<br/>
						&nbsp;&nbsp;char&nbsp;&nbsp;&nbsp;&nbsp;s_volume_name[16];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;卷名&nbsp;*/<br/>
						&nbsp;&nbsp;char&nbsp;&nbsp;&nbsp;&nbsp;s_last_mounted[64];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;最后一个安装点的路径名&nbsp;*/<br/>
						&nbsp;&nbsp;__u32&nbsp;&nbsp;&nbsp;s_algorithm_usage_bitmap;&nbsp;/*&nbsp;用于压缩*/<br/>
						&nbsp;&nbsp;&nbsp;/*<br/>
						&nbsp;&nbsp;&nbsp;*&nbsp;Performance&nbsp;hints.&nbsp;&nbsp;Directory&nbsp;preallocation&nbsp;should&nbsp;only<br/>
						&nbsp;&nbsp;&nbsp;*&nbsp;happen&nbsp;if&nbsp;the&nbsp;EXT2_COMPAT_PREALLOC&nbsp;flag&nbsp;is&nbsp;on.<br/>
						&nbsp;&nbsp;&nbsp;*/<br/>
						&nbsp;&nbsp;__u8&nbsp;&nbsp;&nbsp;&nbsp;s_prealloc_blocks;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;预分配的块数*/<br/>
						&nbsp;&nbsp;__u8&nbsp;&nbsp;&nbsp;&nbsp;s_prealloc_dir_blocks;&nbsp;&nbsp;/*&nbsp;给目录预分配的块数&nbsp;*/<br/>
						&nbsp;&nbsp;__u16&nbsp;&nbsp;&nbsp;s_padding1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
						&nbsp;&nbsp;__u32&nbsp;&nbsp;&nbsp;s_reserved[204];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;用null填充块的末尾&nbsp;*/<br/>
						&nbsp;};<br/>
						<br/>
						可以看到s_uuid[16]就是存放分区UUID的地方。<br/>
						<br/>
						这样，无论硬盘分区的标识就永远不会重复，而且只要分区没有被重新格式化，那么标识此分区的UUID永远不变。<br/>
						<br/>
						当然并不是所有的文件系统类型都支持UUID，例如微软的NTFS就不支持，而是采用了一个类似的其他机制。微软永远不走正路，真拿他没办法。<br/>
						3&nbsp;GRUB,&nbsp;Linux对硬盘分区UUID的支持<br/>
						3.1&nbsp;实例<br/>
						<br/>
						目前最新版本的GRUB和Linux系统都对硬盘分区的UUID机制提供了良好的支持。<br/>
						下面是CentOS6系统中/boot/grub/grub.conf配置文件的一部分：<br/>
						<br/>
						title&nbsp;CentOS&nbsp;(2.6.32-504.el6.x86_64)<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;root&nbsp;(hd0,0)<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kernel&nbsp;/boot/vmlinuz-2.6.32-504.el6.x86_64&nbsp;ro&nbsp;root=UUID=ec2c1241-2c17-46ea-8cc6-a6a850df3e94&nbsp;rd_NO_LUKS&nbsp;rd_NO_LVM&nbsp;LANG=en_US.UTF-8&nbsp;rd_NO_MD&nbsp;SYSFONT=latarcyrheb-sun16&nbsp;crashkernel=auto&nbsp;&nbsp;KEYBOARDTYPE=pc&nbsp;KEYTABLE=us&nbsp;rd_NO_DM&nbsp;rhgb&nbsp;quiet<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;initrd&nbsp;/boot/initramfs-2.6.32-504.el6.x86_64.img<br/>
						<br/>
						可以看出，GRUB本身仍采用(hd0,0)的传统方式寻找分区，而为其启动的linux提供了UUID的方式。<br/>
						<br/>
						下面是CentOS7系统中/boot/grub2/grub.cfg配置文件一部分：<br/>
						<br/>
						menuentry&nbsp;'CentOS&nbsp;Linux,&nbsp;with&nbsp;Linux&nbsp;3.10.0-123.el7.x86_64'&nbsp;--class&nbsp;centos&nbsp;--class&nbsp;gnu-linux&nbsp;--class&nbsp;gnu&nbsp;--class&nbsp;os&nbsp;--unrestricted&nbsp;$menuentry_id_option&nbsp;'gnulinux-3.10.0-123.el7.x86_64-advanced-b1e99de2-d388-4882-9b3a-5ced68992ee0'&nbsp;{<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;load_video<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;gfxpayload=keep<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;insmod&nbsp;gzio<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;insmod&nbsp;part_msdos<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;insmod&nbsp;xfs<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;root='hd0,msdos1'<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;[&nbsp;x$feature_platform_search_hint&nbsp;=&nbsp;xy&nbsp;];&nbsp;then<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;search&nbsp;--no-floppy&nbsp;--fs-uuid&nbsp;--set=root&nbsp;--hint-bios=hd0,msdos1&nbsp;--hint-efi=hd0,msdos1&nbsp;--hint-baremetal=ahci0,msdos1&nbsp;--hint='hd0,msdos1'&nbsp;&nbsp;49224d20-43a6-44f2-8cf5-cfa11758a3a7<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;else<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;search&nbsp;--no-floppy&nbsp;--fs-uuid&nbsp;--set=root&nbsp;49224d20-43a6-44f2-8cf5-cfa11758a3a7<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;fi<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;linux16&nbsp;/vmlinuz-3.10.0-123.el7.x86_64&nbsp;root=UUID=b1e99de2-d388-4882-9b3a-5ced68992ee0&nbsp;ro&nbsp;rd.lvm.lv=centos/swap&nbsp;vconsole.font=latarcyrheb-sun16&nbsp;rd.lvm.lv=centos/root&nbsp;crashkernel=auto&nbsp;&nbsp;vconsole.keymap=us&nbsp;rhgb&nbsp;quiet&nbsp;LANG=en_US.UTF-8<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;initrd16&nbsp;/initramfs-3.10.0-123.el7.x86_64.img<br/>
						<br/>
						}<br/>
						<br/>
						可见，GRUB和LINUX均采用了UUID来寻找硬盘分区。<br/>
						<br/>
						下面是fstab的一部分：<br/>
						UUID=49224d20-43a6-44f2-8cf5-cfa11758a3a7&nbsp;/boot&nbsp;xfs&nbsp;defaults&nbsp;1&nbsp;2<br/>
						<br/>
						显然也是采用了UUID来定位硬盘分区。<br/>
						3.2&nbsp;注意事项<br/>
						<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;重新格式化分区时，分区的UUID会变更<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;所以格式化分区后，需要修改对应的配置文件，更新其UUID。<br/>
						<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;NTFS文件系统不支持UUID<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;虽然NTFS不支持UUID，但是其支持一种较短的ID，也可以拿来凑合用。<br/>
						<br/>
						既然UUID有这么多优势，毫无疑问只要系统支持，就要充分使用它。<br/>
						4&nbsp;UUID工具程序<br/>
						<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;如何查看硬盘分区的UUID<br/>
						<br/>
						分区的UUID是mkfs工具自动写入的，我们可以使用blkid来查看之。<br/>
						<br/>
						[root@db001&nbsp;~]#&nbsp;blkid<br/>
						/dev/sda1:&nbsp;UUID="33141ba9-acd3-4021-9de3-bf7460f7c77c"&nbsp;TYPE="ext3"<br/>
						/dev/sdc1:&nbsp;UUID="ec2c1241-2c17-46ea-8cc6-a6a850df3e94"&nbsp;TYPE="ext4"<br/>
						/dev/sdc2:&nbsp;UUID="a1dc0e52-777e-450a-8fac-62d7966ff619"&nbsp;TYPE="swap"<br/>
						<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;生成UUID和分析UUID<br/>
						<br/>
						为方便大家学习和理解UUID，uuid这个工具提供了很好的实践。它不仅可以用来生成UUID，而且可以对已有的UUID进行分析。<br/>
						<br/>
						[root@db001&nbsp;~]#&nbsp;uuid<br/>
						3f3418ce-0e79-11e5-b477-00e081de9b4a<br/>
						[root@db001&nbsp;~]#&nbsp;blkid<br/>
						/dev/sda1:&nbsp;UUID="33141ba9-acd3-4021-9de3-bf7460f7c77c"&nbsp;TYPE="ext3"<br/>
						/dev/sdc1:&nbsp;UUID="ec2c1241-2c17-46ea-8cc6-a6a850df3e94"&nbsp;TYPE="ext4"<br/>
						/dev/sdc2:&nbsp;UUID="a1dc0e52-777e-450a-8fac-62d7966ff619"&nbsp;TYPE="swap"<br/>
						[root@db001&nbsp;~]#&nbsp;uuid&nbsp;-d&nbsp;33141ba9-acd3-4021-9de3-bf7460f7c77c<br/>
						encode:&nbsp;STR:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;33141ba9-acd3-4021-9de3-bf7460f7c77c<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SIV:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;67895034790306977465223914142060496764<br/>
						decode:&nbsp;variant:&nbsp;DCE&nbsp;1.1,&nbsp;ISO/IEC&nbsp;11578:1996<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;version:&nbsp;4&nbsp;(random&nbsp;data&nbsp;based)<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;content:&nbsp;33:14:1B:A9:AC:D3:00:21:1D:E3:BF:74:60:F7:C7:7C<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(no&nbsp;semantics:&nbsp;random&nbsp;data&nbsp;only)<br/>
					</div>
				</div>
			</section>
			<section>
				<h3>linux 查看设备挂载信息</h3>
				<div>
					<div class="class___code class___copy_other_people_content">
						linux&nbsp;查看设备挂载信息<br/>
						<br/>
						<br/>
						系统<br/>
						<br/>
						#&nbsp;uname&nbsp;-a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;查看内核/操作系统/CPU信息<br/>
						&nbsp;#&nbsp;head&nbsp;-n&nbsp;1&nbsp;/etc/issue&nbsp;&nbsp;&nbsp;#&nbsp;查看操作系统版本&nbsp;<br/>
						#&nbsp;cat&nbsp;/proc/cpuinfo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;查看CPU信息<br/>
						&nbsp;#&nbsp;hostname&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;查看计算机名&nbsp;<br/>
						#&nbsp;lspci&nbsp;-tv&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;列出所有PCI设备<br/>
						&nbsp;#&nbsp;lsusb&nbsp;-tv&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;列出所有USB设备&nbsp;<br/>
						#&nbsp;lsmod&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;列出加载的内核模块<br/>
						&nbsp;#&nbsp;env&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;查看环境变量<br/>
						<br/>
						资源<br/>
						<br/>
						#&nbsp;free&nbsp;-m&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;查看内存使用量和交换区使用量&nbsp;<br/>
						#&nbsp;df&nbsp;-h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;查看各分区使用情况&nbsp;<br/>
						#&nbsp;du&nbsp;-sh&nbsp;&lt;目录名&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;查看指定目录的大小&nbsp;<br/>
						#&nbsp;grep&nbsp;MemTotal&nbsp;/proc/meminfo&nbsp;&nbsp;&nbsp;#&nbsp;查看内存总量<br/>
						&nbsp;#&nbsp;grep&nbsp;MemFree&nbsp;/proc/meminfo&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;查看空闲内存量<br/>
						#&nbsp;uptime&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;查看系统运行时间、用户数、负载&nbsp;<br/>
						#&nbsp;cat&nbsp;/proc/loadavg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;查看系统负载<br/>
						<br/>
						磁盘和分区<br/>
						<br/>
						#&nbsp;mount&nbsp;|&nbsp;column&nbsp;-t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;查看挂接的分区状态&nbsp;<br/>
						#&nbsp;fdisk&nbsp;-l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;查看所有分区&nbsp;<br/>
						#&nbsp;swapon&nbsp;-s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;查看所有交换分区<br/>
						&nbsp;#&nbsp;hdparm&nbsp;-i&nbsp;/dev/hda&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;查看磁盘参数(仅适用于IDE设备)&nbsp;<br/>
						#&nbsp;dmesg&nbsp;|&nbsp;grep&nbsp;IDE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;查看启动时IDE设备检测状况<br/>
						<br/>
						网络<br/>
						<br/>
						#&nbsp;ifconfig&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;查看所有网络接口的属性<br/>
						&nbsp;#&nbsp;iptables&nbsp;-L&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;查看防火墙设置&nbsp;<br/>
						#&nbsp;route&nbsp;-n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;查看路由表&nbsp;<br/>
						#&nbsp;netstat&nbsp;-lntp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;查看所有监听端口&nbsp;<br/>
						#&nbsp;netstat&nbsp;-antp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;查看所有已经建立的连接<br/>
						&nbsp;#&nbsp;netstat&nbsp;-s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;查看网络统计信息<br/>
						<br/>
						进程<br/>
						<br/>
						#&nbsp;ps&nbsp;-ef&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;查看所有进程&nbsp;<br/>
						#&nbsp;top&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;实时显示进程状态<br/>
						<br/>
						用户<br/>
						<br/>
						#&nbsp;w&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;查看活动用户&nbsp;<br/>
						#&nbsp;id&nbsp;&lt;用户名&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;查看指定用户信息&nbsp;<br/>
						#&nbsp;last&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;查看用户登录日志&nbsp;<br/>
						#&nbsp;cut&nbsp;-d:&nbsp;-f1&nbsp;/etc/passwd&nbsp;&nbsp;&nbsp;#&nbsp;查看系统所有用户&nbsp;<br/>
						#&nbsp;cut&nbsp;-d:&nbsp;-f1&nbsp;/etc/group&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;查看系统所有组&nbsp;<br/>
						#&nbsp;crontab&nbsp;-l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;查看当前用户的计划任务<br/>
						<br/>
						服务<br/>
						<br/>
						#&nbsp;chkconfig&nbsp;--list&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;列出所有系统服务&nbsp;<br/>
						#&nbsp;chkconfig&nbsp;--list&nbsp;|&nbsp;grep&nbsp;on&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;列出所有启动的系统服务<br/>
						<br/>
						程序<br/>
						<br/>
						#&nbsp;rpm&nbsp;-qa&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;查看所有安装的软件包<br/>
						<br/>
						常用命令整理如下：<br/>
						<br/>
						查看主板的序列号:&nbsp;dmidecode&nbsp;|&nbsp;grep&nbsp;-i&nbsp;’serial&nbsp;number’<br/>
						<br/>
						用硬件检测程序kuduz探测新硬件：service&nbsp;kudzu&nbsp;start&nbsp;(&nbsp;or&nbsp;restart)<br/>
						<br/>
						查看CPU信息：cat&nbsp;/proc/cpuinfo&nbsp;[dmesg&nbsp;|&nbsp;grep&nbsp;-i&nbsp;‘cpu’][dmidecode&nbsp;-t&nbsp;processor]<br/>
						<br/>
						查看内存信息：cat&nbsp;/proc/meminfo&nbsp;[free&nbsp;-m][vmstat]<br/>
						<br/>
						查看板卡信息：cat&nbsp;/proc/pci<br/>
						<br/>
						查看显卡/声卡信息：lspci&nbsp;|grep&nbsp;-i&nbsp;‘VGA’[dmesg&nbsp;|&nbsp;grep&nbsp;-i&nbsp;‘VGA’]<br/>
						<br/>
						查看网卡信息：dmesg&nbsp;|&nbsp;grep&nbsp;-i&nbsp;‘eth’[cat&nbsp;/etc/sysconfig/hwconf&nbsp;|&nbsp;grep&nbsp;-i&nbsp;eth][lspci&nbsp;|&nbsp;grep&nbsp;-i&nbsp;‘eth’]<br/>
						<br/>
						查看PCI信息：lspci&nbsp;(相比cat&nbsp;/proc/pci更直观）<br/>
						<br/>
						查看USB设备：cat&nbsp;/proc/bus/usb/devices<br/>
						<br/>
						查看键盘和鼠标:cat&nbsp;/proc/bus/input/devices<br/>
						<br/>
						查看系统硬盘信息和使用情况：fdisk&nbsp;&amp;&nbsp;disk&nbsp;–&nbsp;l&nbsp;&amp;&nbsp;df<br/>
						<br/>
						查看各设备的中断请求(IRQ):cat&nbsp;/proc/interrupts<br/>
						<br/>
						查看系统体系结构：uname&nbsp;-a<br/>
						<br/>
						查看及启动系统的32位或64位内核模式：isalist&nbsp;–v&nbsp;[isainfo&nbsp;–v][isainfo&nbsp;–b]<br/>
						<br/>
						dmidecode查看硬件信息，包括bios、cpu、内存等信息<br/>
						<br/>
						测定当前的显示器刷新频率：/usr/sbin/ffbconfig&nbsp;–rev&nbsp;?<br/>
						<br/>
						查看系统配置：/usr/platform/sun4u/sbin/prtdiag&nbsp;–v<br/>
						<br/>
						查看当前系统中已经应用的补丁：showrev&nbsp;–p<br/>
						<br/>
						显示当前的运行级别：who&nbsp;–rH<br/>
						<br/>
						查看当前的bind版本信息：nslookup&nbsp;–class=chaos&nbsp;–q=txt&nbsp;version.bind<br/>
						<br/>
						dmesg&nbsp;|&nbsp;more&nbsp;查看硬件信息<br/>
						lspci&nbsp;显示外设信息,&nbsp;如usb，网卡等信息<br/>
						lsnod&nbsp;查看已加载的驱动<br/>
						lshw<br/>
						psrinfo&nbsp;-v&nbsp;查看当前处理器的类型和速度（主频）<br/>
						prtconf&nbsp;-v&nbsp;打印当前的OBP版本号<br/>
						iostat&nbsp;–E&nbsp;查看硬盘物理信息(vendor,&nbsp;RPM,&nbsp;Capacity)<br/>
						prtvtoc&nbsp;/dev/rdsk/c0t0d0s&nbsp;查看磁盘的几何参数和分区信息<br/>
						df&nbsp;–F&nbsp;ufs&nbsp;–o&nbsp;i&nbsp;显示已经使用和未使用的i-node数目<br/>
						isalist&nbsp;–v<br/>
						<br/>
						对于“/proc”中文件可使用文件查看命令浏览其内容，文件中包含系统特定信息：<br/>
						Cpuinfo&nbsp;主机CPU信息<br/>
						Dma&nbsp;主机DMA通道信息<br/>
						Filesystems&nbsp;文件系统信息<br/>
						Interrupts&nbsp;主机中断信息<br/>
						Ioprots&nbsp;主机I/O端口号信息<br/>
						Meninfo&nbsp;主机内存信息<br/>
						Version&nbsp;Linux内存版本信息<br/>
						<br/>
						备注：&nbsp;proc&nbsp;–&nbsp;process&nbsp;information&nbsp;pseudo-filesystem&nbsp;进程信息伪装文件系统<br/>
						<br/>
						RPM<br/>
						<br/>
						​&nbsp;在Linux&nbsp;操作系统中，有一个系统软件包，它的功能类似于Windows里面的“添加/删除程序”，但是功能又比“添加/删除程序”强很多，它就是&nbsp;Red&nbsp;Hat&nbsp;Package&nbsp;Manager(简称RPM)。此工具包最先是由Red&nbsp;Hat公司推出的，后来被其他Linux开发商所借用。由于它为Linux使用者省去了很多时间，所以被广泛应用于在Linux下安装、删除软件。下面就&nbsp;给大家介绍一下它的具体使用方法。<br/>
						<br/>
						1.我们得到一个新软件，在安装之前，一般都要先查看一下这个软件包里有什么内容，假设这个文件是：Linux-1.4-6.i368.rpm，我们可以用这条命令查看：<br/>
						<br/>
						rpm&nbsp;-qpi&nbsp;Linux-1.4-6.i368.rpm<br/>
						<br/>
						系统将会列出这个软件包的详细资料，包括含有多少个文件、各文件名称、文件大小、创建时间、编译日期等信息。<br/>
						<br/>
						2.上面列出的所有文件在安装时不一定全部安装，就像Windows下程序的安装方式分为典型、完全、自定义一样，Linux也会让你选择安装方式，此时我们可以用下面这条命令查看软件包将会在系统里安装哪些部分，以方便我们的选择：<br/>
						<br/>
						rpm&nbsp;-qpl&nbsp;Linux-1.4-6.i368.rpm<br/>
						<br/>
						\3.&nbsp;选择安装方式后，开始安装。我们可以用rpm-ivh&nbsp;Linux-1.4-6.i368.rpm命令安装此软件。在安装过程中，若系统提示此软件已安装过或因其他原因无法继续安装，但若我们确实想执行安装命&nbsp;令，可以在&nbsp;-ivh后加一参数“-replacepkgs”：<br/>
						<br/>
						rpm&nbsp;-ivh&nbsp;-replacepkgs&nbsp;Linux-1.4-6.i368.rpm<br/>
						<br/>
						4.有时我们卸载某个安装过的软件，只需执行rpm-e&nbsp;&lt;文件名&gt;;命令即可。<br/>
						<br/>
						5.对低版本软件进行升级是提高其功能的好办法，这样可以省去我们卸载后再安装新软件的麻烦，要升级某个软件，只须执行如下命令：rpm&nbsp;-uvh&nbsp;&lt;文件名&gt;;，注意：此时的文件名必须是要升级软件的升级补丁<br/>
						<br/>
						\6.&nbsp;另外一个安装软件的方法可谓是Linux的独到之处，同时也是RMP强大功能的一个表现：通过FTP站点直接在线安装软件。当找到含有你所需软件的站点并&nbsp;与此网站连接后，执行下面的命令即可实现在线安装，譬如在线安装Linux-1.4-6.i368.rpm，可以用命令：<br/>
						<br/>
						rpm&nbsp;-i&nbsp;ftp://ftp.pht.com/pub/linux/redhat/...-1.4-6.i368.rpm<br/>
						<br/>
						\7.&nbsp;在我们使用电脑过程中，难免会有误操作，若我们误删了几个文件而影响了系统的性能时，怎样查找到底少了哪些文件呢?RPM软件包提供了一个查找损坏文件的&nbsp;功能，执行此命令：rpm&nbsp;-Va即可，Linux将为你列出所有损坏的文件。你可以通过Linux的安装光盘进行修复。<br/>
						<br/>
						8.Linux系统中文件繁多，在使用过程中，难免会碰到我们不认识的文件，在Windows下我们可以用“开始/查找”菜单快速判断某个文件属于哪个文件夹，在Linux中，下面这条命令行可以帮助我们快速判定某个文件属于哪个软件包：<br/>
						<br/>
						rpm&nbsp;-qf&nbsp;&lt;文件名&gt;;<br/>
						<br/>
						9.当每个软件包安装在Linux系统后，安装文件都会到RPM数据库中“报到”，所以，我们要查询某个已安装软件的属性时，只需到此数据库中查找即可。注意：此时的查询命令不同于1和8介绍的查询，这种方法只适用于已安装过的软件包！命令格式：<br/>
						<br/>
						rpm&nbsp;-参数　&lt;文件名&gt;;<br/>
						<br/>
						APT-GET<br/>
						<br/>
						apt-get&nbsp;update——在修改/etc/apt/sources.list或者/etc/apt/preferences之后运行该命令。此外您需要定期运行这一命令以确保您的软件包列表是最新的。<br/>
						apt-get&nbsp;install&nbsp;packagename——安装一个新软件包（参见下文的aptitude）<br/>
						apt-get&nbsp;remove&nbsp;packagename——卸载一个已安装的软件包（保留配置文件）<br/>
						apt-get&nbsp;--purge&nbsp;remove&nbsp;packagename——卸载一个已安装的软件包（删除配置文件）<br/>
						dpkg&nbsp;--force-all&nbsp;--purge&nbsp;packagename&nbsp;有些软件很难卸载，而且还阻止了别的软件的应用，就可以用这个，不过有点冒险。<br/>
						apt-get&nbsp;autoclean&nbsp;apt会把已装或已卸的软件都备份在硬盘上，所以如果需要空间的话，可以让这个命令来删除你已经删掉的软件<br/>
						apt-get&nbsp;clean&nbsp;这个命令会把安装的软件的备份也删除，不过这样不会影响软件的使用的。<br/>
						apt-get&nbsp;upgrade——更新所有已安装的软件包<br/>
						apt-get&nbsp;dist-upgrade——将系统升级到新版本<br/>
						apt-cache&nbsp;search&nbsp;string——在软件包列表中搜索字符串<br/>
						dpkg&nbsp;-l&nbsp;package-name-pattern——列出所有与模式相匹配的软件包。如果您不知道软件包的全名，您可以使用“package-name-pattern”。<br/>
						aptitude——详细查看已安装或可用的软件包。与apt-get类似，aptitude可以通过命令行方式调用，但仅限于某些命令——最常见的有安装和卸载命令。由于aptitude比apt-get了解更多信息，可以说它更适合用来进行安装和卸载。<br/>
						apt-cache&nbsp;showpkg&nbsp;pkgs——显示软件包信息。<br/>
						apt-cache&nbsp;dumpavail——打印可用软件包列表。<br/>
						apt-cache&nbsp;show&nbsp;pkgs——显示软件包记录，类似于dpkg&nbsp;–print-avail。<br/>
						apt-cache&nbsp;pkgnames——打印软件包列表中所有软件包的名称。<br/>
						dpkg&nbsp;-S&nbsp;file——这个文件属于哪个已安装软件包。<br/>
						dpkg&nbsp;-L&nbsp;package——列出软件包中的所有文件。<br/>
						apt-file&nbsp;search&nbsp;filename——查找包含特定文件的软件包（不一定是已安装的），这些文件的文件名中含有指定的字符串。apt-file是一个独立的软件包。您必须&nbsp;先使用apt-get&nbsp;install来安装它，然后运行apt-file&nbsp;update。如果apt-file&nbsp;search&nbsp;filename输出的内容太多，您可以尝试使用apt-file&nbsp;search&nbsp;filename&nbsp;|&nbsp;grep&nbsp;-w&nbsp;filename（只显示指定字符串作为完整的单词出现在其中的那些文件名）或者类似方法，例如：apt-file&nbsp;search&nbsp;filename&nbsp;|&nbsp;grep&nbsp;/bin/（只显示位于诸如/bin或/usr/bin这些文件夹中的文件，如果您要查找的是某个特定的执行文件的话，这样做是有帮助的）。<br/>
					</div>
				</div>
			</section>
			<section>
				<h3>blkid命令 获取文件系统类型、UUID和开机自动挂载硬盘</h3>
				<div>
					<div class="class___code class___copy_other_people_content">
						blkid命令&nbsp;获取文件系统类型、UUID和开机自动挂载硬盘<br/>
						<br/>
						在Linux下可以使用blkid命令对查询设备上所采用文件系统类型进行查询。blkid主要用来对系统的块设备（包括交换分区）所使用的文件系统类型、LABEL、UUID等信息进行查询。要使用这个命令必须安装e2fsprogs软件包。<br/>
						直接使用blkid可列出当前系统中所以已挂载文件系统的类型<br/>
						如果你试图安装或者升级到最新的ubuntu，你或许会发现所有的存储设备现在都用一个叫UUID的字符串来表示了。UUID-Universally&nbsp;Unique&nbsp;IDentifiers，翻译过来就是“全局唯一标志符”。<br/>
						<br/>
						UUID到底是什么？<br/>
						<br/>
						UUID是一个标帜你系统中的存储设备的字符串，其目的是帮助使用者唯一的确定系统中的所有存储设备，不管它们是什么类型的。它可以标识DVD驱动器，USB存储设备以及你系统中的硬盘设备等。一个典型的UUID看起来就是这样：<br/>
						<br/>
						c73a37c8-ef7f-40e4-b9de-8b2f8103844<br/>
						<br/>
						那为什么要使用UUID呢？<br/>
						<br/>
						原因1：它是真正的唯一标志符<br/>
						<br/>
						UUID为系统中的存储设备提供唯一的标识字符串，不管这个设备是什么类型的。如果你在系统中添加了新的存储设备如硬盘，很可能会造成一些麻烦，比如说启动的时候因为找不到设备而失败，而使用UUID则不会有这样的问题。<br/>
						<br/>
						原因2：设备名并非总是不变的<br/>
						<br/>
						自动分配的设备名称并非总是一致的，它们依赖于启动时内核加载模块的顺序。如果你在插入了USB盘时启动了系统，而下次启动时又把它拔掉了，就有可能导致设备名分配不一致。<br/>
						<br/>
						使用UUID对于挂载移动设备也非常有好处──例如我有一个24合一的读卡器，它支持各种各样的卡，而使用UUID总可以使同一块卡挂载在同一个地方。<br/>
						<br/>
						原因3：ubuntu中的许多关键功能现在开始依赖于UUID<br/>
						<br/>
						例如grub──系统引导程序，现在可以识别UUID，打开你的/boot/grub/menu.lst，你可以看到类似如下的语句：<br/>
						title&nbsp;Ubuntu&nbsp;hardy&nbsp;(development&nbsp;branch),&nbsp;kernel&nbsp;2.6.24-16-generic<br/>
						root&nbsp;(hd2,0)<br/>
						kernel&nbsp;/boot/vmlinuz-2.6.24-16-generic&nbsp;root=UUID=c73a37c8-ef7f-40e4-b9de-8b2f81038441&nbsp;ro&nbsp;quiet&nbsp;splash<br/>
						initrd&nbsp;/boot/initrd.img-2.6.24-16-generic<br/>
						quiet<br/>
						<br/>
						查看设备的uuid<br/>
						<br/>
						root@useradmin-Lenovo:~#&nbsp;blkid&nbsp;-s&nbsp;UUID<br/>
						/dev/sda1:&nbsp;UUID="D8040D3E040D20DC"<br/>
						/dev/sda5:&nbsp;UUID="000E7962000B34C0"<br/>
						/dev/sda6:&nbsp;UUID="000D38F500016CA2"<br/>
						/dev/sda7:&nbsp;UUID="000CBE310009728A"<br/>
						/dev/sda8:&nbsp;UUID="000311B0000C14D6"<br/>
						/dev/sdb1:&nbsp;UUID="575fec83-5ffc-4618-816a-dfb6066dc370"<br/>
						/dev/sdb5:&nbsp;UUID="000E125200086C29"<br/>
						/dev/sdb6:&nbsp;UUID="bf7a4028-3c88-445b-8af4-27a95165ccd0"<br/>
						<br/>
						挂载设备<br/>
						编辑<br/>
						<br/>
						vi&nbsp;/etc/fstab<br/>
						追加每个设备的UUID&nbsp;都不一样<br/>
						#/dev/sda5&nbsp;<br/>
						UUID="000E7962000B34C0"&nbsp;/media/user-admin/软件&nbsp;ntfs&nbsp;defaults&nbsp;0&nbsp;2<br/>
						#/dev/sdb5&nbsp;on&nbsp;<br/>
						UUID="000E125200086C29"&nbsp;/media/user-admin/软件1&nbsp;ntfs&nbsp;defaults&nbsp;0&nbsp;2<br/>
						#/dev/sda8&nbsp;on<br/>
						UUID="000311B0000C14D6"&nbsp;/media/user-admin/软件备份&nbsp;&nbsp;ntfs&nbsp;defaults&nbsp;0&nbsp;2&nbsp;<br/>
						#/dev/sda6&nbsp;on<br/>
						UUID="000D38F500016CA2"&nbsp;/media/user-admin/文档&nbsp;&nbsp;&nbsp;&nbsp;ntfs&nbsp;defaults&nbsp;0&nbsp;2&nbsp;<br/>
						#/dev/sda7&nbsp;on&nbsp;<br/>
						UUID="000CBE310009728A"&nbsp;/media/user-admin/虚拟化&nbsp;&nbsp;&nbsp;ntfs&nbsp;defaults&nbsp;0&nbsp;2&nbsp;<br/>
						/dev/sda1&nbsp;on&nbsp;<br/>
						UUID="D8040D3E040D20DC"&nbsp;/media/user-admin/D8040D3E040D20DC&nbsp;&nbsp;ntfs&nbsp;defaults&nbsp;0&nbsp;2&nbsp;<br/>
						<br/>
						可以查看<br/>
						<br/>
						root@useradmin-Lenovo:~#&nbsp;blkid<br/>
						/dev/sda1:&nbsp;UUID="D8040D3E040D20DC"&nbsp;TYPE="ntfs"&nbsp;PARTUUID="9522e75d-01"<br/>
						/dev/sda5:&nbsp;LABEL="M-hM-=M-/M-dM-;M-6"&nbsp;UUID="000E7962000B34C0"&nbsp;TYPE="ntfs"&nbsp;PARTUUID="9522e75d-05"<br/>
						/dev/sda6:&nbsp;LABEL="M-fM-^VM-^GM-fM-!M-#"&nbsp;UUID="000D38F500016CA2"&nbsp;TYPE="ntfs"&nbsp;PARTUUID="9522e75d-06"<br/>
						/dev/sda7:&nbsp;LABEL="M-hM-^YM-^ZM-fM-^KM-^_M-eM-^LM-^V"&nbsp;UUID="000CBE310009728A"&nbsp;TYPE="ntfs"&nbsp;PARTUUID="9522e75d-07"<br/>
						/dev/sda8:&nbsp;LABEL="M-hM-=M-/M-dM-;M-6M-eM-$M-^GM-dM-;M-="&nbsp;UUID="000311B0000C14D6"&nbsp;TYPE="ntfs"&nbsp;PARTUUID="9522e75d-08"<br/>
						/dev/sdb1:&nbsp;UUID="575fec83-5ffc-4618-816a-dfb6066dc370"&nbsp;TYPE="ext4"&nbsp;PARTUUID="3b676d7c-01"<br/>
						/dev/sdb5:&nbsp;LABEL="M-hM-=M-/M-dM-;M-6"&nbsp;UUID="000E125200086C29"&nbsp;TYPE="ntfs"&nbsp;PARTUUID="3b676d7c-05"<br/>
						/dev/sdb6:&nbsp;UUID="bf7a4028-3c88-445b-8af4-27a95165ccd0"&nbsp;TYPE="swap"&nbsp;PARTUUID="3b676d7c-06"<br/>
					</div>
				</div>
			</section>
			<section>
				<h3>Linux查看硬件信息命令</h3>
				<div>
					<div class="class___code class___copy_other_people_content">
						一、查看服务器硬件信息<br/>
						<br/>
						（1）查看服务器型号、序列号<br/>
						<br/>
						[root@Master&nbsp;~]#&nbsp;dmidecode|grep&nbsp;"System&nbsp;Information"&nbsp;-A9|egrep&nbsp;&nbsp;"Manufacturer|Product|Serial"<br/>
						<img src="./refs/Linux查看硬件信息命令/1.png"/>
						<br/>
						&nbsp;（2）查看主板型号<br/>
						[root@Master&nbsp;~]#&nbsp;dmidecode&nbsp;|grep&nbsp;-A16&nbsp;"System&nbsp;Information$"<br/>
						<img src="./refs/Linux查看硬件信息命令/2.png"/>
						<br/>
						&nbsp;（3）查看BIOS信息<br/>
						[root@Master&nbsp;~]#&nbsp;dmidecode&nbsp;-t&nbsp;bios<br/>
						#&nbsp;dmidecode&nbsp;2.12<br/>
						SMBIOS&nbsp;2.8&nbsp;present.<br/>
						<br/>
						Handle&nbsp;0x0008,&nbsp;DMI&nbsp;type&nbsp;0,&nbsp;24&nbsp;bytes<br/>
						BIOS&nbsp;Information<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vendor:&nbsp;HP<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Version:&nbsp;U19<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Release&nbsp;Date:&nbsp;12/27/2015<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Address:&nbsp;0xF0000<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Runtime&nbsp;Size:&nbsp;64&nbsp;kB<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ROM&nbsp;Size:&nbsp;16384&nbsp;kB<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Characteristics:<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PCI&nbsp;is&nbsp;supported<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PNP&nbsp;is&nbsp;supported<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BIOS&nbsp;is&nbsp;upgradeable<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BIOS&nbsp;shadowing&nbsp;is&nbsp;allowed<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ESCD&nbsp;support&nbsp;is&nbsp;available<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Boot&nbsp;from&nbsp;CD&nbsp;is&nbsp;supported<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Selectable&nbsp;boot&nbsp;is&nbsp;supported<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EDD&nbsp;is&nbsp;supported<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.25"/360&nbsp;kB&nbsp;floppy&nbsp;services&nbsp;are&nbsp;supported&nbsp;(int&nbsp;13h)<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.25"/1.2&nbsp;MB&nbsp;floppy&nbsp;services&nbsp;are&nbsp;supported&nbsp;(int&nbsp;13h)<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.5"/720&nbsp;kB&nbsp;floppy&nbsp;services&nbsp;are&nbsp;supported&nbsp;(int&nbsp;13h)<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Print&nbsp;screen&nbsp;service&nbsp;is&nbsp;supported&nbsp;(int&nbsp;5h)<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8042&nbsp;keyboard&nbsp;services&nbsp;are&nbsp;supported&nbsp;(int&nbsp;9h)<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Serial&nbsp;services&nbsp;are&nbsp;supported&nbsp;(int&nbsp;14h)<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Printer&nbsp;services&nbsp;are&nbsp;supported&nbsp;(int&nbsp;17h)<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CGA/mono&nbsp;video&nbsp;services&nbsp;are&nbsp;supported&nbsp;(int&nbsp;10h)<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ACPI&nbsp;is&nbsp;supported<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;USB&nbsp;legacy&nbsp;is&nbsp;supported<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BIOS&nbsp;boot&nbsp;specification&nbsp;is&nbsp;supported<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Function&nbsp;key-initiated&nbsp;network&nbsp;boot&nbsp;is&nbsp;supported<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Targeted&nbsp;content&nbsp;distribution&nbsp;is&nbsp;supported<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UEFI&nbsp;is&nbsp;supported<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BIOS&nbsp;Revision:&nbsp;2.0<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Firmware&nbsp;Revision:&nbsp;2.40<br/>
						<br/>
						<br/>
						&nbsp;&nbsp;（3）查看内存槽及内存条<br/>
						[root@Master&nbsp;~]#&nbsp;dmidecode&nbsp;-t&nbsp;memory&nbsp;|&nbsp;head&nbsp;-45&nbsp;|&nbsp;tail&nbsp;-23<br/>
						Memory&nbsp;Device<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Array&nbsp;Handle:&nbsp;0x000A<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Error&nbsp;Information&nbsp;Handle:&nbsp;Not&nbsp;Provided<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Total&nbsp;Width:&nbsp;72&nbsp;bits<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Data&nbsp;Width:&nbsp;64&nbsp;bits<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Size:&nbsp;16384&nbsp;MB<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Form&nbsp;Factor:&nbsp;DIMM<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set:&nbsp;None<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Locator:&nbsp;PROC&nbsp;1&nbsp;DIMM&nbsp;1<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bank&nbsp;Locator:&nbsp;Not&nbsp;Specified<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Type:&nbsp;DDR4<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Type&nbsp;Detail:&nbsp;Synchronous&nbsp;Registered&nbsp;(Buffered)<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Speed:&nbsp;2133&nbsp;MHz<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Manufacturer:&nbsp;HP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Serial&nbsp;Number:&nbsp;Not&nbsp;Specified<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Asset&nbsp;Tag:&nbsp;Not&nbsp;Specified<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Part&nbsp;Number:&nbsp;752369-081<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rank:&nbsp;2<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Configured&nbsp;Clock&nbsp;Speed:&nbsp;2133&nbsp;MHz<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Minimum&nbsp;Voltage:&nbsp;&nbsp;1.2&nbsp;V<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Maximum&nbsp;Voltage:&nbsp;&nbsp;1.2&nbsp;V<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Configured&nbsp;Voltage:&nbsp;&nbsp;1.2&nbsp;V<br/>
						<br/>
						&nbsp;&nbsp;（4）查看网卡信息<br/>
						[root@Master&nbsp;~]#&nbsp;dmesg&nbsp;|&nbsp;grep&nbsp;-i&nbsp;Ethernet<br/>
						igb:&nbsp;Intel(R)&nbsp;Gigabit&nbsp;Ethernet&nbsp;Network&nbsp;Driver&nbsp;-&nbsp;version&nbsp;5.3.0-k<br/>
						igb&nbsp;0000:04:00.0:&nbsp;Intel(R)&nbsp;Gigabit&nbsp;Ethernet&nbsp;Network&nbsp;Connection<br/>
						igb&nbsp;0000:04:00.1:&nbsp;Intel(R)&nbsp;Gigabit&nbsp;Ethernet&nbsp;Network&nbsp;Connection<br/>
						igb&nbsp;0000:04:00.2:&nbsp;Intel(R)&nbsp;Gigabit&nbsp;Ethernet&nbsp;Network&nbsp;Connection<br/>
						igb&nbsp;0000:04:00.3:&nbsp;Intel(R)&nbsp;Gigabit&nbsp;Ethernet&nbsp;Network&nbsp;Connection<br/>
						igb&nbsp;0000:02:00.0:&nbsp;Intel(R)&nbsp;Gigabit&nbsp;Ethernet&nbsp;Network&nbsp;Connection<br/>
						igb&nbsp;0000:02:00.1:&nbsp;Intel(R)&nbsp;Gigabit&nbsp;Ethernet&nbsp;Network&nbsp;Connection&nbsp;<br/>
						<br/>
						（5）&nbsp;查看pci信息，即主板所有硬件槽信息<br/>
						[root@Master&nbsp;~]#&nbsp;lspci&nbsp;|&nbsp;head&nbsp;-10<br/>
						00:00.0&nbsp;Host&nbsp;bridge:&nbsp;Intel&nbsp;Corporation&nbsp;Xeon&nbsp;E7&nbsp;v3/Xeon&nbsp;E5&nbsp;v3/Core&nbsp;i7&nbsp;DMI2&nbsp;(rev&nbsp;02)<br/>
						00:01.0&nbsp;PCI&nbsp;bridge:&nbsp;Intel&nbsp;Corporation&nbsp;Xeon&nbsp;E7&nbsp;v3/Xeon&nbsp;E5&nbsp;v3/Core&nbsp;i7&nbsp;PCI&nbsp;Express&nbsp;Root&nbsp;Port&nbsp;1&nbsp;(rev&nbsp;02)<br/>
						00:01.1&nbsp;PCI&nbsp;bridge:&nbsp;Intel&nbsp;Corporation&nbsp;Xeon&nbsp;E7&nbsp;v3/Xeon&nbsp;E5&nbsp;v3/Core&nbsp;i7&nbsp;PCI&nbsp;Express&nbsp;Root&nbsp;Port&nbsp;1&nbsp;(rev&nbsp;02)<br/>
						00:02.0&nbsp;PCI&nbsp;bridge:&nbsp;Intel&nbsp;Corporation&nbsp;Xeon&nbsp;E7&nbsp;v3/Xeon&nbsp;E5&nbsp;v3/Core&nbsp;i7&nbsp;PCI&nbsp;Express&nbsp;Root&nbsp;Port&nbsp;2&nbsp;(rev&nbsp;02)<br/>
						00:02.1&nbsp;PCI&nbsp;bridge:&nbsp;Intel&nbsp;Corporation&nbsp;Xeon&nbsp;E7&nbsp;v3/Xeon&nbsp;E5&nbsp;v3/Core&nbsp;i7&nbsp;PCI&nbsp;Express&nbsp;Root&nbsp;Port&nbsp;2&nbsp;(rev&nbsp;02)<br/>
						00:02.2&nbsp;PCI&nbsp;bridge:&nbsp;Intel&nbsp;Corporation&nbsp;Xeon&nbsp;E7&nbsp;v3/Xeon&nbsp;E5&nbsp;v3/Core&nbsp;i7&nbsp;PCI&nbsp;Express&nbsp;Root&nbsp;Port&nbsp;2&nbsp;(rev&nbsp;02)<br/>
						00:02.3&nbsp;PCI&nbsp;bridge:&nbsp;Intel&nbsp;Corporation&nbsp;Xeon&nbsp;E7&nbsp;v3/Xeon&nbsp;E5&nbsp;v3/Core&nbsp;i7&nbsp;PCI&nbsp;Express&nbsp;Root&nbsp;Port&nbsp;2&nbsp;(rev&nbsp;02)<br/>
						00:03.0&nbsp;PCI&nbsp;bridge:&nbsp;Intel&nbsp;Corporation&nbsp;Xeon&nbsp;E7&nbsp;v3/Xeon&nbsp;E5&nbsp;v3/Core&nbsp;i7&nbsp;PCI&nbsp;Express&nbsp;Root&nbsp;Port&nbsp;3&nbsp;(rev&nbsp;02)<br/>
						00:03.1&nbsp;PCI&nbsp;bridge:&nbsp;Intel&nbsp;Corporation&nbsp;Xeon&nbsp;E7&nbsp;v3/Xeon&nbsp;E5&nbsp;v3/Core&nbsp;i7&nbsp;PCI&nbsp;Express&nbsp;Root&nbsp;Port&nbsp;3&nbsp;(rev&nbsp;02)<br/>
						00:03.2&nbsp;PCI&nbsp;bridge:&nbsp;Intel&nbsp;Corporation&nbsp;Xeon&nbsp;E7&nbsp;v3/Xeon&nbsp;E5&nbsp;v3/Core&nbsp;i7&nbsp;PCI&nbsp;Express&nbsp;Root&nbsp;Port&nbsp;3&nbsp;(rev&nbsp;02)<br/>
						<br/>
						<br/>
						二、查看CPU信息<br/>
						<br/>
						（1）查看cpu型号<br/>
						<br/>
						[root@Master&nbsp;~]#&nbsp;cat&nbsp;/proc/cpuinfo&nbsp;|&nbsp;grep&nbsp;name&nbsp;|&nbsp;cut&nbsp;-f2&nbsp;-d:&nbsp;|&nbsp;uniq&nbsp;-c<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;40&nbsp;&nbsp;Intel(R)&nbsp;Xeon(R)&nbsp;CPU&nbsp;E5-2650&nbsp;v3&nbsp;@&nbsp;2.30GHz<br/>
						<br/>
						（2）查看系统中实际物理CPU的数量（物理）<br/>
						<br/>
						[root@Master&nbsp;~]#&nbsp;grep&nbsp;'physical&nbsp;id'&nbsp;/proc/cpuinfo&nbsp;|&nbsp;sort&nbsp;|&nbsp;uniq&nbsp;|&nbsp;wc&nbsp;-l<br/>
						2<br/>
						<br/>
						（3）系统中实际物理CPU的数量（核数）<br/>
						<br/>
						[root@Master&nbsp;~]#&nbsp;cat&nbsp;/proc/cpuinfo&nbsp;|grep&nbsp;'processor'|wc&nbsp;-l<br/>
						40<br/>
						<br/>
						&nbsp;（4）查看每个物理CPU中core的个数(即核数)<br/>
						<br/>
						[root@Master&nbsp;~]#&nbsp;cat&nbsp;/proc/cpuinfo&nbsp;|grep&nbsp;"cores"|uniq&nbsp;<br/>
						cpu&nbsp;cores&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;10<br/>
						<br/>
						（5）查看CPU的主频<br/>
						<br/>
						[root@Master&nbsp;~]#&nbsp;cat&nbsp;/proc/cpuinfo&nbsp;|grep&nbsp;MHz|uniq&nbsp;<br/>
						cpu&nbsp;MHz&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;1200.000<br/>
						cpu&nbsp;MHz&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;2300.000<br/>
						cpu&nbsp;MHz&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;1200.000<br/>
						<br/>
						（6）查看CPU的详细信息<br/>
						[root@Master&nbsp;~]#&nbsp;cat&nbsp;/proc/cpuinfo&nbsp;|&nbsp;head&nbsp;-20<br/>
						processor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//逻辑处理器的ID<br/>
						vendor_id&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;GenuineIntel<br/>
						cpu&nbsp;family&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;6<br/>
						model&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;63<br/>
						model&nbsp;name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;Intel(R)&nbsp;Xeon(R)&nbsp;CPU&nbsp;E5-2650&nbsp;v3&nbsp;@&nbsp;2.30GHz&nbsp;&nbsp;&nbsp;//CPU型号<br/>
						stepping&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;2<br/>
						microcode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;54<br/>
						cpu&nbsp;MHz&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;1200.000<br/>
						cache&nbsp;size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;25600&nbsp;KB<br/>
						physical&nbsp;id&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;0<br/>
						siblings&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//相同物理封装处理器中逻辑处理器数<br/>
						core&nbsp;id&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;0<br/>
						cpu&nbsp;cores&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//相同物理封装处理器中的内核数<br/>
						apicid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;0<br/>
						initial&nbsp;apicid&nbsp;&nbsp;:&nbsp;0<br/>
						fpu&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;yes<br/>
						fpu_exception&nbsp;&nbsp;&nbsp;:&nbsp;yes<br/>
						cpuid&nbsp;level&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;15<br/>
						wp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;yes<br/>
						flags&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;fpu&nbsp;vme&nbsp;de&nbsp;pse&nbsp;tsc&nbsp;msr&nbsp;pae&nbsp;mce&nbsp;cx8&nbsp;apic&nbsp;sep&nbsp;mtrr&nbsp;pge&nbsp;mca&nbsp;cmov&nbsp;pat&nbsp;pse36&nbsp;clflush&nbsp;dts&nbsp;acpi&nbsp;mmx&nbsp;fxsr&nbsp;sse&nbsp;sse2&nbsp;ss&nbsp;ht&nbsp;tm&nbsp;pbe&nbsp;syscall&nbsp;nx&nbsp;pdpe1gb&nbsp;rdtscp&nbsp;lm&nbsp;constant_tsc&nbsp;arch_perfmon&nbsp;pebs&nbsp;bts&nbsp;rep_good&nbsp;xtopology&nbsp;nonstop_tsc&nbsp;aperfmperf&nbsp;pni&nbsp;pclmulqdq&nbsp;dtes64&nbsp;monitor&nbsp;ds_cpl&nbsp;vmx&nbsp;smx&nbsp;est&nbsp;tm2&nbsp;ssse3&nbsp;fma&nbsp;cx16&nbsp;xtpr&nbsp;pdcm&nbsp;pcid&nbsp;dca&nbsp;sse4_1&nbsp;sse4_2&nbsp;x2apic&nbsp;movbe&nbsp;popcnt&nbsp;tsc_deadline_timer&nbsp;aes&nbsp;xsave&nbsp;avx&nbsp;f16c&nbsp;rdrand&nbsp;lahf_lm&nbsp;abm&nbsp;ida&nbsp;arat&nbsp;epb&nbsp;xsaveopt&nbsp;pln&nbsp;pts&nbsp;dtherm&nbsp;tpr_shadow&nbsp;vnmi&nbsp;flexpriority&nbsp;ept&nbsp;vpid&nbsp;fsgsbase&nbsp;bmi1&nbsp;avx2&nbsp;smep&nbsp;bmi2&nbsp;erms&nbsp;invpcid&nbsp;cqm&nbsp;cqm_llc&nbsp;cqm_occup_llc<br/>
						<br/>
						&nbsp;（7）查看CPU的相关信息<br/>
						[root@Master&nbsp;~]#&nbsp;lscpu<br/>
						Architecture:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x86_64<br/>
						CPU&nbsp;op-mode(s):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32-bit,&nbsp;64-bit<br/>
						Byte&nbsp;Order:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Little&nbsp;Endian<br/>
						CPU(s):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;40<br/>
						On-line&nbsp;CPU(s)&nbsp;list:&nbsp;&nbsp;&nbsp;0-39<br/>
						Thread(s)&nbsp;per&nbsp;core:&nbsp;&nbsp;&nbsp;&nbsp;2<br/>
						Core(s)&nbsp;per&nbsp;socket:&nbsp;&nbsp;&nbsp;&nbsp;10<br/>
						Socket(s):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2<br/>
						NUMA&nbsp;node(s):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2<br/>
						Vendor&nbsp;ID:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GenuineIntel<br/>
						CPU&nbsp;family:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6<br/>
						Model:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;63<br/>
						Model&nbsp;name:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Intel(R)&nbsp;Xeon(R)&nbsp;CPU&nbsp;E5-2650&nbsp;v3&nbsp;@&nbsp;2.30GHz<br/>
						Stepping:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2<br/>
						CPU&nbsp;MHz:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1200.000<br/>
						BogoMIPS:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4594.43<br/>
						Virtualization:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VT-x<br/>
						L1d&nbsp;cache:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32K<br/>
						L1i&nbsp;cache:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32K<br/>
						L2&nbsp;cache:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;256K<br/>
						L3&nbsp;cache:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;25600K<br/>
						NUMA&nbsp;node0&nbsp;CPU(s):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0-9,20-29<br/>
						NUMA&nbsp;node1&nbsp;CPU(s):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10-19,30-39<br/>
						<br/>
						&nbsp;（8）查看cpu运行模式<br/>
						<br/>
						[root@Master&nbsp;~]#&nbsp;getconf&nbsp;LONG_BIT<br/>
						64<br/>
						<br/>
						&nbsp;（9）查看cpu是否支持64bit<br/>
						<br/>
						[root@Master&nbsp;~]#&nbsp;&nbsp;cat&nbsp;/proc/cpuinfo&nbsp;|&nbsp;grep&nbsp;flags&nbsp;|&nbsp;grep&nbsp;'&nbsp;lm&nbsp;'&nbsp;|&nbsp;wc&nbsp;-l<br/>
						40<br/>
						(结果大于0,&nbsp;说明支持64bit计算.&nbsp;lm指long&nbsp;mode,&nbsp;支持lm则是64bit)<br/>
						<br/>
						&nbsp;<br/>
						<br/>
						三、查看内存信息<br/>
						（1）查看内存硬件信息<br/>
						[root@Master&nbsp;~]#&nbsp;dmidecode&nbsp;-t&nbsp;memory&nbsp;|&nbsp;head&nbsp;-45&nbsp;|&nbsp;tail&nbsp;-24<br/>
						Handle&nbsp;0x000C,&nbsp;DMI&nbsp;type&nbsp;17,&nbsp;40&nbsp;bytes<br/>
						Memory&nbsp;Device<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Array&nbsp;Handle:&nbsp;0x000A<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Error&nbsp;Information&nbsp;Handle:&nbsp;Not&nbsp;Provided<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Total&nbsp;Width:&nbsp;72&nbsp;bits<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Data&nbsp;Width:&nbsp;64&nbsp;bits<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Size:&nbsp;16384&nbsp;MB<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Form&nbsp;Factor:&nbsp;DIMM<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set:&nbsp;None<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Locator:&nbsp;PROC&nbsp;1&nbsp;DIMM&nbsp;1<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bank&nbsp;Locator:&nbsp;Not&nbsp;Specified<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Type:&nbsp;DDR4<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Type&nbsp;Detail:&nbsp;Synchronous&nbsp;Registered&nbsp;(Buffered)<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Speed:&nbsp;2133&nbsp;MHz<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Manufacturer:&nbsp;HP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Serial&nbsp;Number:&nbsp;Not&nbsp;Specified<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Asset&nbsp;Tag:&nbsp;Not&nbsp;Specified<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Part&nbsp;Number:&nbsp;752369-081<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rank:&nbsp;2<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Configured&nbsp;Clock&nbsp;Speed:&nbsp;2133&nbsp;MHz<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Minimum&nbsp;Voltage:&nbsp;&nbsp;1.2&nbsp;V<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Maximum&nbsp;Voltage:&nbsp;&nbsp;1.2&nbsp;V<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Configured&nbsp;Voltage:&nbsp;&nbsp;1.2&nbsp;V<br/>
						<br/>
						&nbsp;（2）最大支持多少内存<br/>
						[root@Master&nbsp;~]#&nbsp;dmidecode|grep&nbsp;-P&nbsp;'Maximum\s+Capacity'<br/>
						<img src="./refs/Linux查看硬件信息命令/3.png"/>
						<br/>
						&nbsp;（3）Linux&nbsp;查看内存的插槽数,已经使用多少插槽.每条内存多大：<br/>
						<img src="./refs/Linux查看硬件信息命令/4.png"/>
						<br/>
						&nbsp;（4）Linux&nbsp;查看内存的频率：<br/>
						[root@Master&nbsp;~]#&nbsp;dmidecode|grep&nbsp;-A16&nbsp;"Memory&nbsp;Device"|grep&nbsp;'Speed'<br/>
						<img src="./refs/Linux查看硬件信息命令/5.png"/>
						<br/>
						&nbsp;（5）Linux&nbsp;查看内存的详细信息：<br/>
						[root@Master&nbsp;~]#&nbsp;cat&nbsp;/proc/meminfo&nbsp;|head&nbsp;-20<br/>
						MemTotal:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;131897620&nbsp;kB<br/>
						MemFree:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;414124&nbsp;kB<br/>
						Buffers:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1040560&nbsp;kB<br/>
						Cached:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;111083180&nbsp;kB<br/>
						SwapCached:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1320&nbsp;kB<br/>
						Active:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7637912&nbsp;kB<br/>
						Inactive:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;110607108&nbsp;kB<br/>
						Active(anon):&nbsp;&nbsp;&nbsp;&nbsp;4406900&nbsp;kB<br/>
						Inactive(anon):&nbsp;&nbsp;1714900&nbsp;kB<br/>
						Active(file):&nbsp;&nbsp;&nbsp;&nbsp;3231012&nbsp;kB<br/>
						Inactive(file):&nbsp;108892208&nbsp;kB<br/>
						Unevictable:&nbsp;&nbsp;&nbsp;&nbsp;10878976&nbsp;kB<br/>
						Mlocked:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5521652&nbsp;kB<br/>
						SwapTotal:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16777212&nbsp;kB<br/>
						SwapFree:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16737536&nbsp;kB<br/>
						Dirty:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;180&nbsp;kB<br/>
						Writeback:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;kB<br/>
						AnonPages:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16999324&nbsp;kB<br/>
						Mapped:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;149020&nbsp;kB<br/>
						Shmem:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;172&nbsp;kB<br/>
						<br/>
						（6）Linux&nbsp;查看内存的使用情况<br/>
						<br/>
						[root@Master&nbsp;~]#&nbsp;free&nbsp;-m&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;-b,-k,-m,-g&nbsp;show&nbsp;output&nbsp;in&nbsp;bytes,&nbsp;KB,&nbsp;MB,&nbsp;or&nbsp;GB<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;total&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;used&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shared&nbsp;&nbsp;&nbsp;&nbsp;buffers&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cached<br/>
						Mem:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;128806&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;123407&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5398&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1015&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;103474<br/>
						-/+&nbsp;buffers/cache:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18918&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;109888<br/>
						Swap:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16383&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;38&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16345<br/>
						<br/>
						&nbsp;<br/>
						<br/>
						&nbsp;四、查看硬盘信息<br/>
						（1）查看挂接的分区状态<br/>
						[root@Master&nbsp;~]#&nbsp;fdisk&nbsp;-l&nbsp;|grep&nbsp;Disk<br/>
						<img src="./refs/Linux查看硬件信息命令/6.png"/>
						<br/>
						（2）查看硬盘和分区分布<br/>
						<br/>
						[root@Master&nbsp;~]#&nbsp;lsblk<br/>
						NAME&nbsp;&nbsp;&nbsp;MAJ:MIN&nbsp;RM&nbsp;&nbsp;&nbsp;SIZE&nbsp;RO&nbsp;TYPE&nbsp;MOUNTPOINT<br/>
						sda&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8:0&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;279.4G&nbsp;&nbsp;0&nbsp;disk&nbsp;<br/>
						├─sda1&nbsp;&nbsp;&nbsp;8:1&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;50M&nbsp;&nbsp;0&nbsp;part&nbsp;/boot<br/>
						├─sda2&nbsp;&nbsp;&nbsp;8:2&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;100G&nbsp;&nbsp;0&nbsp;part&nbsp;/<br/>
						├─sda3&nbsp;&nbsp;&nbsp;8:3&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;50G&nbsp;&nbsp;0&nbsp;part&nbsp;/home<br/>
						├─sda4&nbsp;&nbsp;&nbsp;8:4&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1K&nbsp;&nbsp;0&nbsp;part&nbsp;<br/>
						├─sda5&nbsp;&nbsp;&nbsp;8:5&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;16G&nbsp;&nbsp;0&nbsp;part&nbsp;[SWAP]<br/>
						├─sda6&nbsp;&nbsp;&nbsp;8:6&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;13.3G&nbsp;&nbsp;0&nbsp;part&nbsp;/tmp<br/>
						└─sda7&nbsp;&nbsp;&nbsp;8:7&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;100G&nbsp;&nbsp;0&nbsp;part&nbsp;/usr<br/>
						sdb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8:16&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;83.7T&nbsp;&nbsp;0&nbsp;disk&nbsp;<br/>
						└─sdb1&nbsp;&nbsp;&nbsp;8:17&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;83.7T&nbsp;&nbsp;0&nbsp;part&nbsp;/PureDisk<br/>
						<br/>
						<br/>
						&nbsp;（3）查看硬盘和分区的详细信息<br/>
						[root@Master&nbsp;~]#&nbsp;fdisk&nbsp;-l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
						<br/>
						Disk&nbsp;/dev/sda:&nbsp;300.0&nbsp;GB,&nbsp;299966445568&nbsp;bytes<br/>
						255&nbsp;heads,&nbsp;63&nbsp;sectors/track,&nbsp;36468&nbsp;cylinders<br/>
						Units&nbsp;=&nbsp;cylinders&nbsp;of&nbsp;16065&nbsp;*&nbsp;512&nbsp;=&nbsp;8225280&nbsp;bytes<br/>
						Sector&nbsp;size&nbsp;(logical/physical):&nbsp;512&nbsp;bytes&nbsp;/&nbsp;512&nbsp;bytes<br/>
						I/O&nbsp;size&nbsp;(minimum/optimal):&nbsp;262144&nbsp;bytes&nbsp;/&nbsp;262144&nbsp;bytes<br/>
						Disk&nbsp;identifier:&nbsp;0x000384d9<br/>
						<br/>
						&nbsp;&nbsp;&nbsp;Device&nbsp;Boot&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Start&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;End&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Blocks&nbsp;&nbsp;&nbsp;Id&nbsp;&nbsp;System<br/>
						/dev/sda1&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;51200&nbsp;&nbsp;&nbsp;83&nbsp;&nbsp;Linux<br/>
						Partition&nbsp;1&nbsp;does&nbsp;not&nbsp;end&nbsp;on&nbsp;cylinder&nbsp;boundary.<br/>
						/dev/sda2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;13061&nbsp;&nbsp;&nbsp;104857600&nbsp;&nbsp;&nbsp;83&nbsp;&nbsp;Linux<br/>
						/dev/sda3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;13061&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;19588&nbsp;&nbsp;&nbsp;&nbsp;52428800&nbsp;&nbsp;&nbsp;83&nbsp;&nbsp;Linux<br/>
						/dev/sda4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;19588&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;36469&nbsp;&nbsp;&nbsp;135597056&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;Extended<br/>
						/dev/sda5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;19588&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;21677&nbsp;&nbsp;&nbsp;&nbsp;16777216&nbsp;&nbsp;&nbsp;82&nbsp;&nbsp;Linux&nbsp;swap&nbsp;/&nbsp;Solaris<br/>
						/dev/sda6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;21677&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;23415&nbsp;&nbsp;&nbsp;&nbsp;13962240&nbsp;&nbsp;&nbsp;83&nbsp;&nbsp;Linux<br/>
						/dev/sda7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;23416&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;36469&nbsp;&nbsp;&nbsp;104854528&nbsp;&nbsp;&nbsp;83&nbsp;&nbsp;Linux<br/>
						<br/>
						WARNING:&nbsp;GPT&nbsp;(GUID&nbsp;Partition&nbsp;Table)&nbsp;detected&nbsp;on&nbsp;'/dev/sdb'!&nbsp;The&nbsp;util&nbsp;fdisk&nbsp;doesn't&nbsp;support&nbsp;GPT.&nbsp;Use&nbsp;GNU&nbsp;Parted.<br/>
						<br/>
						<br/>
						Disk&nbsp;/dev/sdb:&nbsp;92017.3&nbsp;GB,&nbsp;92017310654464&nbsp;bytes<br/>
						255&nbsp;heads,&nbsp;63&nbsp;sectors/track,&nbsp;11187134&nbsp;cylinders<br/>
						Units&nbsp;=&nbsp;cylinders&nbsp;of&nbsp;16065&nbsp;*&nbsp;512&nbsp;=&nbsp;8225280&nbsp;bytes<br/>
						Sector&nbsp;size&nbsp;(logical/physical):&nbsp;512&nbsp;bytes&nbsp;/&nbsp;512&nbsp;bytes<br/>
						I/O&nbsp;size&nbsp;(minimum/optimal):&nbsp;262144&nbsp;bytes&nbsp;/&nbsp;6029312&nbsp;bytes<br/>
						Disk&nbsp;identifier:&nbsp;0x00000000<br/>
						<br/>
						&nbsp;&nbsp;&nbsp;Device&nbsp;Boot&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Start&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;End&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Blocks&nbsp;&nbsp;&nbsp;Id&nbsp;&nbsp;System<br/>
						/dev/sdb1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;267350&nbsp;&nbsp;2147483647+&nbsp;&nbsp;ee&nbsp;&nbsp;GPT<br/>
						Partition&nbsp;1&nbsp;does&nbsp;not&nbsp;start&nbsp;on&nbsp;physical&nbsp;sector&nbsp;boundary.<br/>
						<br/>
						&nbsp;（4）查看挂接的分区状态<br/>
						[root@Master&nbsp;~]#&nbsp;mount&nbsp;|&nbsp;column&nbsp;-t<br/>
						/dev/sda2&nbsp;&nbsp;on&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;&nbsp;ext4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rw)<br/>
						proc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;on&nbsp;&nbsp;/proc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;&nbsp;proc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rw)<br/>
						sysfs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;on&nbsp;&nbsp;/sys&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;&nbsp;sysfs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rw)<br/>
						devpts&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;on&nbsp;&nbsp;/dev/pts&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;&nbsp;devpts&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rw,gid=5,mode=620)<br/>
						tmpfs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;on&nbsp;&nbsp;/dev/shm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;&nbsp;tmpfs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rw)<br/>
						/dev/sda1&nbsp;&nbsp;on&nbsp;&nbsp;/boot&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;&nbsp;ext4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rw)<br/>
						/dev/sda3&nbsp;&nbsp;on&nbsp;&nbsp;/home&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;&nbsp;ext4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rw)<br/>
						/dev/sda6&nbsp;&nbsp;on&nbsp;&nbsp;/tmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;&nbsp;ext4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rw)<br/>
						/dev/sda7&nbsp;&nbsp;on&nbsp;&nbsp;/usr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;&nbsp;ext4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rw)<br/>
						/dev/sdb1&nbsp;&nbsp;on&nbsp;&nbsp;/PureDisk&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;&nbsp;ext4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rw)<br/>
						none&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;on&nbsp;&nbsp;/proc/sys/fs/binfmt_misc&nbsp;&nbsp;type&nbsp;&nbsp;binfmt_misc&nbsp;&nbsp;(rw<br/>
						<br/>
						&nbsp;（5）查看挂接的分区状态<br/>
						<br/>
						[root@Master&nbsp;~]#&nbsp;swapon&nbsp;-s&nbsp;&nbsp;&nbsp;<br/>
						Filename&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Size&nbsp;&nbsp;&nbsp;&nbsp;Used&nbsp;&nbsp;&nbsp;&nbsp;Priority<br/>
						/dev/sda5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;partition&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16777212&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;39676&nbsp;&nbsp;&nbsp;-1<br/>
						<br/>
						&nbsp;（6）查看硬盘使用情况<br/>
						[root@Master&nbsp;~]#&nbsp;df&nbsp;-hT<br/>
						Filesystem&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Type&nbsp;&nbsp;&nbsp;Size&nbsp;&nbsp;Used&nbsp;Avail&nbsp;Use%&nbsp;Mounted&nbsp;on<br/>
						/dev/sda2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ext4&nbsp;&nbsp;&nbsp;&nbsp;99G&nbsp;&nbsp;561M&nbsp;&nbsp;&nbsp;93G&nbsp;&nbsp;&nbsp;1%&nbsp;/<br/>
						tmpfs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmpfs&nbsp;&nbsp;&nbsp;63G&nbsp;&nbsp;&nbsp;76K&nbsp;&nbsp;&nbsp;63G&nbsp;&nbsp;&nbsp;1%&nbsp;/dev/shm<br/>
						/dev/sda1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ext4&nbsp;&nbsp;&nbsp;&nbsp;45M&nbsp;&nbsp;&nbsp;38M&nbsp;&nbsp;4.9M&nbsp;&nbsp;89%&nbsp;/boot<br/>
						/dev/sda3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ext4&nbsp;&nbsp;&nbsp;&nbsp;50G&nbsp;&nbsp;&nbsp;52M&nbsp;&nbsp;&nbsp;47G&nbsp;&nbsp;&nbsp;1%&nbsp;/home<br/>
						/dev/sda6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ext4&nbsp;&nbsp;&nbsp;&nbsp;13G&nbsp;&nbsp;&nbsp;34M&nbsp;&nbsp;&nbsp;13G&nbsp;&nbsp;&nbsp;1%&nbsp;/tmp<br/>
						/dev/sda7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ext4&nbsp;&nbsp;&nbsp;&nbsp;99G&nbsp;&nbsp;&nbsp;21G&nbsp;&nbsp;&nbsp;73G&nbsp;&nbsp;23%&nbsp;/usr<br/>
						/dev/sdb1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ext4&nbsp;&nbsp;&nbsp;&nbsp;84T&nbsp;&nbsp;&nbsp;41T&nbsp;&nbsp;&nbsp;40T&nbsp;&nbsp;51%&nbsp;/PureDisk<br/>
						<br/>
						<br/>
						&nbsp;（7）&nbsp;硬盘检测命令smartctl<br/>
						[root@Master&nbsp;~]#&nbsp;smartctl&nbsp;-a&nbsp;/dev/sda<br/>
						smartctl&nbsp;5.43&nbsp;2012-06-30&nbsp;r3573&nbsp;[x86_64-linux-2.6.32-642.el6.x86_64]&nbsp;(local&nbsp;build)<br/>
						Copyright&nbsp;(C)&nbsp;2002-12&nbsp;by&nbsp;Bruce&nbsp;Allen,&nbsp;http://smartmontools.sourceforge.net<br/>
						<br/>
						Vendor:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
						Product:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOGICAL&nbsp;VOLUME&nbsp;&nbsp;<br/>
						Revision:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.56<br/>
						User&nbsp;Capacity:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;299,966,445,568&nbsp;bytes&nbsp;[299&nbsp;GB]<br/>
						Logical&nbsp;block&nbsp;size:&nbsp;&nbsp;&nbsp;512&nbsp;bytes<br/>
						Logical&nbsp;Unit&nbsp;id:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x600508b1001cc8a1b9ec4dacc5ab35dc<br/>
						Serial&nbsp;number:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDNNK0BRH9U0AG&nbsp;&nbsp;<br/>
						Device&nbsp;type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;disk<br/>
						Local&nbsp;Time&nbsp;is:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mon&nbsp;Feb&nbsp;&nbsp;5&nbsp;13:13:33&nbsp;2018&nbsp;CST<br/>
						Device&nbsp;supports&nbsp;SMART&nbsp;and&nbsp;is&nbsp;Enabled<br/>
						Temperature&nbsp;Warning&nbsp;Disabled&nbsp;or&nbsp;Not&nbsp;Supported<br/>
						SMART&nbsp;Health&nbsp;Status:&nbsp;OK<br/>
						<br/>
						Error&nbsp;Counter&nbsp;logging&nbsp;not&nbsp;supported<br/>
						Device&nbsp;does&nbsp;not&nbsp;support&nbsp;Self&nbsp;Test&nbsp;logging<br/>
						<br/>
						五、查看网卡信息<br/>
						<br/>
						（1)查看网卡硬件信息<br/>
						[root@Master&nbsp;~]#&nbsp;&nbsp;lspci&nbsp;|&nbsp;grep&nbsp;-i&nbsp;'eth'<br/>
						<img src="./refs/Linux查看硬件信息命令/7.png"/>
						<br/>
						&nbsp;&nbsp;&nbsp;(2)查看系统的所有网络接口<br/>
						<br/>
						[root@Master&nbsp;~]#&nbsp;ifconfig&nbsp;-a<br/>
						[root@Master&nbsp;~]#&nbsp;ip&nbsp;link&nbsp;show<br/>
						<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;(3)查看某个网络接口的详细信息，例如eth0的详细参数和指标<br/>
						[root@Master&nbsp;~]#&nbsp;ethtool&nbsp;eth0<br/>
						Settings&nbsp;for&nbsp;eth0:<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Supported&nbsp;ports:&nbsp;[&nbsp;FIBRE&nbsp;]<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Supported&nbsp;link&nbsp;modes:&nbsp;&nbsp;&nbsp;10000baseT/Full&nbsp;<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Supported&nbsp;pause&nbsp;frame&nbsp;use:&nbsp;No<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Supports&nbsp;auto-negotiation:&nbsp;No<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Advertised&nbsp;link&nbsp;modes:&nbsp;&nbsp;10000baseT/Full&nbsp;<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Advertised&nbsp;pause&nbsp;frame&nbsp;use:&nbsp;No<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Advertised&nbsp;auto-negotiation:&nbsp;No<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Speed:&nbsp;10000Mb/s<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Duplex:&nbsp;Full<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Port:&nbsp;FIBRE<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PHYAD:&nbsp;0<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Transceiver:&nbsp;external<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Auto-negotiation:&nbsp;off<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Supports&nbsp;Wake-on:&nbsp;d<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wake-on:&nbsp;d<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Current&nbsp;message&nbsp;level:&nbsp;0x00000007&nbsp;(7)<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;drv&nbsp;probe&nbsp;link<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Link&nbsp;detected:&nbsp;yes<br/>
						<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;(4)查看所有网卡的链路状态<br/>
						[root@Master&nbsp;~]#&nbsp;for&nbsp;i&nbsp;in&nbsp;`seq&nbsp;0&nbsp;9`;do&nbsp;ethtool&nbsp;eth${i}&nbsp;|&nbsp;egrep&nbsp;'eth|Link';done<br/>
						Settings&nbsp;for&nbsp;eth0:<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Link&nbsp;detected:&nbsp;yes&nbsp;&nbsp;&nbsp;<br/>
						Settings&nbsp;for&nbsp;eth1:<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Link&nbsp;detected:&nbsp;yes<br/>
						Settings&nbsp;for&nbsp;eth2:<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Link&nbsp;detected:&nbsp;no<br/>
						Settings&nbsp;for&nbsp;eth3:<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Link&nbsp;detected:&nbsp;no<br/>
						Settings&nbsp;for&nbsp;eth4:<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Link&nbsp;detected:&nbsp;no<br/>
						Settings&nbsp;for&nbsp;eth5:<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Link&nbsp;detected:&nbsp;no<br/>
						Settings&nbsp;for&nbsp;eth6:<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Link&nbsp;detected:&nbsp;no<br/>
						Settings&nbsp;for&nbsp;eth7:<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Link&nbsp;detected:&nbsp;no<br/>
						Settings&nbsp;for&nbsp;eth8:<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Link&nbsp;detected:&nbsp;no<br/>
						Settings&nbsp;for&nbsp;eth9:<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Link&nbsp;detected:&nbsp;no<br/>
						<br/>
						&nbsp;六、列出所有PCI设备信息<br/>
						[root@Master&nbsp;~]#&nbsp;lspci&nbsp;-tv&nbsp;|&nbsp;more<br/>
						-+-[0000:ff]-+-08.0&nbsp;&nbsp;Intel&nbsp;Corporation&nbsp;Xeon&nbsp;E7&nbsp;v3/Xeon&nbsp;E5&nbsp;v3/Core&nbsp;i7&nbsp;QPI&nbsp;Link&nbsp;0<br/>
						&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-08.3&nbsp;&nbsp;Intel&nbsp;Corporation&nbsp;Xeon&nbsp;E7&nbsp;v3/Xeon&nbsp;E5&nbsp;v3/Core&nbsp;i7&nbsp;QPI&nbsp;Link&nbsp;0<br/>
						&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-09.0&nbsp;&nbsp;Intel&nbsp;Corporation&nbsp;Xeon&nbsp;E7&nbsp;v3/Xeon&nbsp;E5&nbsp;v3/Core&nbsp;i7&nbsp;QPI&nbsp;Link&nbsp;1<br/>
						&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-09.3&nbsp;&nbsp;Intel&nbsp;Corporation&nbsp;Xeon&nbsp;E7&nbsp;v3/Xeon&nbsp;E5&nbsp;v3/Core&nbsp;i7&nbsp;QPI&nbsp;Link&nbsp;1<br/>
						&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-0b.0&nbsp;&nbsp;Intel&nbsp;Corporation&nbsp;Xeon&nbsp;E7&nbsp;v3/Xeon&nbsp;E5&nbsp;v3/Core&nbsp;i7&nbsp;R3&nbsp;QPI&nbsp;Link&nbsp;0&nbsp;&amp;&nbsp;1&nbsp;Monitoring<br/>
						&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-0b.1&nbsp;&nbsp;Intel&nbsp;Corporation&nbsp;Xeon&nbsp;E7&nbsp;v3/Xeon&nbsp;E5&nbsp;v3/Core&nbsp;i7&nbsp;R3&nbsp;QPI&nbsp;Link&nbsp;0&nbsp;&amp;&nbsp;1&nbsp;Monitoring<br/>
						&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-0b.2&nbsp;&nbsp;Intel&nbsp;Corporation&nbsp;Xeon&nbsp;E7&nbsp;v3/Xeon&nbsp;E5&nbsp;v3/Core&nbsp;i7&nbsp;R3&nbsp;QPI&nbsp;Link&nbsp;0&nbsp;&amp;&nbsp;1&nbsp;Monitoring<br/>
						&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-0c.0&nbsp;&nbsp;Intel&nbsp;Corporation&nbsp;Xeon&nbsp;E7&nbsp;v3/Xeon&nbsp;E5&nbsp;v3/Core&nbsp;i7&nbsp;Unicast&nbsp;Registers<br/>
						&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-0c.1&nbsp;&nbsp;Intel&nbsp;Corporation&nbsp;Xeon&nbsp;E7&nbsp;v3/Xeon&nbsp;E5&nbsp;v3/Core&nbsp;i7&nbsp;Unicast&nbsp;Registers<br/>
						&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-0c.2&nbsp;&nbsp;Intel&nbsp;Corporation&nbsp;Xeon&nbsp;E7&nbsp;v3/Xeon&nbsp;E5&nbsp;v3/Core&nbsp;i7&nbsp;Unicast&nbsp;Registers<br/>
						&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-0c.3&nbsp;&nbsp;Intel&nbsp;Corporation&nbsp;Xeon&nbsp;E7&nbsp;v3/Xeon&nbsp;E5&nbsp;v3/Core&nbsp;i7&nbsp;Unicast&nbsp;Registers<br/>
						&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-0c.4&nbsp;&nbsp;Intel&nbsp;Corporation&nbsp;Xeon&nbsp;E7&nbsp;v3/Xeon&nbsp;E5&nbsp;v3/Core&nbsp;i7&nbsp;Unicast&nbsp;Registers<br/>
						&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-0c.5&nbsp;&nbsp;Intel&nbsp;Corporation&nbsp;Xeon&nbsp;E7&nbsp;v3/Xeon&nbsp;E5&nbsp;v3/Core&nbsp;i7&nbsp;Unicast&nbsp;Registers<br/>
						&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-0c.6&nbsp;&nbsp;Intel&nbsp;Corporation&nbsp;Xeon&nbsp;E7&nbsp;v3/Xeon&nbsp;E5&nbsp;v3/Core&nbsp;i7&nbsp;Unicast&nbsp;Registers<br/>
						&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-0c.7&nbsp;&nbsp;Intel&nbsp;Corporation&nbsp;Xeon&nbsp;E7&nbsp;v3/Xeon&nbsp;E5&nbsp;v3/Core&nbsp;i7&nbsp;Unicast&nbsp;Registers<br/>
						&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-0d.0&nbsp;&nbsp;Intel&nbsp;Corporation&nbsp;Xeon&nbsp;E7&nbsp;v3/Xeon&nbsp;E5&nbsp;v3/Core&nbsp;i7&nbsp;Unicast&nbsp;Registers<br/>
						&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-0d.1&nbsp;&nbsp;Intel&nbsp;Corporation&nbsp;Xeon&nbsp;E7&nbsp;v3/Xeon&nbsp;E5&nbsp;v3/Core&nbsp;i7&nbsp;Unicast&nbsp;Registers<br/>
						&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-0f.0&nbsp;&nbsp;Intel&nbsp;Corporation&nbsp;Xeon&nbsp;E7&nbsp;v3/Xeon&nbsp;E5&nbsp;v3/Core&nbsp;i7&nbsp;Buffered&nbsp;Ring&nbsp;Agent<br/>
						&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-0f.1&nbsp;&nbsp;Intel&nbsp;Corporation&nbsp;Xeon&nbsp;E7&nbsp;v3/Xeon&nbsp;E5&nbsp;v3/Core&nbsp;i7&nbsp;Buffered&nbsp;Ring&nbsp;Agent<br/>
						&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-0f.2&nbsp;&nbsp;Intel&nbsp;Corporation&nbsp;Xeon&nbsp;E7&nbsp;v3/Xeon&nbsp;E5&nbsp;v3/Core&nbsp;i7&nbsp;Buffered&nbsp;Ring&nbsp;Agent<br/>
						&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-0f.3&nbsp;&nbsp;Intel&nbsp;Corporation&nbsp;Xeon&nbsp;E7&nbsp;v3/Xeon&nbsp;E5&nbsp;v3/Core&nbsp;i7&nbsp;Buffered&nbsp;Ring&nbsp;Agent<br/>
					</div>
				</div>
			</section>
			<section>
				<h3>LINUX查看硬件配置命令</h3>
				<div>
					<div class="class___code class___copy_other_people_content">
						一、如何查看服务器的CPU<br/>
						<br/>
						今天安装了9台Linux服务器，型号完全不一样（有DELL、HP和IBM服务器），又懒得去对清单，如何在Linux下cpu的个数和核数呢？另外，nginx的cpu工作模式也需要确切的知道linux服务器到底有多少个逻辑cpu，不过现在服务器那是相当的彪悍，直接上worker_processes&nbsp;8吧。<br/>
						<br/>
						判断依据：<br/>
						<br/>
						1.具有相同core&nbsp;id的cpu是同一个core的超线程。（Physical&nbsp;id&nbsp;and&nbsp;core&nbsp;id&nbsp;are&nbsp;not&nbsp;necessarily&nbsp;consecutive&nbsp;but&nbsp;they&nbsp;are&nbsp;unique.&nbsp;Any&nbsp;cpu&nbsp;with&nbsp;the&nbsp;same&nbsp;core&nbsp;id&nbsp;are&nbsp;hyperthreads&nbsp;in&nbsp;the&nbsp;same&nbsp;core.）<br/>
						<br/>
						2.具有相同physical&nbsp;id的cpu是同一颗cpu封装的线程或者cores。（Any&nbsp;cpu&nbsp;with&nbsp;the&nbsp;same&nbsp;physical&nbsp;id&nbsp;are&nbsp;threads&nbsp;or&nbsp;cores&nbsp;in&nbsp;the&nbsp;same&nbsp;physical&nbsp;socket.）<br/>
						<br/>
						以自己的惠普DL380G6为例说明：<br/>
						<br/>
						①物理cpu个数:<br/>
						[root@localhost&nbsp;~]#&nbsp;cat&nbsp;/proc/cpuinfo&nbsp;|&nbsp;grep&nbsp;"physical&nbsp;id"&nbsp;|&nbsp;sort&nbsp;|&nbsp;uniq&nbsp;|&nbsp;wc&nbsp;-l<br/>
						②每个物理cpu中core的个数(即核数)<br/>
						[root@localhost&nbsp;~]#&nbsp;cat&nbsp;/proc/cpuinfo&nbsp;|&nbsp;grep&nbsp;"cpu&nbsp;cores"&nbsp;|&nbsp;uniq<br/>
						cpu&nbsp;cores&nbsp;:&nbsp;4<br/>
						这样可以推算出自己服务器的逻辑CPU为物理个数*核数，如果你的服务器是server2003，你可以在你的资源管理器里以图形化方式看到你的逻辑CPU个数。<br/>
						<br/>
						二、查看服务器的内存情况<br/>
						<br/>
						有时候，你运行了许多大的进程，比如你开启了300个fast-cgi。这时候你感觉系统很慢，便需要查看服务器的内存情况：<br/>
						[root@server&nbsp;~]#&nbsp;free&nbsp;-m<br/>
						total&nbsp;used&nbsp;free&nbsp;shared&nbsp;buffers&nbsp;cached<br/>
						Mem:&nbsp;249&nbsp;163&nbsp;86&nbsp;0&nbsp;10&nbsp;94<br/>
						-/+&nbsp;buffers/cache:&nbsp;58&nbsp;191<br/>
						Swap:&nbsp;511&nbsp;0&nbsp;511<br/>
						参数解释：<br/>
						total&nbsp;内存总数<br/>
						used&nbsp;已经使用的内存数<br/>
						free&nbsp;空闲的内存数<br/>
						shared&nbsp;多个进程共享的内存总额<br/>
						buffers&nbsp;Buffer&nbsp;Cache和cached&nbsp;Page&nbsp;Cache&nbsp;磁盘缓存的大小<br/>
						-buffers/cache&nbsp;(已用)的内存数:used&nbsp;-&nbsp;buffers&nbsp;-&nbsp;cached<br/>
						+buffers/cache(可用)的内存数:free&nbsp;+&nbsp;buffers&nbsp;+&nbsp;cached<br/>
						可用的memory=free&nbsp;memory+buffers+cached<br/>
						上面的数值是一台我公司内网供PHP开发人员使用的DELL&nbsp;PE2850，内存为2G的服务器，其可使用内存为=217+515+826。记住，Linux的内存使用管理机制是有多少就用多少(特别是在频繁存取文件后)，即Linux内存不是拿来看的，是拿来用的。<br/>
						<br/>
						&nbsp;<br/>
						<br/>
						编辑推荐：Linux系统内存监控全面讲解：free命令<br/>
						<br/>
						三、服务器磁盘使用情况<br/>
						<br/>
						有时感觉硬盘反映很慢，或需要查看日志所在分区时，下列命令可以查看磁盘的使用情况，很有用：<br/>
						<br/>
						①查看硬盘分区情况<br/>
						fdisk&nbsp;–l<br/>
						②查看当前硬盘使用情况<br/>
						df&nbsp;–h<br/>
						③查看硬盘性能<br/>
						#&nbsp;iostat&nbsp;-x&nbsp;1&nbsp;10<br/>
						Linux&nbsp;2.6.18-92.el5xen&nbsp;03/01/2010<br/>
						avg-cpu:&nbsp;&nbsp;&nbsp;%user&nbsp;%nice&nbsp;%system&nbsp;%iowait&nbsp;&nbsp;&nbsp;%steal&nbsp;%idle<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.10&nbsp;0.00&nbsp;4.82&nbsp;39.54&nbsp;0.07&nbsp;54.46<br/>
						Device:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rrqm/s&nbsp;wrqm/s&nbsp;r/s&nbsp;w/s&nbsp;rsec/s&nbsp;wsec/s&nbsp;avgrq-sz&nbsp;avgqu-sz&nbsp;await&nbsp;&nbsp;&nbsp;svctm&nbsp;&nbsp;&nbsp;%util<br/>
						sda&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.50&nbsp;&nbsp;&nbsp;0.40&nbsp;&nbsp;&nbsp;2.50&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.60&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;48.00&nbsp;&nbsp;&nbsp;18.48&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.00&nbsp;0.97&nbsp;0.97&nbsp;0.28<br/>
						sdb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.00&nbsp;&nbsp;&nbsp;0.00&nbsp;&nbsp;&nbsp;0.00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.00&nbsp;0.00&nbsp;0.00&nbsp;0.00<br/>
						sdc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.00&nbsp;&nbsp;&nbsp;0.00&nbsp;&nbsp;&nbsp;0.00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.00&nbsp;0.00&nbsp;0.00&nbsp;0.00<br/>
						sdd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.00&nbsp;&nbsp;&nbsp;0.00&nbsp;&nbsp;&nbsp;0.00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.00&nbsp;0.00&nbsp;0.00&nbsp;0.00<br/>
						sde&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.10&nbsp;&nbsp;&nbsp;0.30&nbsp;&nbsp;&nbsp;0.20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.40&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.40&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9.60&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.00&nbsp;1.60&nbsp;1.60&nbsp;0.08<br/>
						sdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.40&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.50&nbsp;102.00&nbsp;&nbsp;&nbsp;0.20&nbsp;12095.20&nbsp;&nbsp;&nbsp;&nbsp;5.60&nbsp;&nbsp;&nbsp;118.40&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.70&nbsp;6.81&nbsp;2.09&nbsp;&nbsp;21.36<br/>
						sdg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;232.40&nbsp;&nbsp;&nbsp;&nbsp;1.90&nbsp;379.70&nbsp;&nbsp;&nbsp;0.50&nbsp;76451.20&nbsp;&nbsp;&nbsp;19.20&nbsp;&nbsp;&nbsp;201.13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.94&nbsp;13.78&nbsp;2.45&nbsp;93.16<br/>
						像我们公司，开发人员占多数。有时为了节约成本，会同时采购一些性价比比较高的二手服务器；这时一般将服务器的硬件的工作模式设置为RAID1，同时对几种型号的服务器作相同文件的写操作，然后各自执行iostat&nbsp;–d，作对比性测试。这样服务器的硬盘性能孰优孰劣，一下子就能对比出来。<br/>
						<br/>
						&nbsp;<br/>
						<br/>
						图解：<br/>
						<br/>
						Tps&nbsp;该设备每秒I/O传输的次数(每秒的I/O请求)<br/>
						<br/>
						Blk_read/s&nbsp;表求从该设备每秒读的数据块数量<br/>
						<br/>
						Blk_wrth/s&nbsp;表示从该设备每秒写的数据块数量<br/>
						<br/>
						编辑推荐：Linux系统监控之磁盘I/O篇<br/>
						<br/>
						&nbsp;<br/>
						<br/>
						&nbsp;<br/>
						<br/>
						四、查看系统内核<br/>
						<br/>
						查看系统内核主要为了掌握其版本号，为安装LVS等软件做准备。<br/>
						uname&nbsp;–a<br/>
						有关查看内核信息的更多指令，可参考Linux查看版本信息及CPU内核、型号等一文。有关Linux的内核优化，则可参考Linux&nbsp;2.6.31内核优化指南一文。<br/>
						<br/>
						五、查看服务器使用的Linux发行版的名称、版本号及描述信息等<br/>
						lsb_release&nbsp;-a<br/>
						这是我的某台用于SVN实验的vmware机器情况：<br/>
						<br/>
						&nbsp;<br/>
						<br/>
						六、查看服务器的平均负载<br/>
						<br/>
						感觉到系统压力较大时用可top或uptime查看下服务器的平均负载。uptime的另一个用法是查看你的Linux服务器已经稳定运行多少天没有重启了，我这边的机器最高记录是360多天。<br/>
						<br/>
						七、查看系统整体性能情况<br/>
						<br/>
						如果感觉系统比较繁忙，可以用vmstat查看系统整体性能情况。vmstat不仅仅适应于linux系统，它一样适用于FreeBSD等unix系统。<br/>
						vmstat&nbsp;1&nbsp;2<br/>
						如果&nbsp;r经常大于&nbsp;4&nbsp;，且id经常少于40，表示cpu的负荷很重。<br/>
						<br/>
						如果pi，po&nbsp;长期不等于0，表示内存不足。<br/>
						<br/>
						如果disk&nbsp;经常不等于0，&nbsp;且在&nbsp;b中的队列&nbsp;大于3，&nbsp;表示&nbsp;io性能不好。<br/>
						<br/>
						编辑推荐：Linux系统监控工具之vmstat详解<br/>
						<br/>
						八、查看系统已载入的相关模块<br/>
						<br/>
						Linux操作系统的核心具有模块化的特性，应此在编译核心时，务须把全部的功能都放入核心。你可以将这些功能编译成一个个单独的模块，待需要时再分别载入。比如说在安装LVS+Keepalived，下列用法被经常用到：<br/>
						#检查内核模块，看一下ip_vs是否被加载<br/>
						lsmod&nbsp;|grep&nbsp;ip_vs<br/>
						ip_vs&nbsp;77313&nbsp;0&nbsp;<br/>
						&nbsp;如果要查看当前系统的已加载模块，直接lsmod。<br/>
						<br/>
						九、Linux下查找PCI设置<br/>
						<br/>
						有时需要在Linux下查找PCI设置，可用lspci命令，它可以列出机器中的PCI&nbsp;设备，比如声卡、显卡、Modem、网卡等，主板集成设备也能列出来。lspci&nbsp;读取的是hwdata&nbsp;数据库。有的小伙可能和我一样，最关心的还是网卡型号：<br/>
						[root@mail&nbsp;~]#&nbsp;lspci&nbsp;|&nbsp;grep&nbsp;Ethernet<br/>
						03:00.0&nbsp;Ethernet&nbsp;controller:&nbsp;Broadcom&nbsp;Corporation&nbsp;NetXtreme&nbsp;II&nbsp;BCM5708&nbsp;Gigabit&nbsp;Ethernet&nbsp;(rev&nbsp;12)<br/>
						07:00.0&nbsp;Ethernet&nbsp;controller:&nbsp;Broadcom&nbsp;Corporation&nbsp;NetXtreme&nbsp;II&nbsp;BCM5708&nbsp;Gigabit&nbsp;Ethernet&nbsp;(rev&nbsp;12)<br/>
						推荐阅读：七大实用命令行工具&nbsp;玩转Linux网络配置。至于网络流量的监控，建议用centos自带的工具iptraf，其用法可参考这篇文章。<br/>
						<br/>
						掌握上面这九条，你对你的Linux服务器的硬件信息基本就可以随时掌控了。<br/>
						<br/>
						&nbsp;<br/>
						<br/>
						系统<br/>
						#&nbsp;uname&nbsp;-a&nbsp;#&nbsp;查看内核/操作系统/CPU信息<br/>
						#&nbsp;head&nbsp;-n&nbsp;1&nbsp;/etc/issue&nbsp;#&nbsp;查看操作系统版本<br/>
						#&nbsp;cat&nbsp;/proc/cpuinfo&nbsp;#&nbsp;查看CPU信息<br/>
						#&nbsp;hostname&nbsp;#&nbsp;查看计算机名<br/>
						#&nbsp;lspci&nbsp;-tv&nbsp;#&nbsp;列出所有PCI设备<br/>
						#&nbsp;lsusb&nbsp;-tv&nbsp;#&nbsp;列出所有USB设备<br/>
						#&nbsp;lsmod&nbsp;#&nbsp;列出加载的内核模块<br/>
						#&nbsp;env&nbsp;#&nbsp;查看环境变量<br/>
						资源<br/>
						#&nbsp;free&nbsp;-m&nbsp;#&nbsp;查看内存使用量和交换区使用量<br/>
						#&nbsp;df&nbsp;-h&nbsp;#&nbsp;查看各分区使用情况<br/>
						#&nbsp;du&nbsp;-sh&nbsp;&lt;目录名&gt;&nbsp;#&nbsp;查看指定目录的大小<br/>
						#&nbsp;grep&nbsp;MemTotal&nbsp;/proc/meminfo&nbsp;#&nbsp;查看内存总量<br/>
						#&nbsp;grep&nbsp;MemFree&nbsp;/proc/meminfo&nbsp;#&nbsp;查看空闲内存量<br/>
						#&nbsp;uptime&nbsp;#&nbsp;查看系统运行时间、用户数、负载<br/>
						#&nbsp;cat&nbsp;/proc/loadavg&nbsp;#&nbsp;查看系统负载<br/>
						磁盘和分区<br/>
						#&nbsp;mount&nbsp;|&nbsp;column&nbsp;-t&nbsp;#&nbsp;查看挂接的分区状态<br/>
						#&nbsp;fdisk&nbsp;-l&nbsp;#&nbsp;查看所有分区&nbsp;&nbsp;www.2cto.com&nbsp;<br/>
						#&nbsp;swapon&nbsp;-s&nbsp;#&nbsp;查看所有交换分区<br/>
						#&nbsp;hdparm&nbsp;-i&nbsp;/dev/hda&nbsp;#&nbsp;查看磁盘参数(仅适用于IDE设备)<br/>
						#&nbsp;dmesg&nbsp;|&nbsp;grep&nbsp;IDE&nbsp;#&nbsp;查看启动时IDE设备检测状况<br/>
						网络<br/>
						#&nbsp;ifconfig&nbsp;#&nbsp;查看所有网络接口的属性<br/>
						#&nbsp;iptables&nbsp;-L&nbsp;#&nbsp;查看防火墙设置<br/>
						#&nbsp;route&nbsp;-n&nbsp;#&nbsp;查看路由表<br/>
						#&nbsp;netstat&nbsp;-lntp&nbsp;#&nbsp;查看所有监听端口<br/>
						#&nbsp;netstat&nbsp;-antp&nbsp;#&nbsp;查看所有已经建立的连接<br/>
						#&nbsp;netstat&nbsp;-s&nbsp;#&nbsp;查看网络统计信息<br/>
						进程<br/>
						#&nbsp;ps&nbsp;-ef&nbsp;#&nbsp;查看所有进程<br/>
						#&nbsp;top&nbsp;#&nbsp;实时显示进程状态<br/>
						用户<br/>
						#&nbsp;w&nbsp;#&nbsp;查看活动用户<br/>
						#&nbsp;id&nbsp;&lt;用户名&gt;&nbsp;#&nbsp;查看指定用户信息<br/>
						#&nbsp;last&nbsp;#&nbsp;查看用户登录日志<br/>
						#&nbsp;cut&nbsp;-d:&nbsp;-f1&nbsp;/etc/passwd&nbsp;#&nbsp;查看系统所有用户<br/>
						#&nbsp;cut&nbsp;-d:&nbsp;-f1&nbsp;/etc/group&nbsp;#&nbsp;查看系统所有组<br/>
						#&nbsp;crontab&nbsp;-l&nbsp;#&nbsp;查看当前用户的计划任务<br/>
						服务<br/>
						#&nbsp;chkconfig&nbsp;--list&nbsp;#&nbsp;列出所有系统服务<br/>
						#&nbsp;chkconfig&nbsp;--list&nbsp;|&nbsp;grep&nbsp;on&nbsp;#&nbsp;列出所有启动的系统服务<br/>
						程序<br/>
						#&nbsp;rpm&nbsp;-qa&nbsp;#&nbsp;查看所有安装的软件包<br/>
						常用命令整理如下：<br/>
						查看主板的序列号:&nbsp;dmidecode&nbsp;|&nbsp;grep&nbsp;-i&nbsp;’serial&nbsp;number’<br/>
						用硬件检测程序kuduz探测新硬件：service&nbsp;kudzu&nbsp;start&nbsp;(&nbsp;or&nbsp;restart)<br/>
						查看CPU信息：cat&nbsp;/proc/cpuinfo&nbsp;[dmesg&nbsp;|&nbsp;grep&nbsp;-i&nbsp;'cpu'][dmidecode&nbsp;-t&nbsp;processor]<br/>
						查看内存信息：cat&nbsp;/proc/meminfo&nbsp;[free&nbsp;-m][vmstat]<br/>
						查看板卡信息：cat&nbsp;/proc/pci<br/>
						查看显卡/声卡信息：lspci&nbsp;|grep&nbsp;-i&nbsp;‘VGA’[dmesg&nbsp;|&nbsp;grep&nbsp;-i&nbsp;'VGA']<br/>
						查看网卡信息：dmesg&nbsp;|&nbsp;grep&nbsp;-i&nbsp;‘eth’[cat&nbsp;/etc/sysconfig/hwconf&nbsp;|&nbsp;grep&nbsp;-i&nbsp;eth][lspci&nbsp;|&nbsp;grep&nbsp;-i&nbsp;'eth']&nbsp;&nbsp;www.2cto.com&nbsp;<br/>
						&lt;!--more--&gt;<br/>
						查看PCI信息：lspci&nbsp;(相比cat&nbsp;/proc/pci更直观）<br/>
						查看USB设备：cat&nbsp;/proc/bus/usb/devices<br/>
						查看键盘和鼠标:cat&nbsp;/proc/bus/input/devices<br/>
						查看系统硬盘信息和使用情况：fdisk&nbsp;&amp;&nbsp;disk&nbsp;–&nbsp;l&nbsp;&amp;&nbsp;df<br/>
						查看各设备的中断请求(IRQ):cat&nbsp;/proc/interrupts<br/>
						查看系统体系结构：uname&nbsp;-a<br/>
						查看及启动系统的32位或64位内核模式：isalist&nbsp;–v&nbsp;[isainfo&nbsp;–v][isainfo&nbsp;–b]<br/>
						dmidecode查看硬件信息，包括bios、cpu、内存等信息<br/>
						测定当前的显示器刷新频率：/usr/sbin/ffbconfig&nbsp;–rev&nbsp;\?<br/>
						查看系统配置：/usr/platform/sun4u/sbin/prtdiag&nbsp;–v<br/>
						查看当前系统中已经应用的补丁：showrev&nbsp;–p<br/>
						显示当前的运行级别：who&nbsp;–rH<br/>
						查看当前的bind版本信息：nslookup&nbsp;–class=chaos&nbsp;–q=txt&nbsp;version.bind<br/>
						dmesg&nbsp;|&nbsp;more&nbsp;查看硬件信息<br/>
						lspci&nbsp;显示外设信息,&nbsp;如usb，网卡等信息<br/>
						lsnod&nbsp;查看已加载的驱动<br/>
						lshw<br/>
						psrinfo&nbsp;-v&nbsp;查看当前处理器的类型和速度（主频）<br/>
						prtconf&nbsp;-v&nbsp;打印当前的OBP版本号&nbsp;&nbsp;www.2cto.com&nbsp;<br/>
						iostat&nbsp;–E&nbsp;查看硬盘物理信息(vendor,&nbsp;RPM,&nbsp;Capacity)<br/>
						prtvtoc&nbsp;/dev/rdsk/c0t0d0s&nbsp;查看磁盘的几何参数和分区信息<br/>
						df&nbsp;–F&nbsp;ufs&nbsp;–o&nbsp;i&nbsp;显示已经使用和未使用的i-node数目<br/>
						isalist&nbsp;–v<br/>
						对于“/proc”中文件可使用文件查看命令浏览其内容，文件中包含系统特定信息：<br/>
						Cpuinfo&nbsp;主机CPU信息<br/>
						Dma&nbsp;主机DMA通道信息<br/>
						Filesystems&nbsp;文件系统信息<br/>
						Interrupts&nbsp;主机中断信息<br/>
						Ioprots&nbsp;主机I/O端口号信息<br/>
						Meninfo&nbsp;主机内存信息<br/>
						Version&nbsp;Linux内存版本信息<br/>
						备注：&nbsp;proc&nbsp;–&nbsp;process&nbsp;information&nbsp;pseudo-filesystem&nbsp;进程信息伪装文件系统<br/>
					</div>
				</div>
			</section>
			<section>
				<h3>linux在shell中获取时间</h3>
				<div>
					<div class="class___code class___copy_other_people_content">
						linux在shell中获取时间<br/>
						<br/>
						获得当天的日期<br/>
						<br/>
						date&nbsp;+%Y-%m-%d<br/>
						<br/>
						输出：&nbsp;2011-07-28<br/>
						<br/>
						&nbsp;<br/>
						<br/>
						将当前日期赋值给DATE变量<br/>
						DATE=$(date&nbsp;+%Y%m%d)<br/>
						<br/>
						有时候我们需要使用今天之前或者往后的日期，这时可以使用date的&nbsp;-d参数<br/>
						<br/>
						&nbsp;<br/>
						<br/>
						获取明天的日期<br/>
						<br/>
						date&nbsp;-d&nbsp;next-day&nbsp;+%Y%m%d<br/>
						<br/>
						获取昨天的日期<br/>
						<br/>
						date&nbsp;-d&nbsp;last-day&nbsp;+%Y%m%d<br/>
						<br/>
						获取上个月的年和月<br/>
						<br/>
						date&nbsp;-d&nbsp;last-month&nbsp;+%Y%m<br/>
						<br/>
						获取下个月的年和月<br/>
						date&nbsp;-d&nbsp;next-month&nbsp;+%Y%m<br/>
						<br/>
						获取明年的年份<br/>
						date&nbsp;-d&nbsp;next-year&nbsp;+%Y<br/>
						<br/>
						&nbsp;<br/>
						<br/>
						下面是一些date参数的说明和一些例子<br/>
						<br/>
						<br/>
						名称&nbsp;:&nbsp;date&nbsp;<br/>
						使用权限&nbsp;:&nbsp;所有使用者&nbsp;<br/>
						使用方式&nbsp;:&nbsp;date&nbsp;[-u]&nbsp;[-d&nbsp;datestr]&nbsp;[-s&nbsp;datestr]&nbsp;[--utc]&nbsp;[--universal]&nbsp;[--date=datestr]&nbsp;[--set=datestr]&nbsp;[--help]&nbsp;[--version]&nbsp;[+FORMAT]&nbsp;[MMDDhhmm[[CC]YY][.ss]]&nbsp;<br/>
						说明&nbsp;:&nbsp;date&nbsp;能用来显示或设定系统的日期和时间，在显示方面，使用者能设定欲显示的格式，格式设定为一个加号后接数个标记，其中可用的标记列表如下&nbsp;:&nbsp;<br/>
						时间方面&nbsp;:&nbsp;<br/>
						%&nbsp;:&nbsp;印出&nbsp;<br/>
						%&nbsp;%n&nbsp;:&nbsp;下一行&nbsp;<br/>
						%t&nbsp;:&nbsp;跳格&nbsp;<br/>
						%H&nbsp;:&nbsp;小时(00..23)&nbsp;<br/>
						%I&nbsp;:&nbsp;小时(01..12)&nbsp;<br/>
						%k&nbsp;:&nbsp;小时(0..23)&nbsp;<br/>
						%l&nbsp;:&nbsp;小时(1..12)&nbsp;<br/>
						%M&nbsp;:&nbsp;分钟(00..59)&nbsp;<br/>
						%p&nbsp;:&nbsp;显示本地&nbsp;AM&nbsp;或&nbsp;PM&nbsp;<br/>
						%r&nbsp;:&nbsp;直接显示时间&nbsp;(12&nbsp;小时制，格式为&nbsp;hh:mm:ss&nbsp;[AP]M)&nbsp;<br/>
						%s&nbsp;:&nbsp;从&nbsp;1970&nbsp;年&nbsp;1&nbsp;月&nbsp;1&nbsp;日&nbsp;00:00:00&nbsp;UTC&nbsp;到目前为止的秒数&nbsp;%S&nbsp;:&nbsp;秒(00..61)&nbsp;<br/>
						%T&nbsp;:&nbsp;直接显示时间&nbsp;(24&nbsp;小时制)&nbsp;<br/>
						%X&nbsp;:&nbsp;相当于&nbsp;%H:%M:%S&nbsp;<br/>
						%Z&nbsp;:&nbsp;显示时区&nbsp;<br/>
						日期方面&nbsp;:&nbsp;<br/>
						%a&nbsp;:&nbsp;星期几&nbsp;(Sun..Sat)&nbsp;<br/>
						%A&nbsp;:&nbsp;星期几&nbsp;(Sunday..Saturday)&nbsp;<br/>
						%b&nbsp;:&nbsp;月份&nbsp;(Jan..Dec)&nbsp;<br/>
						%B&nbsp;:&nbsp;月份&nbsp;(January..December)&nbsp;<br/>
						%c&nbsp;:&nbsp;直接显示日期和时间&nbsp;<br/>
						%d&nbsp;:&nbsp;日&nbsp;(01..31)&nbsp;<br/>
						%D&nbsp;:&nbsp;直接显示日期&nbsp;(mm/dd/yy)&nbsp;<br/>
						%h&nbsp;:&nbsp;同&nbsp;%b&nbsp;<br/>
						%j&nbsp;:&nbsp;一年中的第几天&nbsp;(001..366)&nbsp;<br/>
						%m&nbsp;:&nbsp;月份&nbsp;(01..12)&nbsp;<br/>
						%U&nbsp;:&nbsp;一年中的第几周&nbsp;(00..53)&nbsp;(以&nbsp;Sunday&nbsp;为一周的第一天的情形)&nbsp;<br/>
						%w&nbsp;:&nbsp;一周中的第几天&nbsp;(0..6)&nbsp;<br/>
						%W&nbsp;:&nbsp;一年中的第几周&nbsp;(00..53)&nbsp;(以&nbsp;Monday&nbsp;为一周的第一天的情形)&nbsp;<br/>
						%x&nbsp;:&nbsp;直接显示日期&nbsp;(mm/dd/yy)&nbsp;<br/>
						%y&nbsp;:&nbsp;年份的最后两位数字&nbsp;(00.99)&nbsp;<br/>
						%Y&nbsp;:&nbsp;完整年份&nbsp;(0000..9999)&nbsp;<br/>
						若是不以加号作为开头，则表示要设定时间，而时间格式为&nbsp;MMDDhhmm[[CC]YY][.ss]，&nbsp;<br/>
						其中&nbsp;MM&nbsp;为月份，&nbsp;<br/>
						DD&nbsp;为日，&nbsp;<br/>
						hh&nbsp;为小时，&nbsp;<br/>
						mm&nbsp;为分钟，&nbsp;<br/>
						CC&nbsp;为年份前两位数字，&nbsp;<br/>
						YY&nbsp;为年份后两位数字，&nbsp;<br/>
						ss&nbsp;为秒数&nbsp;<br/>
						把计&nbsp;:&nbsp;<br/>
						-d&nbsp;datestr&nbsp;:&nbsp;显示&nbsp;datestr&nbsp;中所设定的时间&nbsp;(非系统时间)&nbsp;<br/>
						--help&nbsp;:&nbsp;显示辅助讯息&nbsp;<br/>
						-s&nbsp;datestr&nbsp;:&nbsp;将系统时间设为&nbsp;datestr&nbsp;中所设定的时间&nbsp;<br/>
						-u&nbsp;:&nbsp;显示目前的格林威治时间&nbsp;<br/>
						--version&nbsp;:&nbsp;显示版本编号&nbsp;<br/>
						例子&nbsp;:&nbsp;<br/>
						显示时间后跳行，再显示目前日期&nbsp;:&nbsp;date&nbsp;+%T%n%D&nbsp;<br/>
						显示月份和日数&nbsp;:&nbsp;date&nbsp;+%B&nbsp;%d&nbsp;<br/>
						显示日期和设定时间(12:34:56)&nbsp;:&nbsp;date&nbsp;--date&nbsp;12:34:56&nbsp;<br/>
						设置系统当前时间（12:34:56）：date&nbsp;--s&nbsp;12:34:56&nbsp;<br/>
						注意&nbsp;:&nbsp;当你不希望出现无意义的&nbsp;0&nbsp;时(比如说&nbsp;1999/03/07)，则能在标记中插入&nbsp;-&nbsp;符号，比如说&nbsp;date&nbsp;+%-H:%-M:%-S&nbsp;会把时分秒中无意义的&nbsp;0&nbsp;给去掉，像是原本的&nbsp;08:09:04&nbsp;会变为&nbsp;8:9:4。另外，只有取得权限者(比如说&nbsp;root)才能设定系统时间。&nbsp;当你以&nbsp;root&nbsp;身分更改了系统时间之后，请记得以&nbsp;clock&nbsp;-w&nbsp;来将系统时间写入&nbsp;CMOS&nbsp;中，这样下次重新开机时系统时间才会持续抱持最新的正确值。&nbsp;<br/>
						ntp时间同步&nbsp;<br/>
						linux系统下默认安装了ntp服务，手动进行ntp同步如下&nbsp;<br/>
						ntpdate&nbsp;ntp1.nl.net&nbsp;<br/>
						当然，也能指定其他的ntp服务器&nbsp;<br/>
						-------------------------------------------------------------------&nbsp;<br/>
						扩展功能&nbsp;<br/>
						date&nbsp;工具可以完成更多的工作，不仅仅只是打印出当前的系统日期。您可以使用它来得到给定的日期究竟是星期几，并得到相对于当前日期的相对日期。了解某一天是星期几&nbsp;<br/>
						GNU&nbsp;对&nbsp;date&nbsp;命令的另一个扩展是&nbsp;-d&nbsp;选项，当您的桌上没有日历表时（UNIX&nbsp;用户不需要日历表），该选项非常有用。使用这个功能强大的选项，通过将日期作为引号括起来的参数提供，您可以快速地查明一个特定的日期究竟是星期几：&nbsp;<br/>
						$&nbsp;date&nbsp;-d&nbsp;"nov&nbsp;22"&nbsp;<br/>
						Wed&nbsp;Nov&nbsp;22&nbsp;00:00:00&nbsp;EST&nbsp;2006&nbsp;<br/>
						$&nbsp;<br/>
						在本示例中，您可以看到今年的&nbsp;11&nbsp;月&nbsp;22&nbsp;日是星期三。&nbsp;<br/>
						所以，假设在&nbsp;11&nbsp;月&nbsp;22&nbsp;日召开一个重大的会议，您可以立即了解到这一天是星期三，而这一天您将赶到驻地办公室。&nbsp;<br/>
						获得相对日期&nbsp;<br/>
						d&nbsp;选项还可以告诉您，相对于&nbsp;当前日期若干天的究竟是哪一天，从现在开始的若干天或若干星期以后，或者以前（过去）。通过将这个相对偏移使用引号括起来，作为&nbsp;-d&nbsp;选项的参数，就可以完成这项任务。&nbsp;<br/>
						例如，您需要了解两星期以后的日期。如果您处于&nbsp;Shell&nbsp;提示符处，那么可以迅速地得到答案：&nbsp;<br/>
						$&nbsp;date&nbsp;-d&nbsp;’2&nbsp;weeks’&nbsp;<br/>
						关于使用该命令，还有其他一些重要的方法。使用&nbsp;next/last指令，您可以得到以后的星期几是哪一天：&nbsp;<br/>
						$&nbsp;date&nbsp;-d&nbsp;’next&nbsp;monday’&nbsp;(下周一的日期)&nbsp;<br/>
						$&nbsp;date&nbsp;-d&nbsp;next-day&nbsp;+%Y%m%d（明天的日期）或者：date&nbsp;-d&nbsp;tomorrow&nbsp;+%Y%m%d&nbsp;<br/>
						$&nbsp;date&nbsp;-d&nbsp;last-day&nbsp;+%Y%m%d(昨天的日期)&nbsp;或者：date&nbsp;-d&nbsp;yesterday&nbsp;+%Y%m%d&nbsp;<br/>
						$&nbsp;date&nbsp;-d&nbsp;last-month&nbsp;+%Y%m(上个月是几月)&nbsp;<br/>
						$&nbsp;date&nbsp;-d&nbsp;next-month&nbsp;+%Y%m(下个月是几月)&nbsp;<br/>
						使用&nbsp;ago&nbsp;指令，您可以得到过去的日期：&nbsp;<br/>
						$&nbsp;date&nbsp;-d&nbsp;’30&nbsp;days&nbsp;ago’&nbsp;（30天前的日期）&nbsp;<br/>
						您可以使用负数以得到相反的日期：&nbsp;<br/>
						$&nbsp;date&nbsp;-d&nbsp;’dec&nbsp;14&nbsp;-2&nbsp;weeks’&nbsp;（相对:dec&nbsp;14这个日期的两周前的日期）&nbsp;<br/>
						$&nbsp;date&nbsp;-d&nbsp;’-100&nbsp;days’&nbsp;(100天以前的日期)&nbsp;<br/>
						$&nbsp;date&nbsp;-d&nbsp;’50&nbsp;days’(50天后的日期)&nbsp;<br/>
						这个技巧非常有用，它可以根据将来的日期为自己设置提醒，可能是在脚本或&nbsp;Shell&nbsp;启动文件中，如下所示：&nbsp;<br/>
						DAY=`date&nbsp;-d&nbsp;’2&nbsp;weeks’&nbsp;+"%b&nbsp;%d"`&nbsp;<br/>
						if&nbsp;test&nbsp;"`echo&nbsp;$DAY`"&nbsp;=&nbsp;"Aug&nbsp;16";&nbsp;then&nbsp;echo&nbsp;’Product&nbsp;launch&nbsp;is&nbsp;now&nbsp;two&nbsp;weeks&nbsp;away!’;&nbsp;fi&nbsp;<br/>
						<br/>
						##############################&nbsp;<br/>
						<br/>
						unix&nbsp;shell中的日期格式转换&nbsp;<br/>
						$&nbsp;t_t="Jul&nbsp;&nbsp;1&nbsp;21:29"&nbsp;<br/>
						$&nbsp;date&nbsp;"+%G-%m-%d&nbsp;%H:%M:%S"&nbsp;-d&nbsp;"$t_t"&nbsp;#&nbsp;$t_t的格式是比较随意的&nbsp;<br/>
						2008-07-01&nbsp;21:29:00&nbsp;<br/>
						$&nbsp;date&nbsp;+%b/%d/%G&nbsp;-d&nbsp;"2008-07-01"&nbsp;<br/>
						Jul/01/2008&nbsp;<br/>
						<br/>
						unix&nbsp;shell中的日期之间间隔的天数&nbsp;<br/>
						$&nbsp;expr&nbsp;'('&nbsp;$(date&nbsp;+%s&nbsp;-d&nbsp;"2008-07-02")&nbsp;-&nbsp;$(date&nbsp;+%s&nbsp;-d&nbsp;"2008-05-30")&nbsp;')'&nbsp;/&nbsp;86400&nbsp;<br/>
						33&nbsp;<br/>
						##存在bcdate的话，可以直接使用。&nbsp;<br/>
						<br/>
						shell中日期加减指定间隔单位&nbsp;<br/>
						增加36小时：&nbsp;<br/>
						$&nbsp;a=`date&nbsp;+%Y-%m-%d`&nbsp;<br/>
						$&nbsp;b=`date&nbsp;+%Y-%m-%d&nbsp;-d&nbsp;"$a&nbsp;+36&nbsp;hours"`&nbsp;<br/>
						10天前：&nbsp;<br/>
						$&nbsp;date&nbsp;-d&nbsp;"$a&nbsp;-10&nbsp;days"&nbsp;<br/>
						Sun&nbsp;Jun&nbsp;22&nbsp;00:00:00&nbsp;CST&nbsp;2008&nbsp;<br/>
						<br/>
						以指定格式显示文件更改后最后日期，如yyyy-mm-dd&nbsp;hh24:mi:ss&nbsp;<br/>
						$&nbsp;date&nbsp;"+%Y-%m-%d&nbsp;%H:%M:%S"&nbsp;-r&nbsp;test.bak<br/>
					</div>
				</div>
			</section>
			<section>
				<h3>设置开机自动挂载分区, /etc/fstab 文件说明</h3>
				<div>
					<div class="class___code class___copy_other_people_content">
						/etc/fstab&nbsp;参数详解及如何设置开机自动挂载<br/>
						<span class="class___tab">&#9;</span>某些时候当Linux系统下划分了新的分区后，需要将这些分区设置为开机自动挂载，否则，Linux是无法使用新建的分区的。&nbsp;/etc/fstab&nbsp;文件负责配置Linux开机时自动挂载的分区。<br/>
						<span class="class___tab">&#9;</span>在Windows的文件结构是多个并列的树状结构，最顶部的是不同的磁盘（分区），如：C，D，E等。Linux的文件结构是单个的树状结构。最顶部的为根目录，即/。在根目录下，分为多个子目录，包括/bin、/boot、/dev、/etc、/home、/lib、/media、/mnt、/opt、/proc、/root、/sbin、/tmp、/usr和/var等，根目录及其任意一个直接以及间接的子目录都有可能对应分区或硬件设备，即目录也是一个设备或分区的挂载点，例如一个硬盘分了两个分区，将一个分区挂载到一个目录下，当我们访问该目录时便是访问挂载的分区里的内容，挂载时这个挂载的分区在/dev/目录下有一个文件与之对应，通过将该文件挂载到相应的目录便是将该分区挂载到该目录，又例如将tmpfs文件系统挂载到某目录下，这个tmpfs不是硬盘分区而是由linux中将物理内存或交换分区中的一部分空间组成的文件系统，这样可以将一部分内存当硬盘一样读写文件，一些需要高速读写的临时可以放在此处。<br/>
						<span class="class___tab">&#9;</span>磁盘Linux分区都必须挂载到目录树中的某个具体的目录上才能进行读写操作，而fstab正是负责这一配置。显然，根目录是所有Linux的文件和目录所在的地方，需要挂载上一个磁盘分区。<br/>
						<span class="class___tab">&#9;</span>打开&nbsp;/etc/fstab&nbsp;文件,&nbsp;默认情况下，fstab中已经有了当前的分区配置，内容可能类似：<br/>
						<div style="display: grid;grid-template-columns: repeat(6, 1fr);">
							<div>&lt;file system&gt;</div>
							<div>&lt;mount point&gt;</div>
							<div>&lt;type&gt;</div>
							<div>&lt;options&gt;</div>
							<div>&lt;dump&gt;</div>
							<div>&lt;pass&gt;</div>

							<div>proc</div>
							<div>/proc</div>
							<div>proc</div>
							<div>defaults</div>
							<div>0</div>
							<div>0</div>

							<div>/dev/hda1</div>
							<div>/</div>
							<div>ext4</div>
							<div>errors=remount-ro</div>
							<div>0</div>
							<div>1</div>

							<div>/swapfile</div>
							<div>swap</div>
							<div>swap</div>
							<div>defaults</div>
							<div>0</div>
							<div>0</div>

							<div>/dev/hdc</div>
							<div>/media/cdrom0</div>
							<div>udf,iso9660</div>
							<div>user,noauto</div>
							<div>0</div>
							<div>0</div>
						</div>
						<span class="class___tab">&#9;</span>由上面的内容可以看出，系统的&nbsp;/dev/hda1&nbsp;分区被挂载在根目录，文件系统是ext3。此外，还有proc、swap等特殊的“分区”，与&nbsp;/dev/hdc&nbsp;被作为光驱挂载在了&nbsp;/media/cdrom0<br/>
						<br/>
						<span class="class___tab">&#9;</span>因此，如果希望将新分区&nbsp;/dev/hda5&nbsp;挂载在&nbsp;/home/new&nbsp;目录下，则只需在fstab文件中加入一行：<br/>
						<div style="display: grid;grid-template-columns: repeat(6, 1fr);">
							<div>/dev/hda5</div>
							<div>/home/new</div>
							<div>ext4</div>
							<div>defaults</div>
							<div>0</div>
							<div>0</div>
						</div>
						即可。<br/>
						<span class="class___tab">&#9;</span>第一列可以是实际分区名，也可以是实际分区的卷标（Lable）。<br/>
						<span class="class___tab">&#9;</span>如果磁盘是SATA接口，且有多个磁盘，则每个磁盘被标记为&nbsp;/dev/hda&nbsp;、&nbsp;/dev/hdb、&nbsp;/dev/hdc&nbsp;等以此类推；而每个磁盘的分区被标记为&nbsp;/dev/hda1、&nbsp;/dev/hda2等。<br/>
						<span class="class___tab">&#9;</span>如果磁盘是SCSI类型，则多个磁盘会被分别标记为&nbsp;/dev/sda、/dev/sdb等等。分区同理。<br/>
						<span class="class___tab">&#9;</span>如果使用标签来表示，则格式如：<br/>
						<span class="class___tab">&#9;</span>LABLE=/<br/>
						<span class="class___tab">&#9;</span>第二列是挂载点。<br/>
						<span class="class___tab">&#9;</span>挂载点必须为当前已经存在的目录，为了兼容起见，最好在创建需要挂载的目标目录后，将其权限设置为777，以开放所有权限。<br/>
						<span class="class___tab">&#9;</span>第三列为此分区的文件系统类型。<br/>
						<span class="class___tab">&#9;</span>Linux可以使用ext2、ext3等类型，此字段须与分区格式化时使用的类型相同。也可以使用&nbsp;auto&nbsp;这一特殊的语法，使系统自动侦测目标分区的分区类型。auto通常用于可移动设备的挂载。<br/>
						<span class="class___tab">&#9;</span>第四列是挂载的选项，用于设置挂载的参数。<br/>
						<span class="class___tab">&#9;</span>常见参数如下：<br/>
						<span class="class___tab">&#9;</span><span class="class___tab">&#9;</span>auto:&nbsp;系统自动挂载，fstab默认就是这个选项<br/>
						<span class="class___tab">&#9;</span><span class="class___tab">&#9;</span>defaults:&nbsp;rw,&nbsp;suid,&nbsp;dev,&nbsp;exec,&nbsp;auto,&nbsp;nouser,&nbsp;and&nbsp;async.<br/>
						<span class="class___tab">&#9;</span><span class="class___tab">&#9;</span>noauto&nbsp;开机不自动挂载<br/>
						<span class="class___tab">&#9;</span><span class="class___tab">&#9;</span>nouser&nbsp;只有超级用户可以挂载<br/>
						<span class="class___tab">&#9;</span><span class="class___tab">&#9;</span>ro&nbsp;按只读权限挂载<br/>
						<span class="class___tab">&#9;</span><span class="class___tab">&#9;</span>rw&nbsp;按可读可写权限挂载<br/>
						<span class="class___tab">&#9;</span><span class="class___tab">&#9;</span>user&nbsp;任何用户都可以挂载<br/>
						<span class="class___tab">&#9;</span><span class="class___tab">&#9;</span>请注意光驱和软驱只有在装有介质时才可以进行挂载，因此它是noauto<br/>
						<br/>
						<span class="class___tab">&#9;</span>第五列是dump备份设置。<br/>
						<span class="class___tab">&#9;</span>当其值设置为1时，将允许dump备份程序备份；设置为0时，忽略备份操作；<br/>
						<span class="class___tab">&#9;</span>第六列是fsck磁盘检查设置。<br/>
						<span class="class___tab">&#9;</span>其值是一个顺序。当其值为0时，永远不检查；而&nbsp;/&nbsp;根目录分区永远都为1。其它分区从2开始，数字越小越先检查，如果两个分区的数字相同，则同时检查。<br/>
						<span class="class___tab">&#9;</span>当修改完此文件并保存后，重启服务器生效。<br/>
					</div>
				</div>
			</section>
			<section>
				<h3>串口</h3>
				<div>
					<a target="_blank" href="https://blog.csdn.net/m0_46577050/article/details/122825130">linux 命令行操作串口_宁静致远2021的博客-CSDN博客_linux串口命令</a>
					<div>
						<span style="display : inline-block; border : 1px solid black; width : 14px; text-align : center;">+</span><span>为防链接失效的本地截图</span>
						<div style="display:none;">
							<script>add_fold(document.currentScript);</script>
							<img src="./refs/imgs/linux命令行操作串口_宁静致远2021的博客-CSDN博客_串口命令.png"/>
						</div>
					</div>
				</div>
			</section>
			<section>
				<h3>文件分隔</h3>
				<div>
					<a target="_blank" href="https://www.iteye.com/blog/czmmiao-1266577">Linux下二进制文件的分割与合并 - CzmMiao的博客生活 - ITeye技术网站</a>
					<div>
						<span style="display : inline-block; border : 1px solid black; width : 14px; text-align : center;">+</span><span>为防链接失效的本地截图</span>
						<div style="display:none;">
							<script>add_fold(document.currentScript);</script>
							<img src="./refs/imgs/Linux下二进制文件的分割与合并.png"/>
						</div>
					</div>
				</div>
			</section>
			<section>
				<h3>linux下安装中文字体</h3>
				<div>
					<a target="_blank" href="https://www.cnblogs.com/huangyanqi/p/10609587.html">linux安装中文字体 - 无敌仙人掌 - 博客园</a>
					<div>
						<span style="display : inline-block; border : 1px solid black; width : 14px; text-align : center;">+</span><span>为防链接失效的本地截图</span>
						<div style="display:none;">
							<script>add_fold(document.currentScript);</script>
							<img src="./refs/imgs/linux安装中文字体.png"/>
						</div>
					</div>
				</div>
			</section>
			<section>
				<h3>Linux磁盘基本概念_磁盘_分区_MBR_GPT</h3>
				<div>
					<a target="_blank" href="https://www.linuxidc.com/Linux/2013-06/85717.htm">Linux 磁盘基本概念（磁盘、分区、MBR、GPT）_Linux教程_Linux公社-Linux系统门户网站</a>
					<div>
						<span style="display : inline-block; border : 1px solid black; width : 14px; text-align : center;">+</span><span>为防链接失效的本地截图</span>
						<div style="display:none;">
							<script>add_fold(document.currentScript);</script>
							<img src="./refs/imgs/Linux磁盘基本概念_磁盘_分区_MBR_GPT.png"/>
						</div>
					</div>
				</div>
			</section>
			<section>
				<h3>sudoers</h3>
				<div>
					<a target="_blank" href="https://blog.csdn.net/SMF0504/article/details/53373892">请教/etc/sudoers中的含义_荪荪的博客-CSDN博客</a>
					<div>
						<span style="display : inline-block; border : 1px solid black; width : 14px; text-align : center;">+</span><span>为防链接失效的本地截图</span>
						<div style="display:none;">
							<script>add_fold(document.currentScript);</script>
							<img src="./refs/imgs/etc下sudoers的含义.png"/>
						</div>
					</div>
				</div>
			</section>
			<section>
				<h3>free</h3>
				<div>
					<a target="_blank" href="https://www.jianshu.com/p/2ffeb3a3aa90">linux free 命令下free/available区别 - 简书</a>
					<div>
						<span style="display : inline-block; border : 1px solid black; width : 14px; text-align : center;">+</span><span>为防链接失效的本地截图</span>
						<div style="display:none;">
							<script>add_fold(document.currentScript);</script>
							<img src="./refs/imgs/free_available.png"/>
						</div>
					</div>
				</div>
			</section>
			<section>
				<h3>rsync</h3>
				<div>
					<a target="_blank" href="https://www.ruanyifeng.com/blog/2020/08/rsync.html">rsync 用法教程 - 阮一峰的网络日志</a>
					<div>
						<span style="display : inline-block; border : 1px solid black; width : 14px; text-align : center;">+</span><span>为防链接失效的本地截图</span>
						<div style="display:none;">
							<script>add_fold(document.currentScript);</script>
							<img src="./refs/imgs/rsync.png"/>
						</div>
					</div>
				</div>
			</section>
			<section>
				<h3>diff, vimdiff</h3>
				<div>
					diff比较文件没有颜色，可以用vimdiff
					<br/>
					<span class="shell_instruction">vimdiff file_left, file_right</span>
					<br/>
					file_left 为显示在左侧的比较文件
					<br/>
					file_right 为显示在右侧的比较文件
				</div>
			</section>
			<section>
				<h3>download</h3>
				<div>
					<span class="shell_instruction">wget -c url</span>
					<br/>
					-c表示continue用于断点续传
					<br/>
					url为要下载的资源的url
					<br/>
					若url为https可以加
					<br/>
					--no-check-certificate
					<br/>
					<br/>
					<a target="_blank" href="https://www.cnblogs.com/inteliot/archive/2012/06/01/2530843.html">WGET下载https链接及WGET命令的详解 - 物联网技术 - 博客园</a>
					<br/>
					<div>
						<span style="display : inline-block; border : 1px solid black; width : 14px; text-align : center;">+</span><span>为防链接失效的本地截图</span>
						<div style="display:none;">
							<script>add_fold(document.currentScript);</script>
							<img src="./refs/download/WGET下载https链接及WGET命令的详解.png"/>
						</div>
					</div>
					<br/>
					<a target="_blank" href="https://www.cnblogs.com/yosg/p/4747741.html">使用wget镜像网站 - yosg - 博客园</a>
					<br/>
					<div>
						<span style="display : inline-block; border : 1px solid black; width : 14px; text-align : center;">+</span><span>为防链接失效的本地截图</span>
						<div style="display:none;">
							<script>add_fold(document.currentScript);</script>
							<img src="./refs/download/使用wget镜像网站.png"/>
						</div>
					</div>
					<br/>
					<a target="_blank" href="https://www.cnblogs.com/analyzer/archive/2010/05/04/1727438.html">wget 命令用法详解 - analyzer - 博客园</a>
					<br/>
					<div>
						<span style="display : inline-block; border : 1px solid black; width : 14px; text-align : center;">+</span><span>为防链接失效的本地截图</span>
						<div style="display:none;">
							<script>add_fold(document.currentScript);</script>
							<img src="./refs/download/wget命令用法详解.png"/>
						</div>
					</div>
					<br/>
					<a target="_blank" href="https://java-er.com/blog/wget-useage-x/">wget指定文件，指定目录，指定路径下载 | 月小升IT技术博客</a>
					<br/>
					<div>
						<span style="display : inline-block; border : 1px solid black; width : 14px; text-align : center;">+</span><span>为防链接失效的本地截图</span>
						<div style="display:none;">
							<script>add_fold(document.currentScript);</script>
							<img src="./refs/download/wget指定文件_指定目录_指定路径下载.png"/>
						</div>
					</div>
					<br/>
					<a target="_blank" href="https://blog.csdn.net/hzraymond/article/details/8181349">shell: wget、curl(libcurl)使用方法及其区别 - hzraymond的专栏 - 博客频道 - CSDN.NET</a>
					<br/>
					<div>
						<span style="display : inline-block; border : 1px solid black; width : 14px; text-align : center;">+</span><span>为防链接失效的本地截图</span>
						<div style="display:none;">
							<script>add_fold(document.currentScript);</script>
							<img src="./refs/download/wget_curl(libcurl)使用方法及其区别.png"/>
						</div>
					</div>
					<br/>
					<a target="_blank" href="http://blog.51yip.com/linux/1049.html">linux curl 命令详解，以及实例</a>
					<br/>
					<div>
						<span style="display : inline-block; border : 1px solid black; width : 14px; text-align : center;">+</span><span>为防链接失效的本地截图</span>
						<div style="display:none;">
							<script>add_fold(document.currentScript);</script>
							<img src="./refs/download/linux_curl命令详解_以及实例.png"/>
						</div>
					</div>
					<br/>
					<a target="_blank" href="https://blog.csdn.net/xifeijian/article/details/9367339">Linux Shell脚本编程－－curl命令详解 - 席飞剑>>>专注软件测试技术与质量管理 - 博客频道 - CSDN.NET</a>
					<br/>
					<div>
						<span style="display : inline-block; border : 1px solid black; width : 14px; text-align : center;">+</span><span>为防链接失效的本地截图</span>
						<div style="display:none;">
							<script>add_fold(document.currentScript);</script>
							<img src="./refs/download/Linux_Shell脚本编程_curl命令详解_上善若水_水善利万物而不争.png"/>
						</div>
					</div>
				</div>
			</section>
			<section>
				<h3>比较二进制文件差异</h3>
				<div>
					先将二进制文件转换为16进制文本文件, 即将每个字节转换为两个16进制的ASCII字符(在C语言中用printf("%02x"))
					<br/>
					再用diff命令比较转换后的hex文件
					<br/>
					<span class="shell_instruction">xxd binary_file1_name &gt; hexadecimal_file1_name</span>
					<br/>
					<span class="shell_instruction">xxd binary_file2_name &gt; hexadecimal_file2_name</span>
					<br/>
					<span class="shell_instruction">diff hexadecimal_file1_name hexadecimal_file2_name</span>
					<br/>
					binary_file1_name是第1个2进制文件的文件名
					<br/>
					hexadecimal_file1_name是第1个2进制文件转换为16进制文本文件的文件名
					<br/>
					binary_file2_name是第2个2进制文件的文件名
					<br/>
					hexadecimal_file2_name是第2个2进制文件转换为16进制文本文件的文件名
					<br/>
				</div>
			</section>
			<section>
				<h3>dnf, yum</h3>
				<div>
					<span class="shell_instruction">man 8 dnf</span>
					<br/>
					<span class="shell_instruction">--downloaddir=download_path</span>
					<br/>
					Redirect downloaded packages to provided directory. The option has to by used together with --downloadonly command line option or with download command (dnf-plugins-core).
					<br/>
					<span class="shell_instruction">--downloadonly</span>
					<br/>
					Download resolved package set without performing any rpm transaction (install/upgrade/erase).
				</div>
			</section>
			<section>
				<h3>查看cpu信息和开关cpu内核</h3>
				<div>
					查看cpu信息:
					<br/>
					<span class="shell_instruction">cat /proc/cpuinfo</span>
					<br/>
					查看cpu内核数量:
					<br/>
					<span class="shell_instruction">ls /sys/devices/system/cpu/</span>
					<br/>
					显示的cpu0,cpu1...便是相应的cpu内核,从0开始最后一个数加1便是总内核数
					<br/>
					关闭某个内核如cpu3号内核:
					<br/>
					<span class="shell_instruction">echo 0 &gt; /sys/devices/system/cpu/cpu3/online</span>
					<br/>
					开启某个内核如cpu3号内核:
					<br/>
					<span class="shell_instruction">echo 1 &gt; /sys/devices/system/cpu/cpu3/online</span>
				</div>
			</section>
			<section>
				<h3>efibootmgr修改主板上EFI的设备启动项</h3>
				<div>
					查看启动项列表:
					<br/>
					<span class="shell_instruction">efibootmgr</span>
					<br/>
					查看启动项列表详细信息:
					<br/>
					<span class="shell_instruction">efibootmgr -v</span>
					<br/>
					参数列表可参考:
					<br/>
					<span class="shell_instruction">man efibootmgr</span>
					<br/>
					或
					<a target="_blank" href="https://linux.die.net/man/8/efibootmgr">efibootmgr(8): change EFI Boot Manager - Linux man page</a>
					<br/>
					删除启动项:
					<br/>
					<span class="shell_instruction">efibootmgr -b 启动项编号 -B</span>
					<br/>
					如删除编号为0002的项
					<br/>
					<span class="shell_instruction">efibootmgr -b 0002 -B</span>
					<br/>
					创建启动项:
					<br/>
					<span class="shell_instruction">efibootmgr -c -w -L "启动项名称" -d 存储设备路径 -p 分区编号 -l 启动文件相对于前面指定的分区的路径</span>
					<br/>
					如创建启动项叫mylinux, 启动文件在/boot/efi/EFI/fedora/shimx64.efi, 此文件在分区/dev/sda1, /dev/sda1的挂载路径为/boot/efi/
					<br/>
					<span class="shell_instruction">efibootmgr -c -w -L "mylinux" -d /dev/sda -p 1 -l \\EFI\\fedora\\shimx64.efi</span>
					<br/>
					修改启动项顺序:
					<br/>
					<span class="shell_instruction">efibootmgr -o 用,分隔的启动项编号</span>
					<br/>
					如修改启动项顺序为0002,0003,0001
					<br/>
					<span class="shell_instruction">efibootmgr -o 0002,0003,0001</span>
				</div>
			</section>
			<section>
				<h3>make install, make uninstall, make clean</h3>
				<div>
					<div>
						<span style="display : inline-block; border : 1px solid black; width : 14px; text-align : center;">+</span><span>为防链接失效的本地截图</span>
						<div style="display:none;">
							<script>add_fold(document.currentScript);</script>
							<div class="class___copy_other_people_content">
								通常的安装方法是从源码安装包的目录执行以下命令：
								<br/>
								先解压
								<br/>
								然后cd进入源码目录
								<br/>
								检查环境，配置编译条件
								<br/>
								<span class="class___shell">./configure</span>
								<br/>
								<br/>
								调用gcc进行编译
								<br/>
								<span class="class___shell">make</span>
								<br/>
								<br/>
								安装编译好的可执行程序
								<br/>
								<span class="class___shell">sudo make install</span>
								<br/>
								<br/>
								<br/>
								<br/>
								卸载软件：
								<br/>
								删除make install命令时装进去的文件
								<br/>
								<span class="class___shell">sudo make uninstall</span>
								<br/>
								<br/>
								只删除make时产生的临时文件
								<br/>
								<span class="class___shell">make clean</span>
								<br/>
								<br/>
								同时删除configure和make产生的临时文件(soft1下)
								<br/>
								<span class="class___shell">make distclean</span>
								<br/>
								<br/>
								<br/>
								make的原理是执行一个叫Makefile文件里的指令，make的基本用处是自动根据makefile里的指令来编译源文件。它还可以用来做比如安装软件，卸载软件等事情，但前提是作者在makefile里写了。比如makefile里有这么些内容：
								<br/>
								......
								<br/>
								install : < commands >
								<br/>
								然后用make install的话，make程序就会按照上面install：后面的指令< commands >执行安装，uninstall也是一样的道理，大部分的作者会写有卸载的部分，这时只要简单地执行make unistall就可以，如果作者懒没有写，那就只有根据make install中的步骤，看它把什么文件拷到哪去了，然后分别手动删除。
								<br/>
								还有关键的一点是，编译安装完成后，不要删除源代码，不然就算作者写了uninstall目标，你也没有makefile可以执行了。
							</div>
						</div>
					</div>
				</div>
			</section>
			<section>
				<h3>UUID, PARTUUID</h3>
				<div>
					UUID is a filesystem-level UUID, which is retrieved from the filesystem metadata inside the partition. That can only be read if the filesystem type is known and readable.
					<br/>
					PARTUUID is a partition-table-level UUID for the partition, a standard feature for all partitions on GPT-partitioned disks. Since it is retrieved from the partition table, it is accessible without making no assumptions at all about the actual contents of the partition. If the partition is encrypted using some unknown encryption method, this might be the only accessible unique identifier for that particular partition.
					<br/>
					PTUUID is the UUID of the partition table itself, a unique identifier for the entire disk assigned at the time the disk was partitioned. It's the equivalent of disk signature on MBR-partitioned disks, but with more bits and standardized procedure for its generation.
					<br/>
					On MBR-partitioned disks, there are no real UUIDs in the partition table. So, the 32-bit disk signature is used in place of a PTUUID, and PARTUUIDs are created by adding a dash and a two-digit partition number to the end of the disk signature.
				</div>
			</section>
			<section>
				<h3>分区</h3>
				<div>
					GPT分区用:
					<br/>
					<span class="shell_instruction">parted</span>
					<br/>
					MBR分区用:
					<br/>
					<span class="shell_instruction">fdisk</span>
				</div>
			</section>
			<section>
				<h3>文件系统</h3>
				<div>
					<a target="_blank" href="https://www.cnblogs.com/tommyli/p/3201047.html">ext3，ext4，xfs和btrfs文件系统性能对比 - 李占卫 - 博客园</a>
					<div>
						<span style="display : inline-block; border : 1px solid black; width : 14px; text-align : center;">+</span><span>为防链接失效的本地截图</span>
						<div style="display:none;">
							<script>add_fold(document.currentScript);</script>
							<div class="class___copy_other_people_content">
								<br/>
								1：单字节写入性能对比
								<br/>
								<img src="./refs/performance_comparison_of_ext3_ext4_XFS_Btrfs_file_systems/01.png">
								<br/>
								A：由于硬盘式块设备所以对于这种测试硬盘式不擅长的
								<br/>
								B：btrfs系统只有200K/SEC,xfs表现的性能比较平衡。
								<br/>
								2：块写入性能对比（由于硬盘是块设备这种对比来的更有意义）
								<br/>
								<img src="./refs/performance_comparison_of_ext3_ext4_XFS_Btrfs_file_systems/02.png">
								<br/>
								A：性能上差不多，但是效率上（CPU占用率上）来说最好的是xfs接下来依次是EXT4，EXT3，BTRFS
								<br/>
								3：直接块顺序读写（关掉任何的系统和文件缓存）
								<br/>
								<img src="./refs/performance_comparison_of_ext3_ext4_XFS_Btrfs_file_systems/03.png">
								<br/>
								A：绕过系统和文件缓冲的话（例如：视频录制，一些虚拟机软件，ECC），EXT3/ 4是最好的选择，其次是BTRFS，最后是XFS。
								<br/>
								B：没有一种文件系统可以适用于所有环境
								<br/>
								4：随机寻道
								<br/>
								<img src="./refs/performance_comparison_of_ext3_ext4_XFS_Btrfs_file_systems/04.png">
								<br/>
								A：BTRFS系能最差，不到20 seeks/sec
								<br/>
								B：EXT3性能最好，如果软件大量的随机寻址的话这个文件系统性能更好
								<br/>
								5：创建和删除大量文件（文件量一定）
								<br/>
								<img src="./refs/performance_comparison_of_ext3_ext4_XFS_Btrfs_file_systems/05_1.png">
								<br/>
								BTRFS系统性能最差，下面是去掉该系统其它3种的对比
								<br/>
								<img src="./refs/performance_comparison_of_ext3_ext4_XFS_Btrfs_file_systems/05_2.png">
								<br/>
								A：EXT4是更高效高性能的系统，接下来依次是XFS,EXT3
								<br/>
								6：顺序读写吞吐量【没有fsync的是100 writes/one fsync()，有的是1 writes/one fsync()】
								<br/>
								<img src="./refs/performance_comparison_of_ext3_ext4_XFS_Btrfs_file_systems/06.png">
								<br/>
								A：100 writes/one fsync()各个性能差不多
								<br/>
								B：1 writes/one fsync()时EXT3性能最好，接下来依次是XFS,EXT4，BTRFS
								<br/>
								C：write + fsync()在BTRFS下对读性能产生影响
								<br/>
								7：随机读写吞吐量
								<br/>
								<img src="./refs/performance_comparison_of_ext3_ext4_XFS_Btrfs_file_systems/07.png">
								<br/>
								A：100 seeks/sec每个块16 KB，我们得出最大的读取速度是1600 KB/sec，XFS，BTRFS大于了这个数值（可能数据不能随机也可能缓冲影响了结果）
								<br/>
								B：EXT3随机写入性能是最好的，适用于数据库，高容量的记录程序和虚拟机系统
								<br/>
								8：向PostgreSQL 中写入10万行数据
								<br/>
								<img src="./refs/performance_comparison_of_ext3_ext4_XFS_Btrfs_file_systems/08.png">
								<br/>
								A：BTRFS 性能是最好的，EXT4和XFS很低的cpu使用率但是性能太差
								<br/>
								9：读测试
								<br/>
								<img src="./refs/performance_comparison_of_ext3_ext4_XFS_Btrfs_file_systems/09.png">
								<br/>
								A：10万次的读测试，性能差别不大
								<br/>
								10：复杂的读写以及事务测试
								<br/>
								<img src="./refs/performance_comparison_of_ext3_ext4_XFS_Btrfs_file_systems/10.png">
								<br/>
								A：EXT3性能最好
								<br/>
								所以，数据库最好是EXT3系统，除非EXT4解决了所谓的回归问题。
								<br/>
								11：Linux kernel 2.6.36下的解包操作
								<br/>
								<img src="./refs/performance_comparison_of_ext3_ext4_XFS_Btrfs_file_systems/11_1.png">
								<br/>
								A：该操作最好的文件系统是EXT4
								<br/>
								这次操作会受到缓存和延时分配的影响，我们强制同步看看效果
								<br/>
								<img src="./refs/performance_comparison_of_ext3_ext4_XFS_Btrfs_file_systems/11_2.png">
								<br/>
								A：XFS是较慢的FS，EXT3慢于EXT4和BTRFS
								<br/>
								12：cat操作
								<br/>
								<img src="./refs/performance_comparison_of_ext3_ext4_XFS_Btrfs_file_systems/12.png">
								<br/>
								A：该操作比较有效率的系统是XFS
								<br/>
								B：该执行最快CPU占用最高的系统是BTRFS，，说明该系统有复杂的元数据操作
								<br/>
								13：解压linux核心（会产生32000 files）
								<br/>
								<img src="./refs/performance_comparison_of_ext3_ext4_XFS_Btrfs_file_systems/13.png">
								<br/>
								A：EXT3这个唯一没有延时分配能力的系统是最差的
								<br/>
								14：顺序创建128个文件，每个长16 MB（共2 GB）各种系统产生的碎片情况
								<br/>
								<img src="./refs/performance_comparison_of_ext3_ext4_XFS_Btrfs_file_systems/14_1.png">
								<br/>
								A：BTRFS系统碎片是个严重的问题（这也解释了先前的这种系统读性能低下的原因）
								<br/>
								出去BTRFS系统后的图
								<br/>
								<img src="./refs/performance_comparison_of_ext3_ext4_XFS_Btrfs_file_systems/14_2.png">
								<br/>
								A：EXT4，XFS这种有延时分配机制的系统产生的碎片少于EXT3（即使one write/one fsync()）
								<br/>
								15：随机创建128个文件，每个长16 MB（共2 GB）各种系统产生的碎片情况
								<br/>
								<img src="./refs/performance_comparison_of_ext3_ext4_XFS_Btrfs_file_systems/15.png">
								<br/>
								A：随机写入在任何系统下都会产生碎片，即使有延时分配也没用
								<br/>
								<br/>
								<br/>
								Linux kernel 自 2.6.28 开始正式支持新的文件系统 Ext4。 Ext4 是 Ext3 的改进版，修改了 Ext3 中部分重要的数据结构，而不仅仅像 Ext3 对 Ext2 那样，只是增加了一个日志功能而已。Ext4 可以提供更佳的性能和可靠性，还有更为丰富的功能：
								<br/>
								1. 与 Ext3 兼容。执行若干条命令，就能从 Ext3 在线迁移到 Ext4，而无须重新格式化磁盘或重新安装系统。原有 Ext3 数据结构照样保留，Ext4 作用于新数据，当然，整个文件系统因此也就获得了 Ext4 所支持的更大容量。
								<br/>
								2. 更大的文件系统和更大的文件。较之 Ext3 目前所支持的最大 16TB 文件系统和最大 2TB 文件，Ext4 分别支持 1EB（1,048,576TB， 1EB=1024PB， 1PB=1024TB）的文件系统，以及 16TB 的文件。
								<br/>
								3. 无限数量的子目录。Ext3 目前只支持 32,000 个子目录，而 Ext4 支持无限数量的子目录。
								<br/>
								4. Extents。Ext3 采用间接块映射，当操作大文件时，效率极其低下。比如一个 100MB 大小的文件，在 Ext3 中要建立 25,600 个数据块（每个数据块大小为 4KB）的映射表。而 Ext4 引入了现代文件系统中流行的 extents 概念，每个 extent 为一组连续的数据块，上述文件则表示为“ 该文件数据保存在接下来的 25,600 个数据块中”，提高了不少效率。
								<br/>
								5. 多块分配。当写入数据到 Ext3 文件系统中时，Ext3 的数据块分配器每次只能分配一个 4KB 的块，写一个 100MB 文件就要调用 25,600 次数据 块分配器，而 Ext4 的多块分配器“multiblock allocator”（mballoc） 支持一次调用分配多个数据块。
								<br/>
								6. 延迟分配。Ext3 的数据块分配策略是尽快分配，而 Ext4 和其它现代文件操作系统的策略是尽可能地延迟分配，直到文件在 cache 中写完才开始分配数据块并写入磁盘，这样就能优化整个文件的数据块分配，与前两种特性搭配起来可以显著提升性能。
								<br/>
								7. 快速 fsck。以前执行 fsck 第一步就会很慢，因为它要检查所有的 inode，现在 Ext4 给每个组的 inode 表中都添加了一份未使用 inode 的列表，今后 fsck Ext4 文件系统就可以跳过它们而只去检查那些在用的 inode 了。
								<br/>
								8. 日志校验。日志是最常用的部分，也极易导致磁盘硬件故障，而从损坏的日志中恢复数据会导致更多的数据损坏。Ext4 的日志校验功能可以很方便地判断日志数据是否损坏，而且它将 Ext3 的两阶段日志机制合并成一个阶段，在增加安全性的同时提高了性能。
								<br/>
								9. “无日志”（No Journaling）模式。日志总归有一些开销，Ext4 允许关闭日志，以便某些有特殊需求的用户可以借此提升性能。
								<br/>
								10. 在线碎片整理。尽管延迟分配、多块分配和 extents 能有效减少文件系统碎片，但碎片还是不可避免会产生。Ext4 支持在线碎片整理，并将提供 e4defrag 工具进行个别文件或整个文件系统的碎片整理。
								<br/>
								11. inode 相关特性。Ext4 支
								持更大的 inode，较之 Ext3 默认的 inode 大小 128 字节，Ext4 为了在 inode 中容纳更多的扩展属性（如纳秒时间戳或 inode 版本），默认 inode 大小为 256 字节。Ext4 还支持快速扩展属性（fast extended attributes） 和 inode 保留（inodes reservation）。
								<br/>
								12. 持久预分配（Persistent preallocation）。P2P 软件为了保证下载文件有足够的空间存放，常常会预先创建一个与所下载文件大小相同的空文件，以免未来的数小时或数天之内磁盘空间不足导致下载失 败。Ext4 在文件系统层面实现了持久预分配并提供相应的 API（libc 中的 posix_fallocate()），比应用软件自己实现更有效率。
								<br/>
								13. 默认启用 barrier。磁盘上配有内部缓存，以便重新调整批量数据的写操作顺序，优化写入性能，因此文件系统必须在日志数据写入磁盘之后才能写 commit 记录， 若 commit 记录写入在先，而日志有可能损坏，那么就会影响数据完整性。Ext4 默认启用 barrier，只有当 barrier 之前的数据全部写入磁盘，才能写 barrier 之后的数据。（可通过 "mount -o barrier=0" 命令禁用该特性。）
							</div>
						</div>
					</div>
					<br/>
					<div>
						<span style="display : inline-block; border : 1px solid black; width : 14px; text-align : center;">+</span><span>为防链接失效的本地截图</span>
						<div style="display:none;">
							<script>add_fold(document.currentScript);</script>
							<div class="class___copy_other_people_content">
								<a target="_blank" href="http://www.360doc.com/content/19/0304/12/496343_819108088.shtml">新一代 Linux 文件系统 btrfs 简介</a>
								<h2 id="titiletext">新一代 Linux 文件系统 btrfs 简介</h2>
								<table>
									<tbody>
										<tr>
											<td>
												btrfs（B-tree filesystem），由Oracle 2007年后研发，这是一个技术预览版的文件系统，推出用于弥补、替换Linux中的Ext系列文件系统。
												<strong>重要技术特性：</strong>
												<br/>
												1)支持写时复制(COW)，保证数据的可靠性
												<br/>
												2)更好的扩展性支持，利用动态inode创建、Extent、B-tree实现
												<br/>
												3)支持非常大的单个文件与总容量
												<br/>
												4)支持文件快速检查功能，基于数据及元数据校验码机制，将数据、元数据的某些属性保存下来，下次读取时可根据这些属性快速检测是否受损，如果损坏还能尝试修复，这样极大的提高数据的准确性
												<br/>
												5)支持将多个物理卷组成一个Btrfs文件系统，并内置RAID，支持将数据、元数据以RAID、single、dup等方式在多个物理卷中存储。
												<br/>
												6)支持创建子卷，可以创建多个子卷，子卷可以单独挂载
												<br/>
												7)支持透明压缩功能，自动占用CPU资源对传入/出的文件进行压缩/解压
												<br/>
												8)支持快照，支持对子卷、文件进行快照，还能对快照进行快照
												<h2>Btrfs 简介</h2>
												<p>
													文件系统似乎是内核中比较稳定的部分，多年来，人们一直使用 ext2/3，ext 文件系统以其卓越的稳定性成为了事实上的 Linux 标准文件系统。近年来 ext2/3 暴露出了一些扩展性问题，于是便催生了 ext4 。在 2008 年发布的 Linux2.6.19 内核中集成了 ext4 的 dev 版本。 2.6.28 内核发布时，ext4 结束了开发版，开始接受用户的使用。似乎 ext 就将成为 Linux 文件系统的代名词。然而当您阅读很多有关 ext4 的文章时，会发现都不约而同地提到了 btrfs，并认为 ext4 将是一个过渡的文件系统。 ext4 的作者 Theodore Tso 也盛赞 btrfs 并认为 btrfs 将成为下一代 Linux 标准文件系统。 Oracle，IBM， Intel 等厂商也对 btrfs 表现出了极大的关注，投入了资金和人力。为什么 btrfs 如此受人瞩目呢。这便是本文首先想探讨的问题。
												</p>
												<p>
													Kevin Bowling[1] 有一篇介绍各种文件系统的文章，在他看来，ext2/3 等文件系统属于“古典时期”。文件系统的新时代是 2005 年由 Sun 公司的 ZFS 开创的。 ZFS 代表” last word in file system ”，意思是此后再也不需要开发其他的文件系统了。 ZFS 的确带来了很多崭新的观念，对文件系统来讲是一个划时代的作品。
												</p>
												<p>
													如果您比较 btrfs 的特性，将会发现 btrfs 和 ZFS 非常类似。也许我们可以认为 btrfs 就是 Linux 社区对 ZFS 所作出的回应。从此往后在 Linux 中也终于有了一个可以和 ZFS 相媲美的文件系统。
												</p>
												<h2>btrfs 的特性</h2>
												<p>
													您可以在 btrfs 的主页上 [2] 看到 btrfs 的特性列表。我自作主张，将那张列表分成了四大部分。
												</p>
												<p>
													首先是扩展性 (scalability) 相关的特性，btrfs 最重要的设计目标是应对大型机器对文件系统的扩展性要求。 Extent，B-Tree 和动态 inode 创建等特性保证了 btrfs 在大型机器上仍有卓越的表现，其整体性能而不会随着系统容量的增加而降低。
												</p>
												<p>
													其次是数据一致性 (data integrity) 相关的特性。系统面临不可预料的硬件故障，Btrfs 采用 COW 事务技术来保证文件系统的一致性。 btrfs 还支持 checksum，避免了 silent corrupt 的出现。而传统文件系统则无法做到这一点。
												</p>
												<p>
													第三是和多设备管理相关的特性。 Btrfs 支持创建快照 (snapshot)，和克隆 (clone) 。 btrfs 还能够方便的管理多个物理设备，使得传统的卷管理软件变得多余。
												</p>
												<p>
													最后是其他难以归类的特性。这些特性都是比较先进的技术，能够显著提高文件系统的时间 / 空间性能，包括延迟分配，小文件的存储优化，目录索引等。
												</p>
												<h3>扩展性相关的特性</h3>
												<p>B-Tree</p>
												<p>
													btrfs 文件系统中所有的 metadata 都由 BTree 管理。使用 BTree 的主要好处在于查找，插入和删除操作都很高效。可以说 BTree 是 btrfs 的核心。
												</p>
												<p>
													一味地夸耀 BTree 很好很高效也许并不能让人信服，但假如稍微花费一点儿时间看看 ext2/3 中元数据管理的实现方式，便可以反衬出 BTree 的优点。
												</p>
												<p>
													妨碍 ext2/3 扩展性的一个问题来自其目录的组织方式。目录是一种特殊的文件，在 ext2/3 中其内容是一张线性表格。如图 1-1 所示 [6]：
												</p>
												<h5>图 1. ext2 directory [6]</h5>
												<img src="./refs/linux_btrfs/ext2_directory.jpg" alt="ext2 directory" width="514" height="277"/>
												<p>
													图 1 展示了一个 ext2 目录文件的内容，该目录中包含四个文件。分别是 "home1"，"usr"，"oldfile" 和 "sbin" 。如果需要在该目录中查找目录 sbin，ext2 将遍历前三项，直至找到 sbin 这个字符串为止。
												</p>
												<p>
													这种结构在文件个数有限的情况下是比较直观的设计，但随着目录下文件数的增加，查找文件的时间将线性增长。 2003 年，ext3 设计者开发了目录索引技术，解决了这个问题。目录索引使用的数据结构就是 BTree 。如果同一目录下的文件数超过 2K，inode 中的 i_data 域指向一个特殊的 block 。在该 block 中存储着目录索引 BTree 。 BTree 的查找效率高于线性表，
												</p>
												<p>
													但为同一个元数据设计两种数据结构总是不太优雅。在文件系统中还有很多其他的元数据，用统一的 BTree 管理是非常简单而优美的设计。
												</p>
												<p>
													Btrfs 内部所有的元数据都采用 BTree 管理，拥有良好的可扩展性。 btrfs 内部不同的元数据由不同的 Tree 管理。在 superblock 中，有指针指向这些 BTree 的根。如图 2 所示：
												</p>
												<h5>图 2. btrfs btree</h5>
												<img src="./refs/linux_btrfs/btrfs_btree.jpg" alt="btrfs btree" width="566" height="279"/>
												<p>
													FS Tree 管理文件相关的元数据，如 inode，dir 等； Chunk tree 管理设备，每一个磁盘设备都在 Chunk Tree 中有一个 item ； Extent Tree 管理磁盘空间分配，btrfs 每分配一段磁盘空间，便将该磁盘空间的信息插入到 Extent tree 。查询 Extent Tree 将得到空闲的磁盘空间信息； Tree of tree root 保存很多 BTree 的根节点。比如用户每建立一个快照，btrfs 便会创建一个 FS Tree 。为了管理所有的树，btrfs 采用 Tree of tree root 来保存所有树的根节点； checksum Tree 保存数据块的校验和。
												</p>
												<p>
													<strong>基于 Extent 的文件存储</strong>
												</p>
												<p>
													现代很多文件系统都采用了 extent 替代 block 来管理磁盘。 Extent 就是一些连续的 block，一个 extent 由起始的 block 加上长度进行定义。
												</p>
												<p>
													Extent 能有效地减少元数据开销。为了进一步理解这个问题，我们还是看看 ext2 中的反面例子。
												</p>
												<p>
													ext2/3 以 block 为基本单位，将磁盘划分为多个 block 。为了管理磁盘空间，文件系统需要知道哪些 block 是空闲的。 Ext 使用 bitmap 来达到这个目的。 Bitmap 中的每一个 bit 对应磁盘上的一个 block，当相应 block 被分配后，bitmap 中的相应 bit 被设置为 1 。这是很经典也很清晰的一个设计，但不幸的是当磁盘容量变大时，bitmap 自身所占用的空间也将变大。这就导致了扩展性问题，随着存储设备容量的增加，bitmap 这个元数据所占用的空间也随之增加。而人们希望无论磁盘容量如何增加，元数据不应该随之线形增加，这样的设计才具有可扩展性。
												</p>
												<p>
													下图比较了 block 和 extent 的区别：
												</p>
												<h5>图 3. 采用 extent 的 btrfs 和采用 bitmap 的 ext2/3</h5>
												<img src="./refs/linux_btrfs/采用extent的btrfs和采用bitmap的ext2_3.jpg" alt="采用extent的btrfs和采用bitmap的ext2/3" width="563" height="179"/>
												<p>
													在 ext2/3 中，10 个 block 需要 10 个 bit 来表示；在 btrfs 中则只需要一个元数据。对于大文件，extent 表现出了更加优异的管理性能。
												</p>
												<p>
													Extent 是 btrfs 管理磁盘空间的最小单位，由 extent tree 管理。 Btrfs 分配 data 或 metadata 都需要查询 extent tree 以便获得空闲空间的信息。
												</p>
												<p>
													<strong>动态 inode 分配</strong>
												</p>
												<p>
													为了理解动态 inode 分配，还是需要借助 ext2/3 。下表列举了 ext2 文件系统的限制：
												</p>
												<h5>表 1. ext2 限制</h5>
												<div>
													<table style="width: 941px;" cellspacing="0" cellpadding="0" border="0">
														<thead>
															<tr class="firstRow">
																<th style="vertical-align: top; width: 161px;" rowspan="1" colspan="1">
																	<br/>
																</th>
																<th style="text-align: left; vertical-align: top; width: 700px;" rowspan="1" colspan="1">
																	限制
																</th>
															</tr>
														</thead>
														<tbody>
															<tr>
																<td style="text-align:left; vertical-align:middle">
																	<strong>最大文件数量</strong>
																</td>
																<td style="text-align:left; vertical-align:top">
																	文件系统空间大小 V / 8192
																	<br/>
																	比如 100G 大小的文件系统中，能创建的文件个数最大为 131072
																</td>
															</tr>
														</tbody>
													</table>
												</div>
												<p>
													图 4 显示了 ext2 的磁盘布局：
												</p>
												<h5>图 4. ext2 layout</h5>
												<img src="./refs/linux_btrfs/ext2_layout.jpg" alt="ext2 layout" width="376" height="200"/>
												<p>
													在 ext2 中 inode 区是被预先固定分配的，且大小固定，比如一个 100G 的分区中，inode table 区中只能存放 131072 个 inode，这就意味着不可能创建超过 131072 个文件，因为每一个文件都必须有一个唯一的 inode 。
												</p>
												<p>
													为了解决这个问题，必须动态分配 inode 。每一个 inode 只是 BTree 中的一个节点，用户可以无限制地任意插入新的 inode，其物理存储位置是动态分配的。所以 btrfs 没有对文件个数的限制。
												</p>
												<p>
													<strong>针对 SSD 的优化支持</strong>
												</p>
												<p>
													SSD 是固态存储 Solid State Disk 的简称。在过去的几十年中，CPU/RAM 等器件的发展始终遵循着摩尔定律，但硬盘 HDD 的读写速率却始终没有飞跃式的发展。磁盘 IO 始终是系统性能的瓶颈。
												</p>
												<p>
													SSD 采用 flash memory 技术，内部没有磁盘磁头等机械装置，读写速率大幅度提升。 flash memory 有一些不同于 HDD 的特性。 flash 在写数据之前必须先执行擦除操作；其次，flash 对擦除操作的次数有一定的限制，在目前的技术水平下，对同一个数据单元最多能进行约 100 万次擦除操作，因此，为了延长 flash 的寿命，应该将写操作平均到整个 flash 上。
												</p>
												<p>
													SSD 在硬件内部的微代码中实现了 wear leveling 等分布写操作的技术，因此系统无须再使用特殊的 MTD 驱动和 FTL 层。虽然 SSD 在硬件层面做了很多努力，但毕竟还是有限。文件系统针对 SSD 的特性做优化不仅能提高 SSD 的使用寿命，而且能提高读写性能。 Btrfs 是少数专门对 SSD 进行优化的文件系统。 btrfs 用户可以使用 mount 参数打开对 SSD 的特殊优化处理。
												</p>
												<p>
													Btrfs 的 COW 技术从根本上避免了对同一个物理单元的反复写操作。如果用户打开了 SSD 优化选项，btrfs 将在底层的块空间分配策略上进行优化：将多次磁盘空间分配请求聚合成一个大小为 2M 的连续的块。大块连续地址的 IO 能够让固化在 SSD 内部的微代码更好的进行读写优化，从而提高 IO 性能。
												</p>
												<h3>数据一致性相关的特性</h3>
												<p><strong>COW 事务</strong></p>
												<p>
													理解 COW 事务，必须首先理解 COW 和事务这两个术语。
												</p>
												<p>什么是 COW?</p>
												<p>所谓 COW，即每次写磁盘数据时，先将更新数据写入一个新的 block，当新数据写入成功之后，再更新相关的数据结构指向新 block 。</p>
												<p>什么是事务？</p>
												<p>COW 只能保证单一数据更新的原子性。但文件系统中很多操作需要更新多个不同的元数据，比如创建文件需要修改以下这些元数据：</p>
												<ol>
													<li><p>修改 extent tree，分配一段磁盘空间</p></li>
													<li><p>创建一个新的 inode，并插入 FS Tree 中</p></li>
													<li><p>增加一个目录项，插入到 FS Tree 中</p></li>
												</ol>
												<p>任何一个步骤出错，文件便不能创建成功，因此可以定义为一个事务。</p>
												<p>下面将演示一个 COW 事务。</p>
												<p>A 是 FS Tree 的根节点，新的 inode 的信息将被插入节点 C 。首先，btrfs 将 inode 插入一个新分配的 block C ’中，并修改上层节点 B，使其指向新的 block C ’；修改 B 也将引发 COW，以此类推，引发一个连锁反应，直到最顶层的 Root A 。当整个过程结束后，新节点 A ’变成了 FS Tree 的根。但此时事务并未结束，superblock 依然指向 A 。</p>
												<h5>图 5. COW transaction 1</h5>
												<img src="./refs/linux_btrfs/COW_transaction_1.jpg" alt="COW transaction 1" width="529" height="262"/>
												<p>接下来，修改目录项（E 节点），同样引发这一过程，从而生成新的根节点 A ’’。</p>
												<h5>图 6. COW transaction 2</h5>
												<img src="./refs/linux_btrfs/COW_transaction_2.jpg" alt="COW transaction 2" width="336" height="234"/>
												<p>此时，inode 和目录项都已经写入磁盘，可以认为事务已经结束。 btrfs 修改 superblock，使其指向 A ’’，如下图所示：</p>
												<h5>图 7. COW transaction 3</h5>
												<img src="./refs/linux_btrfs/COW_transaction_3.jpg" alt="COW transaction 3" width="376" height="248"/>
												<p>COW 事务能够保证文件系统的一致性，并且系统 Reboot 之后不需要执行 fsck 。因为 superblock 要么指向新的 A ’’，要么指向 A，无论哪个都是一致的数据。</p>
												<p><strong>Checksum</strong></p>
												<p>Checksum 技术保证了数据的可靠性，避免 silent corruption 现象。由于硬件原因，从磁盘上读出的数据会出错。比如 block A 中存放的数据为 0x55，但读取出来的数据变是 0x54，因为读取操作并未报错，所以这种错误不能被上层软件所察觉。</p>
												<p>解决这个问题的方法是保存数据的校验和，在读取数据后检查校验和。如果不符合，便知道数据出现了错误。</p>
												<p>ext2/3 没有校验和，对磁盘完全信任。而不幸的是，磁盘的错误始终存在，不仅发生在廉价的 IDE 硬盘上，昂贵的 RAID 也存在 silent corruption 问题。而且随着存储网络的发展，即使数据从磁盘读出正确，也很难确保能够安全地穿越网络设备。</p>
												<p>btrfs 在读取数据的同时会读取其相应的 checksum 。如果最终从磁盘读取出来的数据和 checksum 不相同，btrfs 会首先尝试读取数据的镜像备份，如果数据没有镜像备份，btrfs 将返回错误。写入磁盘数据之前，btrfs 计算数据的 checksum 。然后将 checksum 和数据同时写入磁盘。</p>
												<p>Btrfs 采用单独的 checksum Tree 来管理数据块的校验和，把 checksum 和 checksum 所保护的数据块分离开，从而提供了更严格的保护。假如在每个数据 block 的 header 中加入一个域保存 checksum，那么这个数据 block 就成为一个自己保护自己的结构。这种结构下有一种错误无法检测出来，比如本来文件系统打算从磁盘上读 block A，但返回了 block B，由于 checksum 在 block 内部，因此 checksum 依旧是正确的。 btrfs 采用 checksum tree 来保存数据块的 checksum，避免了上述问题。</p>
												<p>Btrfs 采用 crc32 算法计算 checksum，在将来的开发中会支持其他类型的校验算法。为了提高效率，btrfs 将写数据和 checksum 的工作分别用不同的内核线程并行执行。</p>
												<h3>多设备管理相关的特性</h3>
												<p>每个 Unix 管理员都曾面临为用户和各种应用分配磁盘空间的任务。多数情况下，人们无法事先准确地估计一个用户或者应用在未来究竟需要多少磁盘空间。磁盘空间被用尽的情况经常发生，此时人们不得不试图增加文件系统空间。传统的 ext2/3 无法应付这种需求。</p>
												<p>很多卷管理软件被设计出来满足用户对多设备管理的需求，比如 LVM 。 Btrfs 集成了卷管理软件的功能，一方面简化了用户命令；另一方面提高了效率。</p>
												<p><strong>多设备管理</strong></p>
												<p>Btrfs 支持动态添加设备。用户在系统中增加新的磁盘之后，可以使用 btrfs 的命令将该设备添加到文件系统中。</p>
												<p>为了灵活利用设备空间，Btrfs 将磁盘空间划分为多个 chunk 。每个 chunk 可以使用不同的磁盘空间分配策略。比如某些 chunk 只存放 metadata，某些 chunk 只存放数据。一些 chunk 可以配置为 mirror，而另一些 chunk 则可以配置为 stripe 。这为用户提供了非常灵活的配置可能性。</p>
												<p><strong>Subvolume</strong></p>
												<p>Subvolume 是很优雅的一个概念。即把文件系统的一部分配置为一个完整的子文件系统，称之为 subvolume 。</p>
												<p>采用 subvolume，一个大的文件系统可以被划分为多个子文件系统，这些子文件系统共享底层的设备空间，在需要磁盘空间时便从底层设备中分配，类似应用程序调用 malloc() 分配内存一样。可以称之为存储池。这种模型有很多优点，比如可以充分利用 disk 的带宽，可以简化磁盘空间的管理等。</p>
												<p>所谓充分利用 disk 的带宽，指文件系统可以并行读写底层的多个 disk，这是因为每个文件系统都可以访问所有的 disk 。传统的文件系统不能共享底层的 disk 设备，无论是物理的还是逻辑的，因此无法做到并行读写。</p>
												<p>所谓简化管理，是相对于 LVM 等卷管理软件而言。采用存储池模型，每个文件系统的大小都可以自动调节。而使用 LVM，如果一个文件系统的空间不够了，该文件系统并不能自动使用其他磁盘设备上的空闲空间，而必须使用 LVM 的管理命令手动调节。</p>
												<p>Subvolume 可以作为根目录挂载到任意 mount 点。 subvolume 是非常有趣的一个特性，有很多应用。</p>
												<p>假如管理员只希望某些用户访问文件系统的一部分，比如希望用户只能访问 /var/test/ 下面的所有内容，而不能访问 /var/ 下面其他的内容。那么便可以将 /var/test 做成一个 subvolume 。 /var/test 这个 subvolume 便是一个完整的文件系统，可以用 mount 命令挂载。比如挂载到 /test 目录下，给用户访问 /test 的权限，那么用户便只能访问 /var/test 下面的内容了。</p>
												<p>快照和克隆</p>
												<p>快照是对文件系统某一时刻的完全备份。建立快照之后，对文件系统的修改不会影响快照中的内容。这是非常有用的一种技术。</p>
												<p>比如数据库备份。假如在时间点 T1，管理员决定对数据库进行备份，那么他必须先停止数据库。备份文件是非常耗时的操作，假如在备份过程中某个应用程序修改了数据库的内容，那么将无法得到一个一致性的备份。因此在备份过程中数据库服务必须停止，对于某些关键应用这是不能允许的。</p>
												<p>利用快照，管理员可以在时间点 T1 将数据库停止，对系统建立一个快照。这个过程一般只需要几秒钟，然后就可以立即重新恢复数据库服务。此后在任何时候，管理员都可以对快照的内容进行备份操作，而此时用户对数据库的修改不会影响快照中的内容。当备份完成，管理员便可以删除快照，释放磁盘空间。</p>
												<p>快照一般是只读的，当系统支持可写快照，那么这种可写快照便被称为克隆。克隆技术也有很多应用。比如在一个系统中安装好基本的软件，然后为不同的用户做不同的克隆，每个用户使用自己的克隆而不会影响其他用户的磁盘空间。非常类似于虚拟机。</p>
												<p>Btrfs 支持 snapshot 和 clone 。这个特性极大地增加了 btrfs 的使用范围，用户不需要购买和安装昂贵并且使用复杂的卷管理软件。下面简要介绍一下 btrfs 实现快照的基本原理。</p>
												<p>如前所述 Btrfs 采用 COW 事务技术，从图 1-10 可以看到，COW 事务结束后，如果不删除原来的节点 A,C,E，那么 A,C,E,D,F 依然完整的表示着事务开始之前的文件系统。这就是 snapshot 实现的基本原理。</p>
												<p>Btrfs 采用引用计数决定是否在事务 commit 之后删除原有节点。对每一个节点，btrfs 维护一个引用计数。当该节点被别的节点引用时，该计数加一，当该节点不再被别的节点引用时，该计数减一。当引用计数归零时，该节点被删除。对于普通的 Tree Root, 引用计数在创建时被加一，因为 Superblock 会引用这个 Root block 。很明显，初始情况下这棵树中的所有其他节点的引用计数都为一。当 COW 事务 commit 时，superblock 被修改指向新的 Root A ’’，原来 Root block A 的引用计数被减一，变为零，因此 A 节点被删除。 A 节点的删除会引发其子孙节点的引用计数也减一，图 1-10 中的 B，C 节点的引用计数因此也变成了 0，从而被删除。 D,E 节点在 COW 时，因为被 A ’’所引用，计数器加一，因此计数器这时并未归零，从而没有被删除。</p>
												<p>创建 Snapshot 时，btrfs 将的 Root A 节点复制到 sA，并将 sA 的引用计数设置为 2 。在事务 commit 的时候，sA 节点的引用计数不会归零，从而不会被删除，因此用户可以继续通过 Root sA 访问 snapshot 中的文件。</p>
												<h5>图 8. Snapshot</h5>
												<img src="./refs/linux_btrfs/Snapshot.jpg" alt="Snapshot" width="489" height="263"/>
												<p><strong>软件 RAID</strong></p>
												<p>RAID 技术有很多非常吸引人的特性，比如用户可以将多个廉价的 IDE 磁盘组合为 RAID0 阵列，从而变成了一个大容量的磁盘； RAID1 和更高级的 RAID 配置还提供了数据冗余保护，从而使得存储在磁盘中的数据更加安全。</p>
												<p>Btrfs 很好的支持了软件 RAID，RAID 种类包括 RAID0,RAID1 和 RAID10.</p>
												<p>Btrfs 缺省情况下对 metadata 进行 RAID1 保护。前面已经提及 btrfs 将设备空间划分为 chunk，一些 chunk 被配置为 metadata，即只存储 metadata 。对于这类 chunk，btrfs 将 chunk 分成两个条带，写 metadata 的时候，会同时写入两个条带内，从而实现对 metadata 的保护。</p>
												<h3>其他特性</h3>
												<p>Btrfs 主页上罗列的其他特性不容易分类，这些特性都是现代文件系统中比较先进的技术，能够提高文件系统的时间或空间效率。</p>
												<p><strong>Delay allocation</strong></p>
												<p>延迟分配技术能够减少磁盘碎片。在 Linux 内核中，为了提高效率，很多操作都会延迟。</p>
												<p>在文件系统中，小块空间频繁的分配和释放会造成碎片。延迟分配是这样一种技术，当用户需要磁盘空间时，先将数据保存在内存中。并将磁盘分配需求发送给磁盘空间分配器，磁盘空间分配器并不立即分配真正的磁盘空间。只是记录下这个请求便返回。</p>
												<p>磁盘空间分配请求可能很频繁，所以在延迟分配的一段时间内，磁盘分配器可以收到很多的分配请求，一些请求也许可以合并，一些请求在这段延迟期间甚至可能被取消。通过这样的“等待”，往往能够减少不必要的分配，也有可能将多个小的分配请求合并为一个大的请求，从而提高 IO 效率。</p>
												<p><strong>Inline file</strong></p>
												<p>系统中往往存在大量的小文件，比如几百个字节或者更小。如果为其分配单独的数据 block，便会引起内部碎片，浪费磁盘空间。 btrfs 将小文件的内容保存在元数据中，不再额外分配存放文件数据的磁盘块。改善了内部碎片问题，也增加了文件的访问效率。</p>
												<h5>图 9. inline file</h5>
												<img src="./refs/linux_btrfs/inline_file.jpg" alt="inline file" width="538" height="239"/>
												<p>上图显示了一个 BTree 的叶子节点。叶子中有两个 extent data item 元数据，分别用来表示文件 file1 和 file2 所使用的磁盘空间。</p>
												<p>假设 file1 的大小仅为 15 个字节； file2 的大小为 1M 。如图所示，file2 采用普通的 extent 表示方法：extent2 元数据指向一段 extent，大小为 1M，其内容便是 file2 文件的内容。</p>
												<p>而对于 file1， btrfs 会把其文件内容内嵌到元数据 extent1 中。如果不采用 inline file 技术。如虚线所示，extent1 指向一个最小的 extent，即一个 block，但 file1 有 15 个字节，其余的空间便成为了碎片空间。</p>
												<p>采用 inline 技术，读取 file1 时只需要读取元数据 block，而无需先读取 extent1 这个元数据，再读取真正存放文件内容的 block，从而减少了磁盘 IO 。</p>
												<p>得益于 inline file 技术，btrfs 处理小文件的效率非常高，也避免了磁盘碎片问题。</p>
												<p><strong>目录索引 Directory index</strong></p>
												<p>当一个目录下的文件数目巨大时，目录索引可以显著提高文件搜索时间。 Btrfs 本身采用 BTree 存储目录项，所以在给定目录下搜索文件的效率是非常高的。</p>
												<p>然而，btrfs 使用 BTree 管理目录项的方式无法同时满足 readdir 的需求。 readdir 是 POSIX 标准 API，它要求返回指定目录下的所有文件，并且特别的，这些文件要按照 inode number 排序。而 btrfs 目录项插入 BTree 时的 Key 并不是 Inode number，而是根据文件名计算的一个 hash 值。这种方式在查找一个特定文件时非常高效，但却不适于 readdir 。为此，btrfs 在每次创建新的文件时，除了插入以 hash 值为 Key 的目录项外，还同时插入另外一种目录项索引，该目录项索引的 KEY 以 sequence number 作为 BTree 的键值。这个 sequence number 在每次创建新文件时线性增加。因为 Inode number 也是每次创建新文件时增加的，所以 sequence number 和 inode number 的顺序相同。以这种 sequence number 作为 KEY 在 BTree 中查找便可以方便的得到一个以 inode number 排序的文件列表。</p>
												<p>另外以 sequence number 排序的文件往往在磁盘上的位置也是相邻的，所以以 sequence number 为序访问大量文件会获得更好的 IO 效率。</p>
												<p>压缩</p>
												<p>大家都曾使用过 zip，winrar 等压缩软件，将一个大文件进行压缩可以有效节约磁盘空间。 Btrfs 内置了压缩功能。</p>
												<p>通常人们认为将数据写入磁盘之前进行压缩会占用很多的 CPU 计算时间，必然降低文件系统的读写效率。但随着硬件技术的发展，CPU 处理时间和磁盘 IO 时间的差距不断加大。在某些情况下，花费一定的 CPU 时间和一些内存，但却能大大节约磁盘 IO 的数量，这反而能够增加整体的效率。</p>
												<p>比如一个文件不经过压缩的情况下需要 100 次磁盘 IO 。但花费少量 CPU 时间进行压缩后，只需要 10 次磁盘 IO 就可以将压缩后的文件写入磁盘。在这种情况下，IO 效率反而提高了。当然，这取决于压缩率。目前 btrfs 采用 zlib 提供的 DEFALTE/INFLATE 算法进行压缩和解压。在将来，btrfs 应该可以支持更多的压缩算法，满足不同用户的不同需求。</p>
												<p>目前 btrfs 的压缩特性还存在一些不足，当压缩使能后，整个文件系统下的所有文件都将被压缩，但用户可能需要更细粒度的控制，比如针对不同的目录采用不同的压缩算法，或者禁止压缩。我相信，btrfs 开发团队将在今后的版本中解决这个问题。</p>
												<p>对于某些类型的文件，比如 jpeg 文件，已经无法再进行压缩。尝试对其压缩将纯粹浪费 CPU 。为此，当对某文件的若干个 block 压缩后发现压缩率不佳，btrfs 将不会再对文件的其余部分进行压缩操作。这个特性在某种程度上提高了文件系统的 IO 效率。</p>
												<p>预分配</p>
												<p>很多应用程序有预先分配磁盘空间的需要。他们可以通过 posix_fallocate 接口告诉文件系统在磁盘上预留一部分空间，但暂时并不写入数据。如果底层文件系统不支持 fallocate，那么应用程序只有使用 write 预先写一些无用信息以便为自己预留足够的磁盘空间。</p>
												<p>由文件系统来支持预留空间更加有效，而且能够减少磁盘碎片，因为所有的空间都是一次分配，因而更有可能使用连续的空间。 Btrfs 支持 posix_fallocate 。</p>
												<h3>总结</h3>
												<p>至此，我们对 btrfs 的很多特性进行了较为详细的探讨，但 btrfs 能提供的特性却并不止这些。 btrfs 正处于试验开发阶段，还将有更多的特性。</p>
												<p>Btrfs 也有一个重要的缺点，当 BTree 中某个节点出现错误时，文件系统将失去该节点之下的所有的文件信息。而 ext2/3 却避免了这种被称为”错误扩散”的问题。</p>
												<p>但无论怎样，希望您和我一样，开始认同 btrfs 将是 Linux 未来最有希望的文件系统。</p>
												<h2>BTRFS 使用简介</h2>
												<p>了解了 btrfs 的特性，想必您一定想亲身体验一下 btrfs 的使用。本章将简要介绍如何使用 btrfs 。</p>
												<h3>创建文件系统</h3>
												<p>mkfs.btrfs 命令建立一个 btrfs 格式的文件系统。可以用如下命令在设备 sda5 上建立一个 btrfs 文件系统，并将其挂载到 /btrfsdisk 目录下：</p>
												<div>
													<table cellspacing="0" cellpadding="0" border="0">
														<tbody>
															<tr class="firstRow">
																<td>
																	<div>1</div>
																	<div>2</div>
																	<div>3</div>
																</td>
																<td>
																	<div>
																		<div>
																			<code>#mkfs.btrfs /dev/sda5 </code>
																		</div>
																		<div>
																			<code>&nbsp;</code>
																			<code>#mkdir /btrfsdisk </code>
																		</div>
																		<div>
																			<code>&nbsp;</code>
																			<code>#mount – t btrfs /dev/sda5 /btrfsdisk</code>
																		</div>
																	</div>
																</td>
															</tr>
														</tbody>
													</table>
												</div>
												<p>这样一个 Btrfs 就在设备 sda5 上建立好了。值得一提的是在这种缺省情况下，即使只有一个设备，Btrfs 也会对 metadata 进行冗余保护。如果有多个设备，那么您可以在创建文件系统的时候进行 RAID 设置。详细信息请参见后续的介绍。</p>
												<p>这里介绍其他几个 mkfs.btrfs 的参数。</p>
												<p>Nodesize 和 leafsize 用来设定 btrfs 内部 BTree 节点的大小，缺省为一个 page 大小。但用户也可以使用更大的节点，以便增加 fanout，减小树的高度，当然这只适合非常大的文件系统。</p>
												<p>Alloc-start 参数用来指定文件系统在磁盘设备上的起始地址。这使得用户可以方便的预留磁盘前面的一些特殊空间。</p>
												<p>Byte-count 参数设定文件系统的大小，用户可以只使用设备的一部分空间，当空间不足时再增加文件系统大小。</p>
												<h3>修改文件系统的大小</h3>
												<p>
													当文件系统建立好之后，您可以修改文件系统的大小。 /dev/sda5 挂载到了 /btrfsdisk 下，大小为 800M 。假如您希望只使用其中的 500M，则需要减小当前文件系统的大小，这可以通过如下命令实现：
												</p>
												<div>
													<table cellspacing="0" cellpadding="0" border="0">
														<tbody>
															<tr class="firstRow">
																<td>
																	<div>1</div>
																	<div>2</div>
																	<div>3</div>
																	<div>4</div>
																	<div>5</div>
																	<div>6</div>
																	<div>7</div>
																	<div>8</div>
																	<div>9</div>
																</td>
																<td>
																	<div>
																		<div>
																			<code>#df </code>
																		</div>
																		<div>
																			<code>&nbsp;</code>
																			<code>
																				Filesystem&nbsp;&nbsp; 1K-blocks&nbsp;&nbsp;&nbsp;&nbsp; Used&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Available&nbsp;&nbsp; Use%&nbsp;&nbsp; Mounted on
																			</code>
																		</div>
																		<div>
																			<code>&nbsp;</code>
																			<code>/dev/sda1&nbsp;&nbsp;&nbsp; 101086&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 19000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 76867&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 20%&nbsp;&nbsp;&nbsp;&nbsp; /boot </code>
																		</div>
																		<div>
																			<code>&nbsp;</code>
																			<code>/dev/sda5&nbsp;&nbsp;&nbsp; 811248&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 811216&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1%&nbsp;&nbsp;&nbsp;&nbsp; /btrfsdisk </code>
																		</div>
																		<div>
																			<code>&nbsp;</code>
																			<code>#btrfsctl – r -300M /btrfsdisk </code>
																		</div>
																		<div>
																			<code>&nbsp;</code>
																			<code>#df </code>
																		</div>
																		<div>
																			<code>&nbsp;</code>
																			<code>Filesystem&nbsp; 1K-blocks&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Used&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Available&nbsp;&nbsp; Use%&nbsp;&nbsp; Mounted on </code>
																		</div>
																		<div>
																			<code>&nbsp;</code>
																			<code>/dev/sda1&nbsp;&nbsp;&nbsp; 101086&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 19000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 76867&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 20%&nbsp;&nbsp;&nbsp;&nbsp; /boot </code>
																		</div>
																		<div>
																			<code>&nbsp;</code>
																			<code>/dev/sda5&nbsp;&nbsp;&nbsp; 504148&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 504106&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1%&nbsp;&nbsp;&nbsp;&nbsp; /btrfsdisk</code>
																		</div>
																	</div>
																</td>
															</tr>
														</tbody>
													</table>
												</div>
												<p>同样的，您可以使用 btrfsctl 命令增加文件系统的大小。</p>
												<h3>创建 Snapshot</h3>
												<p>下面的例子中，创建快照 snap1 时系统存在 2 个文件。创建快照之后，对 test1 的内容进行修改。再回到 snap1，打开 test1 文件，可以看到 test1 的内容依旧是之前的内容。</p>
												<div>
													<table cellspacing="0" cellpadding="0" border="0">
														<tbody>
															<tr class="firstRow">
																<td>
																	<div>1</div>
																	<div>2</div>
																	<div>3</div>
																	<div>4</div>
																	<div>5</div>
																	<div>6</div>
																	<div>7</div>
																	<div>8</div>
																	<div>9</div>
																	<div>10</div>
																</td>
																<td>
																	<div>
																		<div>
																			<code>#ls /btrfsdisk </code>
																		</div>
																		<div>
																			<code>&nbsp;</code>
																			<code>test1 test2 </code>
																		</div>
																		<div>
																			<code>&nbsp;</code>
																			<code>#vi test1 </code>
																		</div>
																		<div>
																			<code>&nbsp;</code>
																			<code>This is a test </code>
																		</div>
																		<div>
																			<code>&nbsp;</code>
																			<code>#btrfsctl – s snap1 /btrfsdisk </code>
																		</div>
																		<div>
																			<code>&nbsp;</code>
																			<code>#vi test1 </code>
																		</div>
																		<div>
																			<code>&nbsp;</code>
																			<code>Test1 is modified </code>
																		</div>
																		<div>
																			<code>&nbsp;</code>
																			<code>#cd /btrfsdisk/snap1 </code>
																		</div>
																		<div>
																			<code>&nbsp;</code>
																			<code>#cat test1 </code>
																		</div>
																		<div>
																			<code>&nbsp;</code>
																			<code>This is a test</code>
																		</div>
																	</div>
																</td>
															</tr>
														</tbody>
													</table>
												</div>
												<p>可以从上面的例子看到，快照 snap1 保存的内容不会被后续的写操作所改变。</p>
												<h3>创建 subvolume</h3>
												<p>使用 btrfs 命令，用户可以方便的建立 subvolume 。假设 /btrfsdisk 已经挂载到了 btrfs 文件系统，则用户可以在这个文件系统内创建新的 subvolume 。比如建立一个 /sub1 的 subvolume，并将 sub1 挂载到 /mnt/test 下：</p>
												<div>
													<table cellspacing="0" cellpadding="0" border="0">
														<tbody>
															<tr class="firstRow">
																<td>
																	<div>1</div>
																	<div>2</div>
																	<div>3</div>
																</td>
																<td>
																	<div>
																		<div>
																			<code>#mkdir /mnt/test </code>
																		</div>
																		<div>
																			<code>&nbsp;</code>
																			<code>#btrfsctl – S sub1 /btrfsdisk </code>
																		</div>
																		<div>
																			<code>&nbsp;</code>
																			<code>#mount – t btrfs – o subvol=sub1 /dev/sda5 /mnt/test</code>
																		</div>
																	</div>
																</td>
															</tr>
														</tbody>
													</table>
												</div>
												<p>
													<code>
														Subvolme 可以方便管理员在文件系统上创建不同用途的子文件系统，并对其进行一些特殊的配置，比如有些目录下的文件关注节约磁盘空间，因此需要打开压缩，或者配置不同的 RAID 策略等。目前 btrfs 尚处于开发阶段，创建的 subvolme 和 snapshot 还无法删除。此外针对 subvolume 的磁盘 quota 功能也未能实现。但随着 btrfs 的不断成熟，这些功能必然将会进一步完善。
													</code>
												</p>
												<h3><code>创建 RAID</code></h3>
												<p>
													<code>
														mkfs 的时候，可以指定多个设备，并配置 RAID 。下面的命令演示了如何使用 mkfs.btrfs 配置 RAID1 。 Sda6 和 sda7 可以配置为 RAID1，即 mirror 。用户可以选择将数据配置为 RAID1，也可以选择将元数据配置为 RAID1 。
													</code>
												</p>
												<p>
													<code>将数据配置为 RAID1，可以使用 mkfs.btrfs 的 -d 参数。如下所示：</code>
												</p>
												<code>
													<div>
														<table cellspacing="0" cellpadding="0" border="0">
															<tbody>
																<tr class="firstRow">
																	<td>
																		<div>1</div>
																		<div>2</div>
																	</td>
																	<td>
																		<div>
																			<div>
																				<code>#mkfs.btrfs – d raid1 /dev/sda6 /dev/sda7 </code>
																			</div>
																			<div>
																				<code>&nbsp;</code>
																				<code>#mount – t btrfs /dev/sda6 /btrfsdisk</code>
																			</div>
																		</div>
																	</td>
																</tr>
															</tbody>
														</table>
													</div>
													<h3>添加新设备</h3>
													<p>当设备的空间快被使用完的时候，用户可以使用 btrfs-vol 命令为文件系统添加新的磁盘设备，从而增加存储空间。下面的命令向 /btrfsdisk 文件系统增加一个设备 /sda8</p>
													<div>
														<table cellspacing="0" cellpadding="0" border="0">
															<tbody>
																<tr class="firstRow">
																	<td>
																		<div>1</div>
																	</td>
																	<td>
																		<div>
																			<div>
																				<code>#btrfs-vol – a /dev/sda8 /btrfsdisk</code>
																			</div>
																		</div>
																	</td>
																</tr>
															</tbody>
														</table>
													</div>
													<h3>SSD 支持</h3>
													<p>用户可以使用 mount 参数打开 btrfs 针对 SSD 的优化。命令如下：</p>
													<div>
														<table cellspacing="0" cellpadding="0" border="0">
															<tbody>
																<tr class="firstRow">
																	<td>
																		<div>1</div>
																	</td>
																	<td>
																		<div>
																			<div>
																				<code>#mount – t btrfs – o SSD /dev/sda5 /btrfsdisk</code>
																			</div>
																		</div>
																	</td>
																</tr>
															</tbody>
														</table>
													</div>
													<p>
														<strong><em>开启压缩功能</em></strong>
													</p>
													<p>
														<code>用户可以使用 mount 参数打开压缩功能。命令如下：</code>
													</p>
													<code>
														<div>
															<table cellspacing="0" cellpadding="0" border="0">
																<tbody>
																	<tr class="firstRow">
																		<td>
																			<div>1</div>
																		</td>
																		<td>
																			<div>
																				<div>
																					<code>#mount – t btrfs – o compress /dev/sda5 /btrfsdisk</code>
																				</div>
																			</div>
																		</td>
																	</tr>
																</tbody>
															</table>
														</div>
														<p><strong><em>同步文件系统</em></strong></p>
														<p><code>为了提高效率，btrfs 的 IO 操作由一些内核线程异步处理。这使得用户对文件的操作并不会立即反应到磁盘上。您可以做一个实验，在 btrfs 上创建一个文件后，稍等 5 到 10 秒将系统电源切断，再次重启后，新建的文件并没有出现。</code></p>
														<p><code>对于多数应用这并不是问题，但有些时候用户希望 IO 操作立即执行，此时就需要对文件系统进行同步。下面的 btrfs 命令用来同步文件系统：</code></p>
														<code>
															<div>
																<table cellspacing="0" cellpadding="0" border="0">
																	<tbody>
																		<tr class="firstRow">
																			<td>
																				<div>1</div>
																			</td>
																			<td>
																				<div>
																					<div>
																						<code>#btrfsctl – c /btrfsdisk</code>
																					</div>
																				</div>
																			</td>
																		</tr>
																	</tbody>
																</table>
															</div>
															<h3>Debug 功能</h3>
															<p>Btrfs 提供了一定的 debug 功能，对于想了解 Btrfs 内部实现原理的读者，debug 将是您最喜欢的工具。这里简单介绍一下 debug 功能的命令使用。</p>
															<p>下面的命令将设备 sda5 上的 btrfs 文件系统中的元数据打印到屏幕上。</p>
															<div>
																<table cellspacing="0" cellpadding="0" border="0">
																	<tbody>
																		<tr class="firstRow">
																			<td>
																				<div>1</div>
																			</td>
																			<td>
																				<div>
																					<div>
																						<code>#btrfs-debug-tree /dev/sda5</code>
																					</div>
																				</div>
																			</td>
																		</tr>
																	</tbody>
																</table>
															</div>
															<p><code>通过对打印信息的分析，您将能了解 btrfs 内部各个 BTree 的变化情况，从而进一步理解每一个文件系统功能的内部实现细节。</code></p>
															<p><code>比如您可以在创建一个文件之前将 BTree 的内容打印出来，创建文件后再次打印。通过比较两次的不同来了解 btrfs 创建一个文件需要修改哪些元数据。进而理解 btrfs 内部的工作原理。</code></p>
														</code>
													</code>
												</code>
											</td>
										</tr>
									</tbody>
								</table>
							</div>
						</div>
					</div>
				</div>
			</section>
			<section>
				<h3>查看文件的inode</h3>
				<div>
					<span class="shell_instruction">ls -i file_path</span>
					<br/>
					其中file_path为文件的路径, 也可以在文件所在的路径下直接
					<br/>
					<span class="shell_instruction">ls -i</span>
				</div>
			</section>
			<section>
				<h3>通过文件的inode来查找文件</h3>
				<div>
					<span class="shell_instruction">find / -inum file_inode</span>
					<br/>
					其中/为根路径, file_inode为文件的inode
				</div>
			</section>
			<section>
				<h3>查找一个文件的所有硬链接</h3>
				<div>
					先查看文件的inode
					<br/>
					在根路径下通过文件的inode进行查找
				</div>
			</section>
			<section>
				<h3>笔记本触摸板鼠标</h3>
				<div>
					开启触摸板鼠标
					<br/>
					<span class="shell_instruction">synclient touchpadoff=0</span>
					<br/>
					关闭触摸板鼠标
					<br/>
					<span class="shell_instruction">synclient touchpadoff=1</span>
				</div>
			</section>
			<section>
				<h3>修改用户账号, 如锁定解锁等The usermod command modifies the system account files to reflect the changes that are specified on the command line</h3>
				<div>
					当用户密码输入错误次数过多时用户会被锁定
					<br/>
					解锁用户密码
					<br/>
					<span class="shell_instruction">usermod -U username</span>
					<br/>
					锁定用户密码
					<br/>
					<span class="shell_instruction">usermod -U username</span>
				</div>
			</section>
			<section>
				<h3>截屏</h3>
				<div>
					gnome-screenshot软件的默认截屏图片存放在~/Pictures/下
					<br/>
					全屏截图不含鼠标:<span class="shell_instruction">gnome-screenshot</span>
					<br/>
					全屏截图含鼠标:<span class="shell_instruction">gnome-screenshot -p</span>
					<br/>
					截取鼠标选定区域:<span class="shell_instruction">gnome-screenshot -a</span>执行后会等待鼠标选择区域, 在要选择的区域的一个角处鼠标点下别松开然后移动到对着的另一个角松开鼠标, 选择完成后即截取完成.
					<br/>
					截取当前窗口:<span class="shell_instruction">gnome-screenshot -w</span>
					<br/>
					截取当前去除边框的窗口:<span class="shell_instruction">gnome-screenshot -w -B</span>
					<br/>
					截取当前窗口并换边框:<span class="shell_instruction">gnome-screenshot -wB -e border</span>用其中的B参数去掉边框再用e参数添加border样式的边框
					<br/>
					延迟截取选定窗口:<span class="shell_instruction">gnome-screenshot -d 5</span>延迟5秒后截取活动窗口
					<br/>
					打开gnome-screenshot软件图形化界面:<span class="shell_instruction">gnome-screenshot -i</span>
				</div>
			</section>
			<section>
				<h3>systemctl</h3>
				<div>
					<a target="_blank" href="https://www.cnblogs.com/zwcry/p/9602756.html">linux systemctl 指令 —— 阮一峰 - 七脉 - 博客园</a>
				</div>
			</section>
			<section>
				<h3>tmpfs, ramfs</h3>
				<div>
					tmpfs与ramfs类似, 挂载方式相似，区别如下:
					<br/>
					<br/>
					tmpfs是虚拟内存文档系统，数据存储在物理内存和交换分区(swap)。在Linux内核中，虚拟内存资源由物理内存（RAM）和交换分区组成，这些资源是由内核中的虚拟内存子系统来负责分配和管理。
					<br/>
					大小不会自动增加, 挂载的目录大小受到限制保护，即往里写入数据不会超出限定的大小, 默认权限设置任何用户均可使用
					<br/>
					<br/>
					ramfs是内存文档系统，工作于虚拟文档系统（VFS）层， 数据存储于物理内存中。
					<br/>
					大小自动增加, 挂载的目录指定大小无效，即往里写入数据会超出限定的大小, 直到内存耗尽，系统挂起, 默认权限设置只有root用户能够使用
					<br/>
					例如通过命令挂载时指定大小为1M
					<br/>
					<span class="shell_instruction">mount -t ramfs -o size=1M ramfs my_ramfs_dir</span>
					<br/>
					写入5M的数据
					<br/>
					<span class="shell_instruction">dd if=/dev/zero of=my_ramfs_div/size_test.txt bs=1M count=5</span>
					<br/>
					执行结果为成功
				</div>
			</section>
			<section>
				<h3>mount --bind 绑定挂载目录</h3>
				<div>
					将source_div目录绑定挂载到target_dir目录
					<br/>
					<span class="shell_instruction">mount --bind source_dir target_dir</span>
					<br/>
					执行后操作target_dir下的内容即为source_dir的内容, 相当与把source_dir文件(在linux中把设备如硬盘等设备均看作文件)挂载到target_dir目录下, 也类似于建立了一个硬链接
				</div>
			</section>
			<section>
				<h3>mount指定分区大小</h3>
				<div>
					<span class="shell_instruction">mount -t tmpfs -o size=4096M tmpfs ./tmp</span>
					<br/>
					其中size=4096M 为4096MB
					<br/>
					<span class="shell_instruction">mount -t tmpfs -o remount,size=80% tmpfs /dev/shm</span>
					<br/>
					size=80%为设置大小为内存的80%
				</div>
			</section>
			<section>
				<h3>/etc/fstab指定分区大小</h3>
				<div>
					tmpfs /dev/shm tmpfs defaults,size=4096M 0 0
					<br/>
					其中size=4096M 为4096MB
				</div>
			</section>
			<section>
				<h3>U盘写入文件Read-only file system错误</h3>
				<div>
					可以查看/proc/mounts文件是否U盘挂载为只读, 若有参数ro则为只读, rw为读写
					<br/>
					用如下命令重新挂载即可
					<br/>
					<span class="shell_instruction">mount -o remount -rw  usb_path/</span>
					<br/>
					其中usb_path/为U盘的挂载路径, -rw为读写
				</div>
			</section>
			<section>
				<h3>压缩</h3>
				<p>
					zip,unzip
					<br/>
					举例:将 archive1 文件夹和 archive2 文件夹压缩到 archive.zip 文件
					<br/>
					<span class="shell_instruction">zip -r archive.zip archive1 archive2</span>
					<br/>
					-r表示递归压缩, 即将子目录递归压缩不是只将第一层的文件压缩到压缩文件中
					<br/>
					举例:将 archive1 文件夹和 archive2 文件夹压缩到 archive.zip 文件, 并指定压缩率
					<br/>
					<span class="shell_instruction">zip -r -0 archive.zip archive1 archive2</span>
					<br/>
					-0表示不压缩直接存储, 速度最快，最高可到-9，-9表示压缩率最高但速度最慢
					<br/>
					举例:将上例中的 archive.zip 解压缩
					<br/>
					<span class="shell_instruction">unzip archive.zip</span>
					<br/>
					<a target="_blank" href="https://sourceforge.net/projects/p7zip/files/p7zip/16.02">p7zip</a>
				</p>
			</section>
			<section>
				<h3>tar過濾部分文件打包</h3>
				<p>
					<a target="_blank" href="refs/tar__exclude_file.pdf">參考文檔</a>
					<br/>
					举例:将 archive1 文件夹和 archive2 文件夹归档到文件 archive.tar 文件中并且过滤掉文件名以.swo和.swp结尾的文件不添加到归档文件中
					<br/>
					<span class="shell_instruction">tar -cf archive.tar --exclude=.*.sw[op] archive1 archive2</span>
					<br/>
					举例:将上例中的 archive.tar 展开, 恢复到多文件状态
					<br/>
					<span class="shell_instruction">tar -xf archive.tar</span>
					<br/>
				</p>
			</section>
			<section>
				<h3>查看Linux内核版本的命令</h3>
				<p>
					<span class="shell_instruction">uname -a</span>
					<br/>
					查看系统内核版本号及系统名称
					<br/>
					or
					<br/>
					<span class="shell_instruction">cat /proc/version</span>
					<br/>
					查看目录"/proc"下version的信息，也可以得到当前系统的内核版本号及系统名称
					<br/>
					补充说明:/proc文件系统，它不是普通的文件系统，而是系统内核的映像，也就是说，该目录中的文件是存放在系统内存之中的，它以文件系统的方式为访问系统内核数 据的操作提供接口。而我们使用命令“uname -a"的信息就是从该文件获取的，当然用方法二的命令直接查看它的内容也可以达到同等效果.另外，加上参数"a"是获得详细信息，如果不加参数为查看系统名称。
				</p>
			</section>
			<section>
				<h3>關機及重啟</h3>
				<p>
					關機
					<br/>
					<span class="shell_instruction">poweroff</span>
					<br/>
					or
					<br/>
					<span class="shell_instruction">shutdown -P now</span>
					<br/>
					or
					<br/>
					<span class="shell_instruction">shutdown -h now</span>
					<br/>
					或參考
					<br/>
					<span class="shell_instruction">man shutdown</span>
					<br/>
					10分鐘後關機
					<br/>
					<span class="shell_instruction">shutdown -h +10</span>
					<br/>
					18:30關機
					<br/>
					<span class="shell_instruction">shutdown -h 18:30</span>
					<br/>


					<br/>
					<br/>
					重啟
					<br/>
					<span class="shell_instruction">reboot</span>
					<br/>
					or
					<br/>
					<span class="shell_instruction">shutdown -r now</span>
					<br/>
					或參考
					<br/>
					<span class="shell_instruction">man shutdown</span>
					<br/>
					10分鐘後重啟
					<br/>
					<span class="shell_instruction">shutdown -r +10</span>
					<br/>
					18:30重啟
					<br/>
					<span class="shell_instruction">shutdown -r 18:30</span>
				</p>
			</section>
			<section>
				<h3>ctrl+z(挂起),jobs(任务),fg(前台),bg(后台),kill(终止进程), ps(显示进程)</h3>
				<div>
					ctrl+z
					<br/>
					ctrl+z挂起前台命令暂停执行，回到shell命令行环境中
					<br/>
					<br/>
				</div>
				<div>
					jobs
					<br/>
					察看当前shell下运行的所有程序；带+表示最新的jobs；带-表示次新的jobs；其他jobs不带符号
					<br/>
					<br/>
				</div>
				<div>
					bg %n
					<br/>
					将第n个job放到后台运行
					<br/>
					<br/>
				</div>
				<div>
					bg
					<br/>
					将最后挂起的命令放到后台运行
					<br/>
					<br/>
				</div>
				<div>
					fg %n
					<br/>
					将第n个job返回前台运行
					<br/>
					<br/>
				</div>
				<div>
					fg
					<br/>
					将最后挂起的命令返回前台运行
					<br/>
					<br/>
				</div>
				<div>
					kill %n
					<br/>
					杀死第n个job，不再执行
					<br/>
					<br/>
				</div>
				<div>
					nohup 英文全称 no hang up（不挂起），用于在系统后台不挂断地运行命令，退出终端不会影响程序的运行。
					<br/>
					nohup 命令，在默认情况下（非重定向时），会输出一个名叫 nohup.out 的文件到当前目录下，如果当前目录的 nohup.out 文件不可写，输出重定向到 $HOME/nohup.out 文件中。
					<br/>
					nohup /root/longtimerun.sh &gt; longtimerun.log 2&gt;&amp;1 &amp;
					<br/>
					2&gt;&amp;1 解释:
					<br/>
					将标准错误 2 重定向到标准输出 &amp;1 ，标准输出 &amp;1 再被重定向输入到 longtimerun.log 文件中
					<br/>
					0 – stdin (standard input，标准输入)
					<br/>
					1 – stdout (standard output，标准输出)
					<br/>
					2 – stderr (standard error，标准错误输出)
					<br/>
					<br/>
				</div>
				<div>
					ps显示当前的进程
					<br/>
					<span class="shell_instruction">ps -ef | grep vim</span>
					<br/>
					显示所有进程并用管道从结果中查找含有vim字符串的程序
					<br/>
					参数:
					<br/>
					-e 全部进程
					<br/>
					-r 只显示当前正在运行的进程
					<br/>
					-f 显示全格式
					<br/>
					<br/>
				</div>
			</section>
			<section>
				<h3>mount -o loop</h3>
				<div>
					THE LOOP DEVICE
					<br/>
					One further possible type is a mount via the loop device.  For example, the command
					<br/>
					<span class="class___tab_place"></span>mount /tmp/disk.img /mnt -t vfat -o loop=/dev/loop3
					<br/>
					will set up the loop device /dev/loop3 to correspond to the file /tmp/disk.img, and then mount this device on /mnt.
					<br/>
					If no explicit loop device is mentioned (but just an option `-o loop' is given), then mount will try to find some unused loop device and use that, for example
					<br/>
					<span class="class___tab_place"></span>mount /tmp/disk.img /mnt -o loop
					<br/>
					The mount command automatically creates a loop device from a regular file if a filesystem type is not specified or the filesystem is known for libblkid, for example:
					<br/>
					<span class="class___tab_place"></span>mount /tmp/disk.img /mnt
					<br/>
					<span class="class___tab_place"></span>mount -t ext3 /tmp/disk.img /mnt
					<br/>
					This type of mount knows about three options, namely loop, offset and sizelimit, that are really options to losetup(8).  (These options can be used in addition to those specific  to  the  filesystem type.)
					<br/>
					Since Linux 2.6.25 auto-destruction of loop devices is supported, meaning that any loop device allocated by mount will be freed by umount independently of /etc/mtab.
					<br/>
					You can also free a loop device by hand, using losetup -d or umount -d.
					<br/>
					Since  util-linux  v2.29  mount  command re-uses the loop device rather than initialize a new device if the same backing file is already used for some loop device with the same offset and sizelimit.
					<br/>
					This is necessary to avoid a filesystem corruption.
				</div>
			</section>
			<section>
				<h3>创建iso文件</h3>
				<div>
					use mkisofs create iso file
					<br/>
					<span class="shell_instruction">mkisofs -r -o mongodb_linux_x86_64_4.0.7.iso mongodb_linux_x86_64_4.0.7.tgz</span>
					<br/>
					-r : 设置所有文件拥有读取权限
					<br/>
					-o : 在后面指定输出的iso文件的路径及文件名
					<br/>
					<br/>
					use dd copy device content to file
					<br/>
					<span class="shell_instruction">dd if=/dev/cdrom of=vcd.iso</span>
					<br/>
					if : 数据源块路径
					<br/>
					of : 输出文件的路径及文件名
					<br/>
					<a target="_blank" href="https://www.jb51.net/LINUXjishu/221537.html">linux 下制作可启动 img/iso 文件的方法_LINUX_操作系统_脚本之家</a>
					<div>
						<span style="display : inline-block; border : 1px solid black; width : 14px; text-align : center;">+</span><span>为防链接失效的本地截图</span>
						<div style="display:none;">
							<script>add_fold(document.currentScript);</script>
							<img src="./refs/imgs/linux下制作可启动img_iso文件的方法.png"/>
						</div>
					</div>
					<a target="_blank" href="https://blog.csdn.net/weixin_39916392/article/details/80727621">用linux制作iso镜像文件 - kaifeibandao - CSDN博客</a>
					<div>
						<span style="display : inline-block; border : 1px solid black; width : 14px; text-align : center;">+</span><span>为防链接失效的本地截图</span>
						<div style="display:none;">
							<script>add_fold(document.currentScript);</script>
							<img src="./refs/imgs/用linux制作iso镜像文件.png"/>
						</div>
					</div>
					<a target="_blank" href="https://www.linuxidc.com/Linux/2009-01/18225.htm">Linux下下打开ISO文件两种方法_Linux教程_Linux公社-Linux系统门户网站</a>
					<div>
						<span style="display : inline-block; border : 1px solid black; width : 14px; text-align : center;">+</span><span>为防链接失效的本地截图</span>
						<div style="display:none;">
							<script>add_fold(document.currentScript);</script>
							<img src="./refs/imgs/Linux下下打开ISO文件两种方法.png"/>
						</div>
					</div>
					<a target="_blank" href=""></a>
					<div>
						<span style="display : inline-block; border : 1px solid black; width : 14px; text-align : center;">+</span><span>为防链接失效的本地截图</span>
						<div style="display:none;">
							<script>add_fold(document.currentScript);</script>
							<img src="./refs/imgs/.png"/>
						</div>
					</div>
				</div>
			</section>
			<section>
				<h3>查看系统配置信息</h3>
				<div>
					#硬件信息
					<br/>
					dmidecode
					<br/>
					#模块信息
					<br/>
					dmesg
					<br/>
					#查看分区信息如uuid等
					<br/>
					blkid
					<br/>
					#查看外存及分区信息
					<br/>
					lsblk
					<br/>
					#查看usb设备
					<br/>
					lsusb
				</div>
			</section>
			<section>
				<h3>设置分区的标签</h3>
				<p>
					#ext2/ext3/ext4
					<br/>
					<span class="shell_instruction">e2label [&lt;device&gt;] [&lt;new_label&gt;]</span>
					<br/>
					#xfs
					<br/>
					<span class="shell_instruction">xfs_admin -L [&lt;new_label&gt;] [&lt;device&gt;]</span>
					<br/>
					#jfs
					<br/>
					<span class="shell_instruction">jfs_tune -L [&lt;new_label&gt;] [&lt;device&gt;]</span>
					<br/>
					#Btrfs
					<br/>
					<span class="shell_instruction">btrfs filesystem label [&lt;device&gt;] [&lt;new_label&gt;]</span>
					<br/>
					#or
					<br/>
					<span class="shell_instruction">btrfs-filesystem label [&lt;device&gt;|&lt;mountpoint&gt;] [&lt;new_label&gt;]</span>
					<br/>
					#ReiserFS
					<br/>
					<span class="shell_instruction">reiserfstune -l [&lt;new_label&gt;] [&lt;device&gt;]</span>
					<br/>
					#swap
					<br/>
					<span class="shell_instruction">mkswap -L [&lt;new_label&gt;] [&lt;device&gt;]</span>
					<br/>
					#ntfs
					<br/>
					<span class="shell_instruction">ntfslabel [&lt;device&gt;] [&lt;new_label&gt;]</span>
					<br/>
					#for example set sda5 label is home
					<br/>
					<span class="shell_instruction">ntfslabel /dev/sda7 home</span>
				</p>
			</section>
			<section>
				<h3>添加和删除用户</h3>
				<p>
					#添加用户angular4
					<br/>
					<span class="shell_instruction">adduser angular4</span>
					<br/>
					#添加用户组angular
					<br/>
					<span class="shell_instruction">groupadd angular</span>
					<br/>
					#设置用户angular4所在组为angular
					<br/>
					<span class="shell_instruction">usermod -g angular angular4</span>
					<br/>
					<br/>

					#查看用户组
					<br/>
					<span class="shell_instruction">vim /etc/group</span>
					<br/>
					#删除用户组
					<br/>
					<span class="shell_instruction">groupdel angular</span>
					<br/>
					<span class="shell_instruction">groupdel angular4</span>
					<br/>
					#删除用户
					<br/>
					<span class="shell_instruction">userdel angular4</span>
					<br/>
					<span class="shell_instruction">rm -rf /home/angular4</span>
					<br/>
					#if add this user again will got error
					<br/>
					#Creating mailbox file: File exists
					<br/>
					<span class="shell_instruction">find / -name angular4</span>
					<br/>
					#the result include /var/spool/mail/angular4
					<br/>
					<span class="shell_instruction">rm -rf /var/spool/mail/angular4</span>
					<br/>
					<br/>

					#set user password
					<br/>
					<span class="shell_instruction">passwd angular4</span>
					<br/>
					<br/>

					#delete user password
					<br/>
					<span class="shell_instruction">passwd -d angular4</span>
				</p>
			</section>
			<section>
				<h3>change run level</h3>
				<p>
					#before CentOS 7 is change /etc/inittab file, but from CentOS 7 is no longer use this, the new run level is in /usr/lib/systemd/system/*.target
					<br/>
					#see current run level
					<br/>
					<span class="shell_instruction">systemctl list-units --type=target</span>
					<br/>
					#change run level to 3 level is
					<br/>
					<span class="shell_instruction">systemctl isolate multi-user.target</span>
					<br/>
					#change default run level to 3 level is
					<br/>
					<span class="shell_instruction">systemctl set-default multi-user.target</span>
					<br/>
					#old run level with new target relation is
					<br/>
					<span style="color : blue">
						runlevel0.target -&gt; poweroff.target
						<br/>
						runlevel1.target -&gt; rescue.target
						<br/>
						runlevel2.target -&gt; multi-user.target
						<br/>
						runlevel3.target -&gt; multi-user.target
						<br/>
						runlevel4.target -&gt; multi-user.target
						<br/>
						runlevel5.target -&gt; graphical.target
						<br/>
						runlevel6.target -&gt; reboot.target
					</span>
					<br/>
					#can use the follow instruction to see all the target
					<br/>
					<span class="shell_instruction">ls -lh /usr/lib/systemd/system/*.target</span>
				</p>
			</section>
			<section>
				<h3>CentOS 7 suspend and hibernate</h3>
				<div>
					到S1状态
					<br/>
					<span class="shell_instruction">echo "standby" &gt; /sys/power/state</span>
					<br/>
					<br/>
					到S3状态
					<br/>
					<span class="shell_instruction">systemctl suspend</span>
					<br/>
					equal
					<br/>
					<span class="shell_instruction">echo "mem" &gt; /sys/power/state</span>
					<br/>
					<br/>
					到S4状态
					<br/>
					<span class="shell_instruction">systemctl hibernate</span>
					<br/>
					equal
					<br/>
					<span class="shell_instruction">echo "disk" &gt; /sys/power/state</span>
					<br/>
					参考内容:
					<br/>
					<a target="_blank" href="http://www.wowotech.net/linux_kenrel/suspend_and_resume.html">Linux电源管理(6)_Generic PM之Suspend功能</a>
					<a target="_blank" href="https://blog.csdn.net/feifei_csdn/article/details/80831373">【sys/power】freeze、standby、mem、disk四个电源状态_勿于浮沙筑高台-CSDN博客</a>
					<div>
						<span style="display : inline-block; border : 1px solid black; width : 14px; text-align : center;">+</span><span>为防链接失效的本地截图</span>
						<div style="display:none;">
							<script>add_fold(document.currentScript);</script>
							<div class="class___copy_other_people_content" style="white-space : pre;">
System Power Management Sleep States

(C) 2014 Intel Corp., Rafael J. Wysocki <rafael.j.wysocki@intel.com>

The kernel supports up to four system sleep states generically（一般）, although three
of them depend on the platform support code to implement（实行） the low-level details
for each state.

The states are represented by strings that can be read or written to the
/sys/power/state file.  Those strings may be "mem", "standby", "freeze" and
"disk", where the last three always represent(代表) Power-On Suspend (if supported待机),
Suspend-To-Idle（idle） and hibernation（冬眠） (Suspend-To-Disk), respectively（分别）.

The meaning of the "mem" string is controlled by the /sys/power/mem_sleep file.
It contains strings representing the available modes of system suspend that may
be triggered by writing "mem" to /sys/power/state.  These modes are "s2idle"
(Suspend-To-Idle), "shallow(浅睡)" (Power-On Suspend) and "deep" (Suspend-To-RAM).
The "s2idle" mode is always available, while the other ones are only available
if supported by the platform (if not supported, the strings representing them
are not present in /sys/power/mem_sleep).  The string representing the suspend
mode to be used subsequently(后来) is enclosed in square brackets.  Writing one of
the other strings present in /sys/power/mem_sleep to it causes the suspend mode
to be used subsequently to change to the one represented by that string.

Consequently, there are two ways to cause the system to go into the
Suspend-To-Idle sleep state.  The first one is to write "freeze" directly to
/sys/power/state.  The second one is to write "s2idle" to /sys/power/mem_sleep
and then to write "mem" to /sys/power/state.  Similarly, there are two ways
to cause the system to go into the Power-On Suspend sleep state (the strings to
write to the control files in that case are "standby(待机)" or "shallow" and "mem",
respectively) if that state is supported by the platform.  In turn, there is
only one way to cause the system to go into the Suspend-To-RAM state (write
"deep" into /sys/power/mem_sleep and "mem" into /sys/power/state).

The default suspend mode (ie. the one to be used without writing anything into
/sys/power/mem_sleep) is either "deep" (if Suspend-To-RAM is supported) or
"s2idle", but it can be overridden by the value of the "mem_sleep_default"
parameter in the kernel command line.

The properties of all of the sleep states are described below.


State:		Suspend-To-Idle
ACPI state:	S0
Label:		"s2idle" ("freeze")

This state is a generic, pure software, light-weight, system sleep state.
It allows more energy to be saved relative to runtime idle by freezing user
space and putting all I/O devices into low-power states (possibly
lower-power than available at run time), such that the processors can
spend more time in their idle states.

This state can be used for platforms without Power-On Suspend/Suspend-to-RAM
support, or it can be used in addition to Suspend-to-RAM to provide reduced
resume latency(延迟).  It is always supported.


State:		Standby / Power-On Suspend
ACPI State:	S1
Label:		"shallow" ("standby")

This state, if supported, offers moderate（中等）, though real, power savings, while
providing a relatively low-latency transition back to a working system.  No
operating state is lost (the CPU retains power), so the system easily starts up
again where it left off.

In addition to freezing user space and putting all I/O devices into low-power
states, which is done for Suspend-To-Idle too, nonboot CPUs are taken offline
and all low-level system functions are suspended during transitions into this
state.  For this reason, it should allow more energy to be saved relative to
Suspend-To-Idle, but the resume latency will generally be greater than for that
state.


State:		Suspend-to-RAM
ACPI State:	S3
Label:		"deep"

This state, if supported, offers significant（重大的） power savings as everything in the
system is put into a low-power state, except for memory, which should be placed
into the self-refresh mode to retain(保留) its contents.  All of the steps carried out
when entering Power-On Suspend are also carried out during transitions to STR.
Additional operations may take place depending on the platform capabilities.  In
particular, on ACPI systems the kernel passes control to the BIOS (platform
firmware) as the last step during STR transitions and that usually results in
powering down some more low-level components that aren't directly controlled by
the kernel.

System and device state is saved and kept in memory.  All devices are suspended
and put into low-power states.  In many cases, all peripheral(外围设备) buses lose power
when entering STR, so devices must be able to handle the transition back to the
"on" state.

For at least(最小的) ACPI, STR requires some minimal boot-strapping code to resume the
system from it.  This may be the case on other platforms too.


State:		Suspend-to-disk
ACPI State:	S4
Label:		"disk"

This state offers the greatest power savings, and can be used even in
the absence of low-level platform support for power management. This
state operates similarly to Suspend-to-RAM, but includes a final step
of writing memory contents to disk. On resume, this is read and memory
is restored to its pre-suspend state.

STD can be handled by the firmware or the kernel. If it is handled by
the firmware, it usually requires a dedicated partition that must be
setup via another operating system for it to use. Despite the
inconvenience, this method requires minimal work by the kernel, since
the firmware will also handle restoring memory contents on resume.

For suspend-to-disk, a mechanism called 'swsusp' (Swap Suspend) is used
to write memory contents to free swap space. swsusp has some restrictive
requirements, but should work in most cases. Some, albeit outdated,
documentation can be found in Documentation/power/swsusp.txt.
Alternatively, userspace can do most of the actual suspend to disk work,
see userland-swsusp.txt.

Once memory state is written to disk, the system may either enter a
low-power state (like ACPI S4), or it may simply power down. Powering
down offers greater savings, and allows this mechanism to work on any
system. However, entering a real low-power state allows the user to
trigger wake up events (e.g. pressing a key or opening a laptop lid).

- On (on)									S0 -  Working（s0的状态应该是freeze）

- Standby (standby)						S1 -  CPU and RAM are powered but not executed

- Suspend to RAM (mem)					S3 -  RAM is powered and the running content is saved to RAM

- Suspend to Disk，Hibernation (disk)			S4 -  All content is saved to Disk and power down

S1状态简称standby状态，此状态下CPU处于低功耗状态，并且没有数据保存到RAM或者disk中，此状态待机和恢复通常很快。

S3 aka STR(suspend to ram),挂起到内存，简称待机。计算机将目前的运行状态等数据存放在内存，关闭硬 盘、外设等设备，进入等待状态。此时内存仍然需要电力维持其数据，但整机耗电很少。恢复时计算机从内存读出数据，回到挂起前的状态，恢复速度较快。对 DDR的耗电情况进行优化是S3性能的关键，大多数手持设备都是用S3待机。此状态下计算机会冻结所有的活动并将当前工作状态保存到RAM中，然后关闭屏幕进入低功耗模式，通常睡眠和唤醒需要几秒

S4 aka STD(suspend to disk),挂起到硬盘，简称休眠。把运行状态等数据存放在硬盘上某个文件或者某个特定的区域，关闭硬盘、外设等设备，进入关机状态。此时计算机完全关闭，不耗电。恢复时计算机从休眠文件/分区中读出数据，回到休眠前的状态，恢复速度较慢。电子书项目中，见过一款索尼的电子书，没有定义关机状态，只定义了S4,从而提高开机速度。一般在window系统中常见到。此状态下计算机将所有活动的状态保存到磁盘中，然后处于关机状态，此模式下是不耗电的，而相比之前的模式，休眠和唤醒的速度都比较慢。
							</div>
						</div>
					</div>
				</div>
			</section>
			<section>
				<h3>ssh</h3>
				<div>
					<a target="_blank" href="https://wangdoc.com/ssh/">SSH 教程 - 网道</a>
				</div>
			</section>
			<section>
				<h3>open port in iptabls or firewalld</h3>
				<p>
					#iptables is(in CentOS 7 not use this):
					<br/>
					#add a data receive rule
					<br/>
					<span class="shell_instruction">iptables -A INPUT -p tcp --dport 22 -j ACCEPT</span>
					<br/>
					#add a data post rule
					<br/>
					<span class="shell_instruction">iptables -A OUTPUT -p tcp --sport 22 -j ACCEPT</span>
					<br/>
					#restart iptables service
					<br/>
					<span class="shell_instruction">service sshd restart</span>
					<br/>
					<br/>

					#firewalld is(in CentOS 7 use this):
					<br/>
					#add a rule, with option parameter --permanent to persistent the rule
					<br/>
					<span class="shell_instruction">firewall-cmd --permanent --add-port=22/tcp</span>
					<br/>
					#restart firewalld service
					<br/>
					<span class="shell_instruction">systemctl restart firewalld</span>
					<br/>
					#ensure the new rule is active
					<br/>
					<span class="shell_instruction">firewall-cmd --query-port=22/tcp</span>
					<br/>
				</p>
			</section>
			<section>
				<h3>set sshd service start with OS boot and start at now</h3>
				<p>
					#query ssdh service status
					<br/>
					<span class="shell_instruction">systemctl status sshd</span>
					<br/>
					#output the follow information
					<br/>
					<span style="color : blue">
					● sshd.service - OpenSSH server daemon
					<br/>
					&nbsp;&nbsp;&nbsp;Loaded: loaded (/usr/lib/systemd/system/sshd.service; disabled; vendor preset: enabled)
					<br/>
					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Active: inactive (dead)
					<br/>
				    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Docs: man:sshd(8)
					<br/>
				    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;man:sshd_config(5)
					</span>
					<br/>
					#so we see the Loaded: loaded (/usr/lib/systemd/system/sshd.service; disabled; vendor preset: enabled)
					<br/>
					#the service is not start with OS boot, so we set it start with OS boot
					<br/>
					<span class="shell_instruction">systemctl enable sshd</span>
					<br/>
					#we also see Active: inactive (dead), that means the service is not run at current time, we start it at now
					<br/>
					<span class="shell_instruction">systemctl start sshd</span>
					<br/>
				</p>
			</section>
			<section>
				<h3>双系统, 修复windows启动项</h3>
				<p>
					修改/boot/grub2/grub.cfg
					<br/>
					找到在两个menuentry末尾添加一个win7启动设置，具体参数是
					<br/>
					menuentry	‘win7’{
						<br/>
						<span class="class___tab_place"></span>set root=(hd0,1)
						<br/>
						<span class="class___tab_place"></span>chainloader +1
						<br/>
					}
				</p>
			</section>
			<section>
				<h3>su</h3>
				<div>
					<span class="shell_instruction">su root</span>
					<br/>
					以root用户身份新建一个子shell并切换到这个shell进程中, 但保持当前状态的环境变量
					<br/>
					<br/>
					<span class="shell_instruction">su - root</span>
					<br/>
					新建并以root用户身份登陆一个子shell进程, 切换为root用户的环境变量
				</div>
			</section>
			<section>
				<h3>清屏命令</h3>
				<p>
					<span class="shell_instruction">clear</span>
					<br/>
					or
					<br/>
					ctrl + l
					<br/>
					刷新屏幕，本质上只是让终端显示页向后翻了一页，如果向上滚动屏幕还可以看到之前的操作信息。
				</p>
				<p>
					<span class="shell_instruction">reset</span>
					<br/>
					完全刷新终端屏幕，之前的终端输入操作信息将都会被清空，这样虽然比较清爽，但整个命令过程速度有点慢，使用较少。
					<br/>
					值得一提的是reset命令在你的终端控制错乱时非常有用。如输入字符不出现在光标的位置的情况。还有当你敲击回车键时，新提示符并没有出现在新行上而是出现在老提示符的前面。此时reset命令就能用来修正这些问题。
				</p>
				<p>
					<span class="shell_instruction">printf '\033c'</span>
					<br/>
					真正的清空了终端屏幕，它的功能跟DOS里CMD.EXE提供的CLS效果很相似。
					<br/>
					工作原理是
					<br/>
					\033  ==  \x1B == 27 == ESC
					<br/>
					于是，这个命令变成了<ESC>c，它是VT-XXX中表示“Full Reset (RIS)”的转义码。现今我们使用的所有的终端都是VT兼容的，它的另一种实现方式也可以这样：
					<br/>
					键盘上Ctrl+v---&gt;Esc--&gt;输入c再回加。但如果你发现自己使用的是一个非常奇怪的终端（如在putty上），那这个命令你可能用不了。
					<br/>
					 printf是bash里内置的命令，内置命令的优先级比其它可执行文件要高。
					<br/>
					 or
					<br/>
					<span class="shell_instruction">printf '\ec'</span>
					<br/>
					\e等价于\033
					<br/>
					 or
					<br/>
					<span class="shell_instruction">echo -e '\ec\c'</span>
					<br/>
					 or
					<br/>
					<span class="shell_instruction">echo -e '\033c\c'</span>
					<br/>
					 or
					<br/>
					<span class="shell_instruction">echo -en '\ec'</span>
					<br/>
					 or
					<br/>
					<span class="shell_instruction">echo -en '\033c'</span>
				</p>
			</section>
			<section>
				<h3>操作目录命令</h3>
				<p>
					回到刚才的目录
					<br/>
					<span class="shell_instruction">cd -</span>
				</p>
				<p>
					目录压栈
					<br/>
					<span class="shell_instruction">pushd .</span>
				</p>
				<p>
					目录出栈
					<br/>
					<span class="shell_instruction">popd</span>
				</p>
			</section>
			<section>
				<h3>查看内存</h3>
				<p>
					<span class="shell_instruction">free</span>
				</p>
			</section>
			<section>
				<h3>sync手动将存放在内存中的数据刷新到磁盘中</h3>
				<p>
					<span class="shell_instruction">sync</span>
					Linux内核为了达到最佳的磁盘操作效率，会把需要写入到磁盘的数据现在内存中缓存起来，在合适的时候才真正写入到磁盘中，这在绝大多数情况都是没有任何问题的，而且提高了系统的效率，但是如果系统当机、掉电，就会有些文件内容不会保存下来。在Linux系统关机或者重启时，会自动把缓冲区的内容自动同步到磁盘中。我们也可以手工去执行sync命令，强制将内存中的文件缓冲内容写到磁盘，这个命令是通过调用sync系统调用来实现的。（flush file system buffers。
					<br/>
					Synchronize data on disk with memory。Force changed blocks to disk, update the super block.`sync' writes any data buffered in memory out to disk.
					<br/>
					This can include (but is not limited to) modified superblocks, modified inodes, and delayed reads and writes.
					<br/>
					This must be implemented by the kernel; The `sync' program does nothing but exercise the `sync' system call.
					<br/>
					The kernel keeps data in memory to avoid doing (relatively slow) disk reads and writes.
					<br/>
					This improves performance, but if the computer crashes, data may be lost or the file system corrupted as a result.
					<br/>
					The `sync' command ensures everything in memory is written to disk.）
				</p>
			</section>
			<section>
				<h3>帮助,查找命令</h3>
				<div>
					<a target="_blank" href="./refs/man/index.html">man</a>
					<br/>
					<span class="shell_instruction">man -k key_word</span>
					<br/>
					-k : 列出包含在下一个参数中的字符的命令
					<br/>
					<br/>
					查看指定路径的man文件
					<br/>
					<span class="shell_instruction">man -l &lt;filepath&gt;</span>
					<br/>
					or
					<br/>
					<span class="shell_instruction">man --local-file &lt;filepath&gt;</span>
					<br/>
					用
					<span class="shell_instruction">man man</span>
					<br/>
					查看man自身的帮助手册, 其中的参数信息如下
					<br/>
					-l, --local-file
					<br/>
Activate `local' mode.  Format and display local manual files instead of searching through the system's manual collection.  Each manual page argument will be interpreted as  an  nroff  source file  in the correct format.  No cat file is produced.  If '-' is listed as one of the arguments, input will be taken from stdin.  When this option is not used, and man fails to find the page required, before displaying the error message, it attempts to act as if this option was supplied, using the name as a filename and looking for an exact match.
					<br/>
					<a target="_blank" href="https://www.cnblogs.com/DataArt/p/10010673.html">Linux man 命令详细介绍 - 海东潮 - 博客园</a>
				</div>
			</section>
			<section>
				<h3>生成ssh协议秘钥</h3>
				<p>
					use ssh-keygen instruction
				</p>
				<p>
					<span class="shell_instruction">ssh-keygen -t rsa -C email@domain</span>
					<br/>
					-t : 在下一个参数中指定加密算法
					<br/>
					-C : 在下一个参数中指定注释
				</p>
			</section>
			<section>
				<h3>encrypt and decrypt file with symmetric algorithm(文件加密解密使用对称算法)</h3>
				<p>
					use openssl, encrypt file by the follow instruction
				</p>
				<p>
					<span class="shell_instruction">openssl enc -des3 -a -salt -in source_file -out target_file [-pass password]</span>
					<br/>
					-des3 : 为加密算法(可以根据自己需要选择).
					<br/>
					-a : 对加密后的数据进行base64编码，或解密前，先对数据进行base64解码.
					<br/>
					-salt : 加盐,这是一个神奇的选项，加盐后，相同的明文可以得到不同的密文。默认情况下，盐值是随机生成的，可以使用-S选项明确指定盐值.
					<br/>
					-in : 在下一个参数中指定要加密的源文件.
					<br/>
					-out : 在下一个参数中指定加密后的文件.
					<br/>
					-pass : 在下一个参数中指定密码, 不加此参数则会在运行时等待用户输入密码,并以*号显示.
				</p>
				<p>
					use openssl, decrypt file by the follow instruction
				</p>
				<p>
					<span class="shell_instruction">openssl enc -d -des3 -a -salt -in source_file -out target_file [-pass password]</span>
					<br/>
					-d : 解密.
					<br/>
					-des3 : 为加密算法(可以根据自己需要选择).
					<br/>
					-a : 对加密后的数据进行base64编码，或解密前，先对数据进行base64解码.
					<br/>
					-salt : 加盐,这是一个神奇的选项，加盐后，相同的明文可以得到不同的密文。默认情况下，盐值是随机生成的，可以使用-S选项明确指定盐值.
					<br/>
					-in : 在下一个参数中指定要加密的源文件.
					<br/>
					-out : 在下一个参数中指定加密后的文件.
					<br/>
					-pass : 在下一个参数中指定密码, 不加此参数则会在运行时等待用户输入密码,并以*号显示.
				</p>
			</section>
			<section>
				<h3>死机</h3>
				<div>
					<a target="_blank" href="https://www.cnblogs.com/zxhyJack/p/8641240.html">linux死机解决办法 - zxhyJack - 博客园</a>
					<div>
						<span style="display : inline-block; border : 1px solid black; width : 14px; text-align : center;">+</span><span>为防链接失效的本地截图</span>
						<div style="display:none;">
							<script>add_fold(document.currentScript);</script>
							<div class="class___code class___copy_other_people_content">
								linux死机后不要长按电源建强制关机，容易对损坏系统配置或者电脑硬件，导致重启后产生不必要的麻烦<br/>
								<br/>
								如果是在图形界面下死机的话，不要再依赖任何图形界面的工具，解决方法如下：<br/>
								<br/>
								1.一种方式是进入终端界面进行操作，按ctrl+alt+f1（或者f2～f6）进入tty，使用top命令查看一下进程，把一直占用资源很大的进程kill掉<br/>
								<br/>
								2.如果进入不了tty或者进入tty后不管用，可以采取终极大杀器--reisub方法，这个方法可以在系统死机的情况下安全的重启计算机，数据还不会丢失<br/>
								<br/>
								具体操作是：按住alt+SysRq，再依次按下reisub几个键，按完b键就会重启　　<br/>
								<br/>
								其实&nbsp;Sys&nbsp;Rq&nbsp;是一种叫做系统请求的东西，按住&nbsp;Alt-Print&nbsp;的时候就相当于按住了&nbsp;Sys&nbsp;Rq&nbsp;键，这个时候输入的一切都会直接由&nbsp;Linux&nbsp;内核来处理，它可以进行许多低级操作。这个时候&nbsp;reisub&nbsp;中的每一个字母都是一个独立操作，他们分别表示：<br/>
								nRaw&nbsp;将键盘控制从&nbsp;X&nbsp;Server&nbsp;那里抢回来<br/>
								tErminate&nbsp;给所有进程发送&nbsp;SIGTERM&nbsp;信号，让他们自己解决善后<br/>
								kIll&nbsp;给所有进程发送&nbsp;SIGKILL&nbsp;信号，强制他们马上关闭<br/>
								Sync&nbsp;将所有数据同步至磁盘<br/>
								Unmount&nbsp;将所有分区挂载为只读模式<br/>
								reBoot&nbsp;重启<br/>
								<br/>
								这里有个问题要注意一下，最好不要快速连续地按下这几个键，要有间隔，大概是估计每个间隔10秒左右，因为每一步操作都需要时间，而且s键之后因为同步数据比较慢，可以停20秒。<br/>
							</div>
							reisuo是关机
						</div>
					</div>
				</div>
			</section>
		</article>
	</body>
</html>
