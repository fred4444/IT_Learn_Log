<!doctype html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0,minimum-scale=1.0,user-scalable=0" />
		<title>Cascading Style Sheets</title>
		<style>
			.class___line_head {
				margin-left : 2em;
			}
			.class___code {
				color : yellow;
				background-color : black;
				line-height : 24px;
				font-size : 18px;
				vertical-align : bottom;
				white-space : nowrap;
				overflow-x : auto;
			}
			.class___tab {
				display : inline-block;
				width : 4ex;
				overflow-x : hidden;
				line-height : 24px;
				font-size : 18px;
				vertical-align : bottom;
				white-space : pre-wrap;
			}
			.class___code_last_line {
				display : inline-block;
				white-space : nowrap;
			}
			.shell_instruction {
				color : yellow;
				background-color : black;
				font-weight : 800;
				padding : 4px;
			}
			section {
				margin-top : 60px;
			}
			section > div {
				padding-left : 2em;
				line-height : 180%;
			}
			#id___textarea___input_source_code {
				height : 100px;
				width : calc(100% - 6px);
				margin-bottom : 10px;
			}
			#id___textarea___output_html_code {
				height : 100px;
				width : calc(100% - 6px);
				margin-top : 10px;
			}
		</style>
		<style>
			tr:nth-of-type(odd) {
				background-color : rgba(210, 210, 200, 1);
			}
			tr:nth-of-type(even) {
				background-color : rgba(200, 200, 210, 1);
			}
		</style>
		<script>
			convert_code_to_html = () => {
				let source = document.getElementById('id___textarea___input_source_code');
				let target = document.getElementById('id___textarea___output_html_code');
				let s = source.value;
				//console.log(s);
				s = s.trim();
				s = s.replace(/\r/g, '');
				s = s.replace(/&/g, '&amp;');
				s = s.replace(/ /g, '&nbsp;');
				s = s.replace(/>/g, '&gt;');
				s = s.replace(/</g, '&lt;');
				s = s.replace(/\t/g, '<span class="class___tab">&#9;</span>');
				s = s.replace(/\n/g, '<br/>\n');
				s = s.replace(/\n/g, '\n\t');
				s += '<br/>';
				//console.log(s);
				target.value = '<div class="class___code">\n\t' + s + '\n</div>';
			}
			window.onload = (e) => {
				let button = document.getElementById('id___button___convert_code_to_html');
				//console.log(button);
				button.addEventListener('click', convert_code_to_html, false);
			}
		</script>
	</head>
	<body>
		<article>
			<header>
				<h3>Cascading Style Sheets(CSS)</h3>
				<p>
					//
				</p>
			</header>
			<section>
				<h3>代码转换</h3>
				<div>
					<textarea id="id___textarea___input_source_code"></textarea>
					<br/>
					<button id="id___button___convert_code_to_html">轉換</button>
					<br/>
					<textarea id="id___textarea___output_html_code"></textarea>
				</div>
			</section>
			<section>
				<h3>BFC</h3>
				<div>
					<a target="_blank" href="https://blog.csdn.net/sinat_36422236/article/details/88763187">什么是BFC？看这一篇就够了_Leon的博客-CSDN博客_bfc</a>
					<br/>
					<a target="_blank" href="./refs/BFC.png">本地图片:什么是BFC？看这一篇就够了_Leon的博客-CSDN博客_bfc</a>
				</div>
			</section>
			<section>
				<h3>example</h3>
				<div>
					<a target="_blank" href="https://www.webhek.com/post/css-loaders.html">你能相信吗？这些都是由一个DIV元素实现的动画，纯CSS3技术</a>
					<br/>
					<a target="_blank" href="https://www.webhek.com/post/css3-animation-sniplet-collection.html#/">CSS3动画代码大集合 - 这是一个能方便的找到CSS动画制作的代码片段的地方。</a>
					<br/>
					<a target="_blank" href="https://www.webhek.com/post/css-sans.html">用纯CSS3绘制26个英文字母</a>
					<br/>
					<a target="_blank" href="https://www.webhek.com/post/creativeguidebook.html">一本书里的大千世界</a>
					<br/>
					<a target="_blank" href="https://www.webhek.com/post/css-draw-a-heart.html">CSS技术高手：一颗自我实现的红心(还会跳呦)</a>
					<br/>
					<a target="_blank" href="https://www.webhek.com/post/3d-album.html">程序员给女朋友用HTML5制作的3D相册</a>
				</div>
			</section>
			<section>
				<h3>倒影</h3>
				<div>
					<div style="font-size : 0;">
						<script>
							{
								const width = 400, height = 400;
								const cs = document.currentScript;
								const div = cs.parentNode;
								div.style.fontSize = 0;
								div.style.lineHeight = 0;
								const canvas = document.createElement('canvas');
								const rw = 100, rh = 100;
								const rwr = rw / 2, rhr = rh / 2, mw = width / 2, mh = height / 2;
								const p_left = mw - rwr, p_right = mw + rwr, p_top = mh - rhr, p_bottom = mh + rhr;
								canvas.width = width;
								canvas.height = height;
								const ctx = canvas.getContext('2d');
								//画背景色
								ctx.fillStyle = 'blue';
								ctx.fillRect(0, 0, width, height);
								//在中间画一个100x100的正方形
								ctx.fillStyle = 'green';
								ctx.fillRect(p_left, p_top, rw, rh);
								//在中间画一个+
								//const path2d = new Path2D();
								//path2d.moveTo(p_left, mh);
								//path2d.lineTo(p_right, mh);
								//path2d.moveTo(mw, p_top);
								//path2d.lineTo(mw, p_bottom);
								//path2d.closePath();
								ctx.beginPath();
								ctx.moveTo(p_left, mh);
								ctx.lineTo(p_right, mh);
								ctx.moveTo(mw, p_top);
								ctx.lineTo(mw, p_bottom);
								ctx.closePath();
								ctx.strokeStyle = 'black';
								ctx.stroke();
								ctx.font = '50px serif';
								ctx.fillText('Hello world', 100, height);
								const url = canvas.toDataURL('image/png');
								

								const img = document.createElement('img');
								img.src = url;
								const inverted_image_container = document.createElement('div');
								//inverted_image_container.classList.add('ic');
								Object.entries({
									'width' : width + 'px',
									'height' : height + 'px',
									'position' : 'relative',
									'overflow' : 'hidden',
								}).forEach((p) => {
									inverted_image_container.style.setProperty(p[0], p[1]);
								});
								const ii = document.createElement('img');
								ii.src = url;
								//ii.classList.add('inverted_image');
								const overlay = document.createElement('div');
								//overlay.classList.add('overlay');
								Object.entries({
									'background-image' : 'linear-gradient(rgba(0, 0, 0, 0) 10%, rgba(0, 0, 0, 0.7))',
									'width' : '100%',
									'height' : '100%',
									'position' : 'absolute',
									'top' : 0,
									'left' : 0,
								}).forEach((p) => {
									overlay.style.setProperty(p[0], p[1]);
								});
								inverted_image_container.appendChild(ii);
								inverted_image_container.appendChild(overlay);


								const keyframeeffect = new KeyframeEffect(
									ii,
									[
										{
											transform : 'scaleY(-1) scaleX(1.01) skew(0.5deg, 0deg)',
											opacity : 0.8,
											filter : 'blur(2px) grayscale(10%)',
										},
										{
											transform : 'scaleY(-1) scaleX(1) skew(0deg, 0deg)',
											opacity : 0.5,
											filter : 'blur(0px) grayscale(0%)',
										},
										{
											transform : 'scaleY(-1) scaleX(1.01) skew(-0.5deg, 0deg)',
											opacity : 0.8,
											filter : 'blur(2px) grayscale(10%)',
										},
									],
									{
										delay : 0,
										direction : 'alternate',
										duration : 3000,
										easing : 'cubic-bezier(0, 0, 1, 1)',
										endDelay : 0,
										fill : 'both',
										iterationStart : 0,
										iterations : 'Infinity',
									}
								);
								const animation = new Animation(keyframeeffect, document.timeline);
								let is_play = true;
								inverted_image_container.addEventListener('click', (e) => {
									if (is_play) {
										animation.pause();
										is_play = false;
									} else {
										animation.play();
										is_play = true;
									}
								});



								div.appendChild(img);
								div.appendChild(inverted_image_container);
								animation.play();
							}
						</script>
					</div>
					通过css中的transform的scaleY(-1);实现倒像, 用background-image的linear-gradient覆盖一层渐变色来使图像
					<div class="class___code">
						.inverted_image_img&nbsp;{<br/>
						<span class="class___tab">&#9;</span>transform&nbsp;:&nbsp;scaleY(-1);<br/>
						<span class="class___tab">&#9;</span>opacity&nbsp;:&nbsp;0.5;<br/>
						}<br/>
						.overlay&nbsp;{<br/>
						<span class="class___tab">&#9;</span>background-image:&nbsp;linear-gradient(rgba(0,&nbsp;0,&nbsp;0,&nbsp;0)&nbsp;10%,&nbsp;rgba(0,&nbsp;0,&nbsp;0,&nbsp;0.7));<br/>
						<span class="class___tab">&#9;</span>width:&nbsp;100%;<br/>
						<span class="class___tab">&#9;</span>height:&nbsp;100%;<br/>
						<span class="class___tab">&#9;</span>position:&nbsp;absolute;<br/>
						<span class="class___tab">&#9;</span>top:&nbsp;0px;<br/>
						<span class="class___tab">&#9;</span>left:&nbsp;0px;<br/>
						}<br/>
					</div>
					上面的例子中还加了filter : blur(1px) grayscale(10%);
					<br/>
					点击倒影可以暂停波动, 再点击恢复波动
				</div>
			</section>
			<section>
				<h3>空行</h3>
				<div>
					在两个标签之间出现空行有多种原因:
					<br/>
					1:换行,如
					<div class="class___code">
						&lt;div&gt;
						<br/>
						&lt;div&gt;
					</div>
					浏览器会在两个div中间产生一个文本节点, 在不换行时产生空白的间隙, 在换行时产生空行
					<br/>
					解决办法:不换行
					<div class="class___code">
						&lt;div&gt;&lt;div&gt;
					</div>
					或用注释占空白
					<div class="class___code">
						&lt;div&gt;&lt;!--
						<br/>
						--&gt;&lt;div&gt;
					</div>
					或在父标签中将字体大小设置为0
					<br/>
					2:line-height
					<br/>
					在设置了line-height时也会有此情况
					<br/>
					解决办法:设置line-height : 0;
				</div>
			</section>
			<section>
				<h3>margin塌陷</h3>
				<div>
					在标准文档流中，竖直方向的margin会出现叠加或转移现象（水平方向不会塌陷），两个margin紧挨着，中间没有border或者padding
					<br/>
					margin直接接触，就产生了塌陷
					<br/>
					当父子关系的DOM都有margin-top时为较大的margin会覆盖掉较小的margin，竖直方向的两个盒子中间只有一个较大的margin
					<br/>
					当父子关系的DOM只有子DOM有margin-top时, 子DOM的margin-top会跑到父DOM上
					<br/>
					当上下相邻的两个DOM,上面的DOM有margin-bottom, 下面的DOM有margin-top时, 只有那个值较大的生效
					<br/>
					可以添加透明边框border
					<br/>
					将margin-top改为padding-top
					<br/>
					在父子关系时设置overflow : hidden;或overflow : auto;
				</div>
			</section>
			<section>
				<h3>Visual formatting model - CSS: Cascading Style Sheets | MDN</h3>
				<div>
					<a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/CSS/Visual_formatting_model">Visual formatting model - CSS: Cascading Style Sheets | MDN</a>
				</div>
			</section>
			<section>
				<h3>flex布局</h3>
				<div>
					<a target="_blank" href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool">Flex 布局教程：语法篇 - 阮一峰的网络日志</a>
				</div>
			</section>
			<section>
				<h3>grid布局</h3>
				<div>
					<a target="_blank" href="https://www.w3cplus.com/css3/css3-grid-layout.html">CSS3 Grid Layout_Grid, Layout, CSS3 Grid Layout, 会员专栏 教程_w3cplus</a>
					<a target="_blank" href="http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html">CSS Grid 网格布局教程 - 阮一峰的网络日志</a>
				</div>
			</section>
			<section>
				<h3>去除input text 获取焦点后显示的蓝色边框</h3>
				<div>
					css中设置outline : none;
				</div>
			</section>
			<section>
				<h3>css list</h3>
				<div>
					<a target="_blank" href="https://iruxu.com/notebook/">iRuxu NoteBook</a>
					<br/>
					<a target="_blank" href="http://demo.haoji.me/notebook/">iRuxu NoteBook</a>
				</div>
			</section>
			<section>
				<h3>换行</h3>
				<div>
					white-space : ${value};
					<br/>
					white-space可设置的值:

					<br/>
					normal
					<br/>
					<span class="class___line_head"></span>
					Sequences of white space are collapsed. Newline characters in the source are handled the same as other white space. Lines are broken as necessary to fill line boxes.
					<br/>
					<span class="class___line_head"></span>
					空白(空格制表位\t等)会被折叠(合并)(多个空白只会显示一个空格). 换行符也被当作空白处理. 在填满容器的宽度后换行.

					<br/>
					nowrap
					<br/>
					<span class="class___line_head"></span>
					Collapses white space as for normal, but suppresses line breaks (text wrapping) within the source.
					<br/>
					<span class="class___line_head"></span>
					像normal中一样折叠(合并)空白. 并禁止换行.

					<br/>
					pre
					<br/>
					<span class="class___line_head"></span>
					Sequences of white space are preserved. Lines are only broken at newline characters in the source and at &lt;br&gt; elements.
					<br/>
					<span class="class___line_head"></span>
					空白被保留. 只在换行符和&lt;br&gt;处换行.

					<br/>
					pre-wrap
					<br/>
					<span class="class___line_head"></span>
					Sequences of white space are preserved. Lines are broken at newline characters, at &lt;br&gt;, and as necessary to fill line boxes.
					<br/>
					<span class="class___line_head"></span>
					空白被保留. 换行符和&lt;br&gt;和填满容器宽度处换行.

					<br/>
					pre-line
					<br/>
					<span class="class___line_head"></span>
					Sequences of white space are collapsed. Lines are broken at newline characters, at &lt;br&gt;, and as necessary to fill line boxes.
					<br/>
					<span class="class___line_head"></span>
					空白被折叠(合并). 换行符和&lt;br&gt;和填满容器宽度处换行.

					<br/>
					break-spaces
					<br/>
					<span class="class___line_head"></span>
					The behavior is identical to that of pre-wrap, except that:
					<br/>
					<span class="class___line_head"></span>
					<span class="class___line_head"></span>
					Any sequence of preserved white space always takes up space, including at the end of the line.
					<br/>
					<span class="class___line_head"></span>
					<span class="class___line_head"></span>
					A line breaking opportunity exists after every preserved white space character, including between white space characters.
					<br/>
					<span class="class___line_head"></span>
					<span class="class___line_head"></span>
					Such preserved spaces take up space and do not hang, and thus affect the box’s intrinsic sizes (min-content size and max-content size).
					<br/>
					<span class="class___line_head"></span>
					除了下述除外与pre-wrap行为一致:
					<br/>
					<span class="class___line_head"></span>
					<span class="class___line_head"></span>
					任何空白都占用空间包括行尾的.
					<br/>
					<span class="class___line_head"></span>
					<span class="class___line_head"></span>
					任何空白处都可能换行.
					<br/>
					<span class="class___line_head"></span>
					<span class="class___line_head"></span>
					此类保留的空间不会被悬挂(悬挂即行尾的空白保留空间但只占用空间当前行尾后面的不占用空间并不会导致因填充满容器宽度而换行, 不被悬挂即把空白当成普通字符一样占用空间并可导致因填充满容器宽度而换行), 并且影响容器的盒大小(最小内容尺寸和最大内容尺寸)
					<br/>
					<br/>
					<table style="width : 100%; text-align : center;">
						<tr>
							<th></th>
							<th>new lines</th>
							<th>spaces and tabs</th>
							<th>text wrapping(文本换行)</th>
							<th>end-of-line spaces</th>
						</tr>
						<tr>
							<td>normal</td>
							<td>collapse</td>
							<td>collapse</td>
							<td>wrap</td>
							<td>remove</td>
						</tr>
						<tr>
							<td>nowrap</td>
							<td>collapse</td>
							<td>collapse</td>
							<td>no wrap</td>
							<td>remove</td>
						</tr>
						<tr>
							<td>pre</td>
							<td>preserve</td>
							<td>preserve</td>
							<td>no wrap</td>
							<td>preserve</td>
						</tr>
						<tr>
							<td>pre-wrap</td>
							<td>preserve</td>
							<td>preserve</td>
							<td>wrap</td>
							<td>hang</td>
						</tr>
						<tr>
							<td>pre-line</td>
							<td>preserve</td>
							<td>collapse</td>
							<td>wrap</td>
							<td>remove</td>
						</tr>
						<tr>
							<td>break-spaces</td>
							<td>preserve</td>
							<td>preserve</td>
							<td>wrap</td>
							<td>wrap</td>
						</tr>
					</table>
					<br/>
					<br/>

					示例如下:
					<div style="white-space : normal; width : 400px; border : 1px solid black;">
						{
							class Class___Inherit_test___Parent {
								constructor() {
								}
							}
							class Class___Inherit_test___Child extends Class___Inherit_test___Parent {
								constructor() {
									super();
								}
							}
							const ca = new Class___Inherit_test___Parent();//后有100个空格                                                                                                    
							console.log(ca);
						}

					</div>
					<div style="white-space : nowrap; width : 400px; border : 1px solid black;">
						{
							class Class___Inherit_test___Parent {
								constructor() {
								}
							}
							class Class___Inherit_test___Child extends Class___Inherit_test___Parent {
								constructor() {
									super();
								}
							}
							const ca = new Class___Inherit_test___Parent();//后有100个空格                                                                                                    
							console.log(ca);
						}

					</div>
					<div style="white-space : pre; width : 400px; border : 1px solid black;">
{
	class Class___Inherit_test___Parent {
		constructor() {
		}
	}
	class Class___Inherit_test___Child extends Class___Inherit_test___Parent {
		constructor() {
			super();
		}
	}
	const ca = new Class___Inherit_test___Parent();//后有100个空格                                                                                                    
	console.log(ca);
}

					</div>
					<div style="white-space : pre-wrap; width : 400px; border : 1px solid black;">
{
	class Class___Inherit_test___Parent {
		constructor() {
		}
	}
	class Class___Inherit_test___Child extends Class___Inherit_test___Parent {
		constructor() {
			super();
		}
	}
	const ca = new Class___Inherit_test___Parent();//后有100个空格                                                                                                    
	console.log(ca);
}

					</div>
					<div style="white-space : pre-line; width : 400px; border : 1px solid black;">
{
	class Class___Inherit_test___Parent {
		constructor() {
		}
	}
	class Class___Inherit_test___Child extends Class___Inherit_test___Parent {
		constructor() {
			super();
		}
	}
	const ca = new Class___Inherit_test___Parent();//后有100个空格                                                                                                    
	console.log(ca);
}

					</div>
					<div style="white-space : break-spaces; width : 400px; border : 1px solid black;">
{
	class Class___Inherit_test___Parent {
		constructor() {
		}
	}
	class Class___Inherit_test___Child extends Class___Inherit_test___Parent {
		constructor() {
			super();
		}
	}
	const ca = new Class___Inherit_test___Parent();//后有100个空格                                                                                                    
	console.log(ca);
}

					</div>
				</div>
			</section>
		</article>
	</body>
</html>
