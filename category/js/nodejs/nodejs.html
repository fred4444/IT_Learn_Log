<!doctype html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0,minimum-scale=1.0,user-scalable=0" />
		<title>nodejs</title>
		<style>
			.class___line_head {
				margin-left : 2em;
			}
			.class___code {
				color : yellow;
				background-color : black;
				line-height : 24px;
				font-size : 18px;
				vertical-align : bottom;
				white-space : nowrap;
			}
			.class___tab {
				display : inline-block;
				width : 4ex;
				overflow-x : hidden;
				line-height : 24px;
				font-size : 18px;
				vertical-align : bottom;
				white-space : pre-wrap;
			}
			.class___code_last_line {
				display : inline-block;
				white-space : nowrap;
			}
			.shell_instruction {
				color : yellow;
				background-color : black;
				font-weight : 800;
				padding : 4px;
			}
			section {
				margin-top : 60px;
			}
			section > div {
				padding-left : 2em;
				line-height : 180%;
			}
			#id___textarea___input_source_code {
				height : 100px;
				width : calc(100% - 6px);
				margin-bottom : 10px;
			}
			#id___textarea___output_html_code {
				height : 100px;
				width : calc(100% - 6px);
				margin-top : 10px;
			}
		</style>
		<script>
			const add_fold = function(currentScript) {
				const cs = currentScript;
				const pn = cs.parentNode;
				const ppn = pn.parentNode;
				ppn.children[0].addEventListener('click', function(e) {
					let display = pn.style.getPropertyValue('display');
					if (display) {
						ppn.children[0].textContent = '-';
						pn.style.removeProperty('display');
					} else {
						ppn.children[0].textContent = '+';
						pn.style.setProperty('display', 'none');
					}
				});
			}
		</script>
		<style>
			.class___menu_item {
				cursor : pointer;
				color : green;
				box-shadow: 0 0 1px 1px #71f4dc;
			}
			.class___menu_item:hover {
				color : red;
				text-shadow: 2px 2px 2px gray;
				box-shadow: 0 0 4px 4px gray;
			}
			.class___menu_close_button {
				cursor : pointer;
				text-align : center;
				border : 1px solid black;
				margin-top : 10px;
				color : black;
				width: 80px;
				margin-left: calc(50% - 40px);
			}
			.class___menu_close_button:hover {
				color : red;
				text-shadow: 2px 2px 2px gray;
			}
			.class___show_menu_button {
				cursor : pointer;
				text-align : center;
				border : 1px solid black;
				color : black;
				background-color : #f0d278;
				width: 40px;
				height : 40xp;
				position : fixed;
				right : 0;
				top : 0;
			}
			.class___show_menu_button:hover {
				color : red;
				text-shadow: 2px 2px 2px gray;
				text-shadow: 2px 2px 2px gray;
			}
		</style>
		<script>
			{
				const convert_code_to_html = () => {
					let source = document.getElementById('id___textarea___input_source_code');
					let target = document.getElementById('id___textarea___output_html_code');
					let s = source.value;
					//console.log(s);
					s = s.trim();
					s = s.replace(/\r/g, '');
					s = s.replace(/&/g, '&amp;');
					s = s.replace(/ /g, '&nbsp;');
					s = s.replace(/>/g, '&gt;');
					s = s.replace(/</g, '&lt;');
					s = s.replace(/\t/g, '<span class="class___tab">&#9;</span>');
					s = s.replace(/\n/g, '<br/>\n');
					s = s.replace(/\n/g, '\n\t');
					s += '<br/>';
					//console.log(s);
					target.value = '<div class="class___code">\n\t' + s + '\n</div>';
				}
				const onload_event_function_array = [];
				onload_event_function_array.push((e) => {//添加代码转化函数
					let button = document.getElementById('id___button___convert_code_to_html');
					//console.log(button);
					button.addEventListener('click', convert_code_to_html, false);
				});
				onload_event_function_array.push((e) => {//添加目录函数
					const dom_array = Object.values(document.body.children[0].children).slice(2);
					const dom__menu = document.createElement('div');
					dom__menu.style.cssText = `
						position: fixed;
						left: 0;
						top: 0;
						height: 100%;
						width: 100%;
						background-color: #f0d278;
						overflow: auto;
					`;
					console.log(dom__menu.style.cssText);
					dom_array.forEach((dom) => {
						const dom__menu_item = document.createElement('div');
						dom__menu_item.className = 'class___menu_item';
						dom__menu_item.textContent = dom.children[0].textContent;
						dom__menu_item.onclick = function(e) {
							dom.scrollIntoView(true);
							dom__menu.style.display = 'none';
						};
						dom__menu.appendChild(dom__menu_item);
					});
					const dom__menu_close_button = document.createElement('div');
					dom__menu_close_button.textContent = '关闭目录';
					dom__menu_close_button.className = 'class___menu_close_button';
					dom__menu_close_button.onclick = (e) => {
						dom__menu.style.display = 'none';
					}
					dom__menu.appendChild(dom__menu_close_button);

					const dom__show_menu_button = document.createElement('div');
					dom__show_menu_button.className = 'class___show_menu_button';
					dom__show_menu_button.textContent = '显示目录';
					dom__show_menu_button.onclick = (e) => {
						//dom__show_menu_button.style.display = 'none';
						dom__menu.style.display = 'block';
					}

					document.body.appendChild(dom__show_menu_button);
					document.body.appendChild(dom__menu);
				});
				window.onload = (e) => {
					onload_event_function_array.forEach((f) => {
						f(e);
					});
				}
			}

		</script>
	</head>
	<body>
		<article>
			<header>
				<h3>nodejs</h3>
				<p>
					<a target="_blank" href="https://www.npmjs.com/">npm | build amazing things</a>
				</p>
			</header>
			<section>
				<h3>代码转换</h3>
				<div>
					<textarea id="id___textarea___input_source_code"></textarea>
					<br/>
					<button id="id___button___convert_code_to_html">轉換</button>
					<br/>
					<textarea id="id___textarea___output_html_code"></textarea>
				</div>
			</section>
			<section>
				<h3>杂</h3>
				<div>
					<a target="_blank" href="https://zhuanlan.zhihu.com/p/137535779">node_modules 困境 - 知乎</a>
					<br/>
					<a target="_blank" href="https://www.ruanyifeng.com/blog/2016/10/npm_scripts.html">npm scripts 使用指南 - 阮一峰的网络日志</a>
					<div>
						<span style="display : inline-block; border : 1px solid black; width : 14px; text-align : center;">+</span><span>为防链接失效的本地截图</span>
						<div style="display:none;">
							<script>add_fold(document.currentScript);</script>
							<img src="./refs/imgs/npm_scripts_使用指南_阮一峰的网络日志.png"/>
						</div>
					</div>
					<a target="_blank" href="https://zhuanlan.zhihu.com/p/130922553">NodeJs async_hooks 深入浅出 - 知乎</a>
					<div>
						<span style="display : inline-block; border : 1px solid black; width : 14px; text-align : center;">+</span><span>为防链接失效的本地截图</span>
						<div style="display:none;">
							<script>add_fold(document.currentScript);</script>
							<img src="./refs/imgs/NodeJs_async_hooks_深入浅出.png"/>
						</div>
					</div>
				</div>
			</section>
			<section>
				<h3>Nodejs进程与其间通信</h3>
				<div>
					该部分内容为从别人处摘取的
					<br/>
					<br/>
					<br/>
					创建进程
					<br/>
					通信方式与进程产生方式有关, 而Node有4种创建进程的方式: spawn()、exec()、execFile()、fork()
					<br/>
					spawn
					<br/>
					<div class="class___code">
						const&nbsp;{&nbsp;spawn&nbsp;}&nbsp;=&nbsp;require('child_process');<br/>
						const&nbsp;child&nbsp;=&nbsp;spawn('pwd');<br/>
						//带参数的形式<br/>
						//const&nbsp;child&nbsp;=&nbsp;spawn('find',&nbsp;['.',&nbsp;'-type',&nbsp;'f']);<br/>
					</div>
					spawn()返回ChildProcess实例, ChildProcess同样基于事件机制(EventEmitter API),提供了一些事件:
					<br/>
					exit : 子进程退出时触发, 可以得知进程退出状态(code和signal)
					<br/>
					disconnect : 父进程调用child.disconnect()时触发
					<br/>
					error : 子进程创建失败, 或被kill时触发
					<br/>
					close : 子进程的stdio流(标准输入输出流)关闭时触发
					<br/>
					message : 子进程通过process.send()发送消息时触发, 父子进程之间可以通过这种内置的消息机制通信
					<br/>
					可以通过child.stdin, child.stdout和child.stderr访问子进程的stdio流, 这些流被关闭的时, 子进程会触发close事件
					<br/>
					close与exit的区别主要体现在多进程共享同一stdio流的场景, 某个进程退出了并不意味着stdio流被关闭了
					<br/>
					在子进程中, stdout/stderr具有Readable特性, 而stdin具有Writable特性, 与主进程的情况正好相反：
					<div class="class___code">
						child.stdout.on('data',&nbsp;(data)&nbsp;=&gt;&nbsp;{<br/>
						<span class="class___tab">&#9;</span>console.log(`child&nbsp;stdout:\n${data}`);<br/>
						});<br/>
						<br/>
						child.stderr.on('data',&nbsp;(data)&nbsp;=&gt;&nbsp;{<br/>
						<span class="class___tab">&#9;</span>console.error(`child&nbsp;stderr:\n${data}`);<br/>
						});<br/>
					</div>
					利用进程stdio流的管道特性, 就可以完成更复杂的事情, 例如:
					<div class="class___code">
						const&nbsp;{&nbsp;spawn&nbsp;}&nbsp;=&nbsp;require('child_process');<br/>
						<br/>
						const&nbsp;find&nbsp;=&nbsp;spawn('find',&nbsp;['.',&nbsp;'-type',&nbsp;'f']);<br/>
						const&nbsp;wc&nbsp;=&nbsp;spawn('wc',&nbsp;['-l']);<br/>
						<br/>
						find.stdout.pipe(wc.stdin);<br/>
						<br/>
						wc.stdout.on('data',&nbsp;(data)&nbsp;=&gt;&nbsp;{<br/>
						<span class="class___tab">&#9;</span>console.log(`Number&nbsp;of&nbsp;files&nbsp;${data}`);<br/>
						});<br/>
					</div>
					作用等价于find . -type f | wc -l, 递归统计当前目录文件数量
					<br/>
					IPC选项
					<br/>
					另外, 通过spawn()方法的stdio选项可以建立IPC机制 :
					<div class="class___code">
						const&nbsp;{&nbsp;spawn&nbsp;}&nbsp;=&nbsp;require('child_process');<br/>
						<br/>
						const&nbsp;child&nbsp;=&nbsp;spawn('node',&nbsp;['./ipc-child.js'],&nbsp;{&nbsp;stdio:&nbsp;[null,&nbsp;null,&nbsp;null,&nbsp;'ipc']&nbsp;});<br/>
						child.on('message',&nbsp;(m)&nbsp;=&gt;&nbsp;{<br/>
						<span class="class___tab">&#9;</span>console.log(m);<br/>
						});<br/>
						child.send('Here&nbsp;Here');<br/>
						<br/>
						//&nbsp;./ipc-child.js<br/>
						process.on('message',&nbsp;(m)&nbsp;=&gt;&nbsp;{<br/>
						<span class="class___tab">&#9;</span>process.send(`&lt;&nbsp;${m}`);<br/>
						<span class="class___tab">&#9;</span>process.send('&gt;&nbsp;不要回答x3');<br/>
						});<br/>
					</div>
					关于spawn()的IPC选项的详细信息, 请查看options.stdio
					<br/>
					exec
					<br/>
					spawn()方法默认不会创建shell去执行传入的命令(所以性能上稍微好一点), 而exec()方法会创建一个shell。另外, exec()不是基于stream的, 而是把传入命令的执行结果暂存到buffer中, 再整个传递给回调函数
					<br/>
					exec()方法的特点是完全支持shell语法, 可以直接传入任意shell脚本, 例如 :
					<div class="class___code">
						const&nbsp;{&nbsp;exec&nbsp;}&nbsp;=&nbsp;require('child_process');<br/>
						<br/>
						exec('find&nbsp;.&nbsp;-type&nbsp;f&nbsp;|&nbsp;wc&nbsp;-l',&nbsp;(err,&nbsp;stdout,&nbsp;stderr)&nbsp;=&gt;&nbsp;{<br/>
						<span class="class___tab">&#9;</span>if&nbsp;(err)&nbsp;{<br/>
						<span class="class___tab">&#9;</span><span class="class___tab">&#9;</span>console.error(`exec&nbsp;error:&nbsp;${err}`);<br/>
						<span class="class___tab">&#9;</span><span class="class___tab">&#9;</span>return;<br/>
						<span class="class___tab">&#9;</span>}<br/>
						<br/>
						<span class="class___tab">&#9;</span>console.log(`Number&nbsp;of&nbsp;files&nbsp;${stdout}`);<br/>
						});<br/>
					</div>
					但exec()方法也因此存在命令注入的安全风险, 在含有用户输入等动态内容的场景要特别注意。所以, exec()方法的适用场景是 :  希望直接使用shell语法, 并且预期输出数据量不大（不存在内存压力）
					<br/>
					既支持shell语法, 还具有stream IO优势的方式 :
					<br/>
					<div class="class___code">
						const&nbsp;{&nbsp;spawn&nbsp;}&nbsp;=&nbsp;require('child_process');<br/>
						const&nbsp;child&nbsp;=&nbsp;spawn('find&nbsp;.&nbsp;-type&nbsp;f&nbsp;|&nbsp;wc&nbsp;-l',&nbsp;{<br/>
						<span class="class___tab">&#9;</span>shell:&nbsp;true<br/>
						});<br/>
						child.stdout.pipe(process.stdout);<br/>
					</div>
					开启spawn()的shell选项, 并通过pipe()方法把子进程的标准输出简单地接到当前进程的标准输入上, 以便看到命令执行结果。实际上还有更容易的方式 :
					<div class="class___code">
						const&nbsp;{&nbsp;spawn&nbsp;}&nbsp;=&nbsp;require('child_process');<br/>
						process.stdout.on('data',&nbsp;(data)&nbsp;=&gt;&nbsp;{<br/>
						<span class="class___tab">&#9;</span>console.log(data);<br/>
						});<br/>
						const&nbsp;child&nbsp;=&nbsp;spawn('find&nbsp;.&nbsp;-type&nbsp;f&nbsp;|&nbsp;wc&nbsp;-l',&nbsp;{<br/>
						<span class="class___tab">&#9;</span>shell:&nbsp;true,<br/>
						<span class="class___tab">&#9;</span>stdio:&nbsp;'inherit'<br/>
						});<br/>
					</div>
					stdio: 'inherit'允许子进程继承当前进程的标准输入输出(共享stdin, stdout和stderr), 所以上例能够通过监听当前进程process.stdout的data事件拿到子进程的输出结果
					<br/>
					另外, 除了stdio和shell选项, spawn()还支持一些其它选项, 如 :
					<br/>
					<div class="class___code">
						const&nbsp;child&nbsp;=&nbsp;spawn('find&nbsp;.&nbsp;-type&nbsp;f&nbsp;|&nbsp;wc&nbsp;-l',&nbsp;{<br/>
						<span class="class___tab">&#9;</span>stdio:&nbsp;'inherit',<br/>
						<span class="class___tab">&#9;</span>shell:&nbsp;true,<br/>
						<span class="class___tab">&#9;</span>//&nbsp;修改环境变量,&nbsp;默认process.env<br/>
						<span class="class___tab">&#9;</span>env:&nbsp;{&nbsp;HOME:&nbsp;'/tmp/xxx'&nbsp;},<br/>
						<span class="class___tab">&#9;</span>//&nbsp;改变当前工作目录<br/>
						<span class="class___tab">&#9;</span>cwd:&nbsp;'/tmp',<br/>
						<span class="class___tab">&#9;</span>//&nbsp;作为独立进程存在<br/>
						<span class="class___tab">&#9;</span>detached:&nbsp;true<br/>
						});<br/>
					</div>
					注意, env选项除了以环境变量形式向子进程传递数据外, 还可以用来实现沙箱式的环境变量隔离, 默认把process.env作为子进程的环境变量集, 子进程与当前进程一样能够访问所有环境变量, 如果像上例中指定自定义对象作为子进程的环境变量集, 子进程就无法访问其它环境变量
					<br/>
					所以, 想要增/删环境变量的话, 需要这样做 :
					<div class="class___code">
						var&nbsp;spawn_env&nbsp;=&nbsp;JSON.parse(JSON.stringify(process.env));<br/>
						<br/>
						//&nbsp;remove&nbsp;those&nbsp;env&nbsp;vars<br/>
						delete&nbsp;spawn_env.ATOM_SHELL_INTERNAL_RUN_AS_NODE;<br/>
						delete&nbsp;spawn_env.ELECTRON_RUN_AS_NODE;<br/>
						<br/>
						var&nbsp;sp&nbsp;=&nbsp;spawn(command,&nbsp;['.'],&nbsp;{cwd:&nbsp;cwd,&nbsp;env:&nbsp;spawn_env});<br/>
					</div>
					detached选项更有意思 :
					<div class="class___code">
						const&nbsp;{&nbsp;spawn&nbsp;}&nbsp;=&nbsp;require('child_process');<br/>
						<br/>
						const&nbsp;child&nbsp;=&nbsp;spawn('node',&nbsp;['stuff.js'],&nbsp;{<br/>
						<span class="class___tab">&#9;</span>detached:&nbsp;true,<br/>
						<span class="class___tab">&#9;</span>stdio:&nbsp;'ignore'<br/>
						});<br/>
						<br/>
						child.unref();<br/>
					</div>
					以这种方式创建的独立进程行为取决于操作系统, Windows上detached子进程将拥有自己的console窗口, 而Linux上该进程会创建新的process group（这个特性可以用来管理子进程族, 实现类似于tree-kill的特性）
					<br/>
					unref()方法用来断绝关系, 这样“父”进程可以独立退出（不会导致子进程跟着退出）, 但要注意这时子进程的stdio也应该独立于“父”进程, 否则“父”进程退出后子进程仍会受到影响
					<br/>
					<br/>
					execFile
					<div class="class___code">
						const&nbsp;{&nbsp;execFile&nbsp;}&nbsp;=&nbsp;require('child_process');<br/>
						const&nbsp;child&nbsp;=&nbsp;execFile('node',&nbsp;['--version'],&nbsp;(error,&nbsp;stdout,&nbsp;stderr)&nbsp;=&gt;&nbsp;{<br/>
						<span class="class___tab">&#9;</span>if&nbsp;(error)&nbsp;{<br/>
						<span class="class___tab">&#9;</span><span class="class___tab">&#9;</span>throw&nbsp;error;<br/>
						<span class="class___tab">&#9;</span>}<br/>
						<span class="class___tab">&#9;</span>console.log(stdout);<br/>
						});<br/>
					</div>
					与exec()方法类似, 但不通过shell来执行(所以性能稍好一点), 所以要求传入可执行文件。Windows下某些文件无法直接执行, 比如.bat和.cmd, 这些文件就不能用execFile()来执行, 只能借助exec()或开启了shell选项的spawn()
					<br/>
					与exec()一样也不是基于stream的, 同样存在输出数据量风险
					<br/>
					xxxSync
					<br/>
					spawn, exec和execFile都有对应的同步阻塞版本, 一直等到子进程退出
					<div class="class___code">
						const&nbsp;{<span class="class___tab">&#9;</span>spawnSync,&nbsp;execSync,&nbsp;execFileSync}&nbsp;=&nbsp;require('child_process');<br/>
					</div>
					同步方法用来简化脚本任务, 比如启动流程, 其它时候应该避免使用这些方法
					<br/>
					<br/>
					fork
					<br/>
					fork()是spawn()的变体, 用来创建Node进程, 最大的特点是父子进程自带通信机制(IPC管道) :
					<br/>
					The child_process.fork() method is a special case of child_process.spawn() used specifically to spawn new Node.js processes. Like child_process.spawn(), a ChildProcess object is returned. The returned ChildProcess will have an additional communication channel built-in that allows messages to be passed back and forth between the parent and child. See subprocess.send() for details.
					<br/>
					例如 :
					<div class="class___code">
						var&nbsp;n&nbsp;=&nbsp;child_process.fork('./child.js');<br/>
						n.on('message',&nbsp;function(m)&nbsp;{<br/>
						<span class="class___tab">&#9;</span>console.log('PARENT&nbsp;got&nbsp;message:',&nbsp;m);<br/>
						});<br/>
						n.send({&nbsp;hello:&nbsp;'world'&nbsp;});<br/>
						<br/>
						//&nbsp;./child.js<br/>
						process.on('message',&nbsp;function(m)&nbsp;{<br/>
						<span class="class___tab">&#9;</span>console.log('CHILD&nbsp;got&nbsp;message:',&nbsp;m);<br/>
						});<br/>
						process.send({&nbsp;foo:&nbsp;'bar'&nbsp;});<br/>
					</div>
					因为fork()自带通信机制的优势, 尤其适合用来拆分耗时逻辑, 例如 :
					<div class="class___code">
						const&nbsp;http&nbsp;=&nbsp;require('http');<br/>
						const&nbsp;longComputation&nbsp;=&nbsp;()&nbsp;=&gt;&nbsp;{<br/>
						<span class="class___tab">&#9;</span>let&nbsp;sum&nbsp;=&nbsp;0;<br/>
						<span class="class___tab">&#9;</span>for&nbsp;(let&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;1e9;&nbsp;i++)&nbsp;{<br/>
						<span class="class___tab">&#9;</span><span class="class___tab">&#9;</span>sum&nbsp;+=&nbsp;i;<br/>
						<span class="class___tab">&#9;</span>};<br/>
						<span class="class___tab">&#9;</span>return&nbsp;sum;<br/>
						};<br/>
						const&nbsp;server&nbsp;=&nbsp;http.createServer();<br/>
						server.on('request',&nbsp;(req,&nbsp;res)&nbsp;=&gt;&nbsp;{<br/>
						<span class="class___tab">&#9;</span>if&nbsp;(req.url&nbsp;===&nbsp;'/compute')&nbsp;{<br/>
						<span class="class___tab">&#9;</span><span class="class___tab">&#9;</span>const&nbsp;sum&nbsp;=&nbsp;longComputation();<br/>
						<span class="class___tab">&#9;</span><span class="class___tab">&#9;</span>return&nbsp;res.end(`Sum&nbsp;is&nbsp;${sum}`);<br/>
						<span class="class___tab">&#9;</span>}&nbsp;else&nbsp;{<br/>
						<span class="class___tab">&#9;</span><span class="class___tab">&#9;</span>res.end('Ok')<br/>
						<span class="class___tab">&#9;</span>}<br/>
						});<br/>
						server.listen(3000);
					</div>
					这样做的致命问题是一旦有人访问/compute, 后续请求都无法及时处理, 因为事件循环还被longComputation阻塞着, 直到耗时计算结束才能恢复服务能力
					<br/>
					为了避免耗时操作阻塞主进程的事件循环, 可以把longComputation()拆分到子进程中 :
					<div class="class___code">
						//&nbsp;compute.js<br/>
						const&nbsp;longComputation&nbsp;=&nbsp;()&nbsp;=&gt;&nbsp;{<br/>
						<span class="class___tab">&#9;</span>let&nbsp;sum&nbsp;=&nbsp;0;<br/>
						<span class="class___tab">&#9;</span>for&nbsp;(let&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;1e9;&nbsp;i++)&nbsp;{<br/>
						<span class="class___tab">&#9;</span><span class="class___tab">&#9;</span>sum&nbsp;+=&nbsp;i;<br/>
						<span class="class___tab">&#9;</span>};<br/>
						<span class="class___tab">&#9;</span>return&nbsp;sum;<br/>
						};<br/>
						<br/>
						//&nbsp;开关,&nbsp;收到消息才开始做<br/>
						process.on('message',&nbsp;(msg)&nbsp;=&gt;&nbsp;{<br/>
						<span class="class___tab">&#9;</span>const&nbsp;sum&nbsp;=&nbsp;longComputation();<br/>
						<span class="class___tab">&#9;</span>process.send(sum);<br/>
						});<br/>
					</div>
					主进程开启子进程执行longComputation :
					<div class="class___code">
						const&nbsp;http&nbsp;=&nbsp;require('http');<br/>
						const&nbsp;{&nbsp;fork&nbsp;}&nbsp;=&nbsp;require('child_process');<br/>
						<br/>
						const&nbsp;server&nbsp;=&nbsp;http.createServer();<br/>
						<br/>
						server.on('request',&nbsp;(req,&nbsp;res)&nbsp;=&gt;&nbsp;{<br/>
						<span class="class___tab">&#9;</span>if&nbsp;(req.url&nbsp;===&nbsp;'/compute')&nbsp;{<br/>
						<span class="class___tab">&#9;</span><span class="class___tab">&#9;</span>const&nbsp;compute&nbsp;=&nbsp;fork('compute.js');<br/>
						<span class="class___tab">&#9;</span><span class="class___tab">&#9;</span>compute.send('start');<br/>
						<span class="class___tab">&#9;</span><span class="class___tab">&#9;</span>compute.on('message',&nbsp;sum&nbsp;=&gt;&nbsp;{<br/>
						<span class="class___tab">&#9;</span><span class="class___tab">&#9;</span><span class="class___tab">&#9;</span>res.end(`Sum&nbsp;is&nbsp;${sum}`);<br/>
						<span class="class___tab">&#9;</span><span class="class___tab">&#9;</span>});<br/>
						<span class="class___tab">&#9;</span>}&nbsp;else&nbsp;{<br/>
						<span class="class___tab">&#9;</span><span class="class___tab">&#9;</span>res.end('Ok')<br/>
						<span class="class___tab">&#9;</span>}<br/>
						});<br/>
						<br/>
						server.listen(3000);<br/>
					</div>
					主进程的事件循环不会再被耗时计算阻塞, 但进程数量还需要进一步限制, 否则资源被进程消耗殆尽时服务能力仍会受到影响
					<br/>
					实际上, cluster模块就是对多进程服务能力的封装, 思路与这个简单示例类似
					<br/>
					<br/>
					通信方式
					<br/>
					1.通过stdin/stdout传递json
					<br/>
					stdin/stdout and a JSON payload
					<br/>
					最直接的通信方式, 拿到子进程的handle后, 可以访问其stdio流, 然后约定一种message格式开始愉快地通信 :
					<div class="class___code">
						const&nbsp;{&nbsp;spawn&nbsp;}&nbsp;=&nbsp;require('child_process');<br/>
						<br/>
						child&nbsp;=&nbsp;spawn('node',&nbsp;['./stdio-child.js']);<br/>
						child.stdout.setEncoding('utf8');<br/>
						//&nbsp;父进程-发<br/>
						child.stdin.write(JSON.stringify({<br/>
						<span class="class___tab">&#9;</span>type:&nbsp;'handshake',<br/>
						<span class="class___tab">&#9;</span>payload:&nbsp;'你好吖'<br/>
						}));<br/>
						//&nbsp;父进程-收<br/>
						child.stdout.on('data',&nbsp;function&nbsp;(chunk)&nbsp;{<br/>
						<span class="class___tab">&#9;</span>let&nbsp;data&nbsp;=&nbsp;chunk.toString();<br/>
						<span class="class___tab">&#9;</span>let&nbsp;message&nbsp;=&nbsp;JSON.parse(data);<br/>
						<span class="class___tab">&#9;</span>console.log(`${message.type}&nbsp;${message.payload}`);<br/>
						});<br/>
					</div>
					子进程与之类似 :
					<div class="class___code">
						//&nbsp;./stdio-child.js<br/>
						//&nbsp;子进程-收<br/>
						process.stdin.on('data',&nbsp;(chunk)&nbsp;=&gt;&nbsp;{<br/>
						<span class="class___tab">&#9;</span>let&nbsp;data&nbsp;=&nbsp;chunk.toString();<br/>
						<span class="class___tab">&#9;</span>let&nbsp;message&nbsp;=&nbsp;JSON.parse(data);<br/>
						<span class="class___tab">&#9;</span>switch&nbsp;(message.type)&nbsp;{<br/>
						<span class="class___tab">&#9;</span><span class="class___tab">&#9;</span>case&nbsp;'handshake':<br/>
						<span class="class___tab">&#9;</span><span class="class___tab">&#9;</span><span class="class___tab">&#9;</span>//&nbsp;子进程-发<br/>
						<span class="class___tab">&#9;</span><span class="class___tab">&#9;</span><span class="class___tab">&#9;</span>process.stdout.write(JSON.stringify({<br/>
						<span class="class___tab">&#9;</span><span class="class___tab">&#9;</span><span class="class___tab">&#9;</span><span class="class___tab">&#9;</span>type:&nbsp;'message',<br/>
						<span class="class___tab">&#9;</span><span class="class___tab">&#9;</span><span class="class___tab">&#9;</span><span class="class___tab">&#9;</span>payload:&nbsp;message.payload&nbsp;+&nbsp;'&nbsp;:&nbsp;hoho'<br/>
						<span class="class___tab">&#9;</span><span class="class___tab">&#9;</span><span class="class___tab">&#9;</span>}));<br/>
						<span class="class___tab">&#9;</span><span class="class___tab">&#9;</span><span class="class___tab">&#9;</span>break;<br/>
						<span class="class___tab">&#9;</span><span class="class___tab">&#9;</span>default:<br/>
						<span class="class___tab">&#9;</span><span class="class___tab">&#9;</span><span class="class___tab">&#9;</span>break;<br/>
						<span class="class___tab">&#9;</span>}<br/>
						});<br/>
					</div>
					VS Code进程间通信就采用了这种方式, 具体见access electron API from vscode extension
					<br/>
					明显的限制是需要拿到“子”进程的handle, 两个完全独立的进程之间无法通过这种方式来通信(比如跨应用, 甚至跨机器的场景)
					<br/>
					关于stream及pipe的详细信息, 请查看Node中的流
					<br/>
					2.原生IPC支持
					<br/>
					如spawn()及fork()的例子, 进程之间可以借助内置的IPC机制通信
					<br/>
					父进程 :
					<br/>
					process.on('message')收
					<br/>
					child.send()发
					<br/>
					子进程 :
					<br/>
					process.on('message')收
					<br/>
					process.send()发
					<br/>
					限制同上, 同样要有一方能够拿到另一方的handle才行
					<br/>
					3.sockets
					<br/>
					借助网络来完成进程间通信, 不仅能跨进程, 还能跨机器
					<br/>
					当然, 单机场景下通过网络来完成进程间通信有些浪费性能, 但网络通信的优势在于跨环境的兼容性与更进一步的RPC场景
				</div>
			</section>
			<section>
				<h3>npm install报错提示证书过期 certificate has expired</h3>
				<div>
					npm 报错, 日志中有 certificate has expired
					<br/>
					这是由于连接的服务器的SSL证书已过期, 可以设置npm关闭对SSL证书的检查, 安装后在恢复设置。
					<br/>
					先关闭检查
					<br/>
					npm config set strict-ssl false
					<br/>
					执行npm install 等命令, 然后再开启检查
					<br/>
					npm config set strict-ssl true
				</div>
			</section>
			<section>
				<h3>命令行交互</h3>
				<div>
					<a target="_blank" href="https://lzw.me/a/nodejs-stdin.html">nodeJS 中从命令行等待并读入用户输入实现与用户交互的方法 - 志文工作室</a>
					<div>
						<span style="display : inline-block; border : 1px solid black; width : 14px; text-align : center;">+</span><span>为防链接失效的本地截图</span>
						<div style="display:none;">
							<script>add_fold(document.currentScript);</script>
							<img src="./refs/imgs/nodeJS中从命令行等待并读入用户输入实现与用户交互的方法.png"/>
						</div>
					</div>
				</div>
			</section>
			<section>
				<h3>异常事件捕获</h3>
				<div>
					process.on('uncaughtException', handle_function);
					<br/>
					Warning: Using 'uncaughtException' correctly
					<br/>
					'uncaughtException' is a crude mechanism for exception handling intended to be used only as a last resort. The event should not be used as an equivalent to On Error Resume Next. Unhandled exceptions inherently mean that an application is in an undefined state. Attempting to resume application code without properly recovering from the exception can cause additional unforeseen and unpredictable issues.
					<br/>
					Exceptions thrown from within the event handler will not be caught. Instead the process will exit with a non-zero exit code and the stack trace will be printed. This is to avoid infinite recursion.
					<br/>
					Attempting to resume normally after an uncaught exception can be similar to pulling out the power cord when upgrading a computer. Nine out of ten times, nothing happens. But the tenth time, the system becomes corrupted.
					<br/>
					The correct use of 'uncaughtException' is to perform synchronous cleanup of allocated resources (e.g. file descriptors, handles, etc) before shutting down the process. It is not safe to resume normal operation after 'uncaughtException'.
					<br/>
					To restart a crashed application in a more reliable way, whether 'uncaughtException' is emitted or not, an external monitor should be employed in a separate process to detect application failures and recover or restart as needed.
					<br/>
					“uncaughtException”的正确用法是在关闭进程之前对分配的资源（例如文件描述符、句柄等）执行同步清理。在“未捕获异常”后恢复正常操作是不安全的。
					<br/>
					为了以更可靠的方式重新启动崩溃的应用程序，无论是否发出“uncaughtException”，都应该在单独的过程中使用外部监视器来检测应用程序故障，并根据需要进行恢复或重新启动。
					<br/>
					<br/>
					<br/>
					process.on('rejectionHandled', handle_function);
					<br/>
					process.on('unhandledRejection', handle_function);
					<br/>
					process.on('uncaughtExceptionMonitor', handle_function);
					<br/>
					process.on('multipleResolves', handle_function);
				</div>
			</section>
			<section>
				<h3>多线程</h3>
				<div>
					<a target="_blank" href="https://zhuanlan.zhihu.com/p/74879045">理解Node.js中的"多线程" - 知乎</a>
					<div>
						<span style="display : inline-block; border : 1px solid black; width : 14px; text-align : center;">+</span><span>为防链接失效的本地截图</span>
						<div style="display:none;">
							<script>add_fold(document.currentScript);</script>
							<img src="./refs/imgs/理解NodeJS中的多线程.png"/>
						</div>
					</div>
					<a target="_blank" href="https://blog.csdn.net/z591102/article/details/108096662">深入理解 Node.js 中的 Worker 线程_高先生的猫-CSDN博客_nodejs worker</a>
					<br/>
					<a target="_blank" href="https://www.cnblogs.com/qianxiaox/p/13821936.html">深入理解 Node.js 中的 Worker 线程 - 浅笑· - 博客园</a>
					<div>
						<span style="display : inline-block; border : 1px solid black; width : 14px; text-align : center;">+</span><span>为防链接失效的本地截图</span>
						<div style="display:none;">
							<script>add_fold(document.currentScript);</script>
							<img src="./refs/imgs/深入理解NodeJS中的Worker线程.png"/>
						</div>
					</div>
				</div>
			</section>
			<section>
				<h3>http2</h3>
				<div>
					<a target="_blank" href="https://blog.csdn.net/programerxiaoer/article/details/82713830">HTTP/2简介_码小二的博客-CSDN博客_http2</a>
					<br/>
					<a target="_blank" href="../../web/refs/HTTP2简介.png">HTTP/2简介_码小二的博客-CSDN博客_http2_in_local_image</a>
					<br/>
					参考后可知, http2在同一个域名下只使用一个TCP连接, 这个连接对应nodejs中http2模块里的一个session, 所有的请求都归这个session管理, 每一个请求对对应这个session中的一个stream, 每一个stream可以类似理解为https1.1中的request, stream.respond对应https1.1中的response, 每一个请求会有一个不同的stream id
					<br/>
					通过监听unknownProtocol事件来测试是否支持http版本, 可查看http2session.alpnProtocol的值, 注意在http2.createSecureServer时带上参数allowHTTP1: true
				</div>
			</section>
			<section>
				<h3>windows获取分区盘符</h3>
				<div>
					windows系统中的分区使用单个英文字母，一共才26个，依次检测一下路径是否存在即可，下面为相应的代码:
					<br/>
					<br/>
					get_window_partition.js :
					<div class="class___code">
						const&nbsp;fs&nbsp;=&nbsp;require('fs');<br/>
						<br/>
						const&nbsp;get_window_partition&nbsp;=&nbsp;function()&nbsp;{<br/>
						<span class="class___tab">&#9;</span>let&nbsp;cp&nbsp;=&nbsp;'a'.codePointAt(0);<br/>
						<span class="class___tab">&#9;</span>let&nbsp;count&nbsp;=&nbsp;26;<br/>
						<br/>
						<span class="class___tab">&#9;</span>const&nbsp;result_list&nbsp;=&nbsp;[];<br/>
						<span class="class___tab">&#9;</span>const&nbsp;po&nbsp;=&nbsp;{<br/>
						<span class="class___tab">&#9;</span><span class="class___tab">&#9;</span>resolve&nbsp;:&nbsp;null,<br/>
						<span class="class___tab">&#9;</span><span class="class___tab">&#9;</span>reject&nbsp;:&nbsp;null,<br/>
						<span class="class___tab">&#9;</span>}<br/>
						<span class="class___tab">&#9;</span>const&nbsp;promise&nbsp;=&nbsp;new&nbsp;Promise((resolve,&nbsp;reject)&nbsp;=&gt;&nbsp;{<br/>
						<span class="class___tab">&#9;</span><span class="class___tab">&#9;</span>po.resolve&nbsp;=&nbsp;resolve;<br/>
						<span class="class___tab">&#9;</span><span class="class___tab">&#9;</span>po.reject&nbsp;=&nbsp;reject;<br/>
						<span class="class___tab">&#9;</span>});<br/>
						<span class="class___tab">&#9;</span>for(let&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;count;&nbsp;i++)&nbsp;{<br/>
						<span class="class___tab">&#9;</span><span class="class___tab">&#9;</span>let&nbsp;p&nbsp;=&nbsp;String.fromCodePoint(cp&nbsp;+&nbsp;i);<br/>
						<br/>
						<span class="class___tab">&#9;</span><span class="class___tab">&#9;</span>fs.stat(p&nbsp;+&nbsp;':\\',&nbsp;function(error,&nbsp;stats)&nbsp;{<br/>
						<span class="class___tab">&#9;</span><span class="class___tab">&#9;</span><span class="class___tab">&#9;</span>count--;<br/>
						<span class="class___tab">&#9;</span><span class="class___tab">&#9;</span><span class="class___tab">&#9;</span>if&nbsp;(stats)&nbsp;{<br/>
						<span class="class___tab">&#9;</span><span class="class___tab">&#9;</span><span class="class___tab">&#9;</span><span class="class___tab">&#9;</span>result_list.push(p);<br/>
						<span class="class___tab">&#9;</span><span class="class___tab">&#9;</span><span class="class___tab">&#9;</span>}<br/>
						<span class="class___tab">&#9;</span><span class="class___tab">&#9;</span><span class="class___tab">&#9;</span>if&nbsp;(!count)&nbsp;{<br/>
						<span class="class___tab">&#9;</span><span class="class___tab">&#9;</span><span class="class___tab">&#9;</span><span class="class___tab">&#9;</span>po.resolve(result_list);<br/>
						<span class="class___tab">&#9;</span><span class="class___tab">&#9;</span><span class="class___tab">&#9;</span>}<br/>
						<span class="class___tab">&#9;</span><span class="class___tab">&#9;</span>});<br/>
						<span class="class___tab">&#9;</span>}<br/>
						<span class="class___tab">&#9;</span>return&nbsp;promise;<br/>
						}<br/>
						module.exports&nbsp;=&nbsp;get_window_partition;<br/>
					</div>
					<br/>
					main.js:
					<div class="class___code">
						const&nbsp;get_window_partition&nbsp;=&nbsp;require('./get_window_partition.js');<br/>
						<br/>
						get_window_partition().then((r)&nbsp;=&gt;&nbsp;{<br/>
						<span class="class___tab">&#9;</span>console.log(r);<br/>
						});<br/>
					</div>
				</div>
			</section>
			<section>
				<h3>Node.js Guides</h3>
				<div>
					<a target="_blank" href="https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/">Node.js 事件循环，定时器和 process.nextTick()</a>
				</div>
			</section>
			<section>
				<h3>nodejs当前路径</h3>
				<div>
					path.resolve('./')与process.cwd()等价是运行node命令行时的当前shell路径的绝对路径
					<br/>
					porcess.execPath运行脚本的运行时程序node的绝对路径
					<br/>
					__dirname是运行node命令行时当前js脚本文件的绝对路径, 例如在path_a路径下有一个a.js文件，在path_a/child/路径下有一个b.js文件，在a.js文件中引入了./child/b.js文件，则在a.js文件中__dirname为path_a，在child/b.js文件中__dirname的值为path_a/child/
					<br/>
					举例, 如下代码保存到~/parent_path/child_path/c_path.js:
					<div class="class___code">
						const&nbsp;path&nbsp;=&nbsp;require('path');<br/>
						<br/>
						console.log(`\npath.resolve('./')`);<br/>
						console.log(path.resolve('./'));<br/>
						console.log(`\nprocess.execPath`);<br/>
						console.log(process.execPath);<br/>
						console.log(`\n__dirname`);<br/>
						console.log(__dirname);<br/>
						console.log(`\nprocess.cwd()`);<br/>
						console.log(process.cwd());<br/>
						console.log();<br/>
					</div>
					在~/parent_path/路径下执行node child_path/c_path.js
					<br/>
					结果如下:
					<div class="class___code">
						path.resolve('./')<br/>
						/home/TestUser/parent_path<br/>
						<br/>
						process.execPath<br/>
						/usr/share/node-v11.13.0-linux-x64/bin/node<br/>
						<br/>
						__dirname<br/>
						/home/TestUser/parent_path/child_path<br/>
						<br/>
						process.cwd()<br/>
						/home/TestUser/parent_path<br/>
					</div>
					在~/parent_path/child_path/路径下执行node c_path.js
					<br/>
					结果如下:
					<div class="class___code">
						path.resolve('./')<br/>
						/home/TestUser/parent_path/child_path<br/>
						<br/>
						process.execPath<br/>
						/usr/share/node-v11.13.0-linux-x64/bin/node<br/>
						<br/>
						__dirname<br/>
						/home/TestUser/parent_path/child_path<br/>
						<br/>
						process.cwd()<br/>
						/home/TestUser/parent_path/child_path<br/>
					</div>
				</div>
			</section>
			<section>
				<h3>npm安装包</h3>
				<div>
					国内访问外网都很慢，甚至不能访问！安装Node时自带的npm地址默认是http://registry.npmjs.org, npm install没反应！
					<br/>
					用cnpm代替npm安装并使用国内的镜像库https://registry.npm.taobao.org
					<br/>
					<a target="_blank" href="https://cnpmjs.org/">cnpmjs.org: Private npm registry and web for Company</a>
					<br/>
					<span class="shell_instruction">npm install -g cnpm --registry=https://registry.npm.taobao.org</span>
					<br/>
					<a target="_blank" href="https://github.com/cnpm/cnpm">GitHub - cnpm/cnpm: cnpm: npm client for China mirror of npm</a>
					<br/>
					<a target="_blank" href="https://cnpmjs.org/">cnpmjs.org: Private npm registry and web for Company</a>
					<br/>
					<a target="_blank" href="https://npm.taobao.org/">For developers in China, please visit the China mirror</a>
					<br/>
					但是在一个项目中npm与cnpm不能混用, 即当有些包是用npm安装的则再用cnpm安装其它包会报错, 反之亦然
					<br/>
					可以修改配置来永久设置源的url
					<br/>
					<span class="shell_instruction">npm config set registry https://registry.npm.taobao.org</span>
					<br/>
					可通过如下命令查看源的url
					<br/>
					<span class="shell_instruction">npm config get registry</span>
					<br/>
					或通过查看配置信息来查看
					<br/>
					<span class="shell_instruction">npm config list</span>
					<br/>
					在切换源url时使用修改配置来永久设置源的方式比较麻烦, 可以使用nrm来管理仓库的源<a target="_blank" href="https://www.npmjs.com/package/nrm">nrm - npm</a>
					<br/>
					安装:<span class="shell_instruction">npm install -g nrm</span>
					<br/>
					查看源列表:<span class="shell_instruction">nrm ls</span>
					<br/>
					切换并使用taobao源:<span class="shell_instruction">nrm use taobao</span>
					<br/>
					在安装nrm时也可能因为慢安不上可以在安装时在命令行中指定临时使用的源地址
					<br/>
					<span class="shell_instruction">npm --registry https://registry.npm.taobao.org install -g nrm</span>
					<br/>
					查看源列表:
					<br/>
					<span class="shell_instruction">nrm ls</span>
					<div class="class___code">
						*&nbsp;npm&nbsp;----------&nbsp;https://registry.npmjs.org/<br/>
						&nbsp;&nbsp;&nbsp;yarn&nbsp;---------&nbsp;https://registry.yarnpkg.com/<br/>
						&nbsp;&nbsp;&nbsp;tencent&nbsp;------&nbsp;https://mirrors.cloud.tencent.com/npm/<br/>
						&nbsp;&nbsp;&nbsp;cnpm&nbsp;---------&nbsp;https://r.cnpmjs.org/<br/>
						&nbsp;&nbsp;&nbsp;taobao&nbsp;-------&nbsp;https://registry.npmmirror.com/<br/>
						&nbsp;&nbsp;&nbsp;npmMirror&nbsp;----&nbsp;https://skimdb.npmjs.com/registry/<br/>
					</div>
					代*号的那行表示当前使用的源
					<br/>
					如报错
					<div class="class___code">
						internal/validators.js:120<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;ERR_INVALID_ARG_TYPE(name,&nbsp;'string',&nbsp;value);<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;^<br/>
						<br/>
						[TypeError&nbsp;[ERR_INVALID_ARG_TYPE]:&nbsp;The&nbsp;"path"&nbsp;argument&nbsp;must&nbsp;be&nbsp;of&nbsp;type&nbsp;string.<br/>
						eceived&nbsp;undefined<br/>
						&nbsp;&nbsp;at&nbsp;validateString&nbsp;(internal/validators.js:120:11)<br/>
						&nbsp;&nbsp;at&nbsp;Object.join&nbsp;(path.js:375:7)<br/>
						&nbsp;&nbsp;at&nbsp;Object.&lt;anonymous&gt;&nbsp;(E:\program\nodejs\node-v12.22.1-win-x64\node_modules\n<br/>
						m\cli.js:17:20)<br/>
						&nbsp;&nbsp;at&nbsp;Module._compile&nbsp;(internal/modules/cjs/loader.js:999:30)<br/>
						&nbsp;&nbsp;at&nbsp;Object.Module._extensions..js&nbsp;(internal/modules/cjs/loader.js:1027:10)<br/>
						&nbsp;&nbsp;at&nbsp;Module.load&nbsp;(internal/modules/cjs/loader.js:863:32)<br/>
						&nbsp;&nbsp;at&nbsp;Function.Module._load&nbsp;(internal/modules/cjs/loader.js:708:14)<br/>
						&nbsp;&nbsp;at&nbsp;Function.executeUserEntryPoint&nbsp;[as&nbsp;runMain]&nbsp;(internal/modules/run_main.js:<br/>
						0:12)<br/>
						&nbsp;&nbsp;at&nbsp;internal/main/run_main_module.js:17:47<br/>
						]&nbsp;{<br/>
						&nbsp;&nbsp;code:&nbsp;'ERR_INVALID_ARG_TYPE'<br/>
						}<br/>
					</div>
					根据
					<div class="class___code">
						at&nbsp;Object.&lt;anonymous&gt;&nbsp;(E:\program\nodejs\node-v12.22.1-win-x64\node_modules\n<br/>
						m\cli.js:17:20)<br/>
					</div>
					找到cli.js 第17行修改成
					<div class="class___code">
						//&nbsp;const&nbsp;NRMRC&nbsp;=&nbsp;path.join(process.env.HOME,&nbsp;'.nrmrc');<br/>
						const&nbsp;NRMRC&nbsp;=&nbsp;path.join(process.env[(process.platform&nbsp;==&nbsp;'win32')&nbsp;?&nbsp;'USERPROFILE'&nbsp;:&nbsp;'HOME'],&nbsp;'.nrmrc');<br/>
					</div>
					<br/>
					也可用
					<br/>
					<span class="shell_instruction">nrm current</span>
					<br/>
					可通过如下命令查看nrm模块信息
					<br/>
					<span class="shell_instruction">npm info nrm</span>
					关于如何使用nrm
				</div>
			</section>
			<section>
				<h3>控制台输出信息不换行</h3>
				<div>
					console.log()函数输出的信息会自动换行
					<br/>
					console.log()函数内部调用process.stdout.write()函数
					<br/>
					console.error()函数内部调用process.stderr.write()函数
					<br/>
					process.stdout与process.stderr都是Writeable_Stream类的实例
					<br/>
					直接用process.stdout.write代替console.log即可
				</div>
			</section>
			<section>
				<h3>控制台格式控制</h3>
				<div>
					<!--参考bash_shell中的<a target="_blank" href="../linux/bash_shell.html#id___console__color_with_format">"输出带颜色的文字及控制台格式控制"</a>-->
					参考bash_shell中的<a target="_blank" href="../linux/bash_shell.html#id___输出带颜色的文字及控制台格式控制">"输出带颜色的文字及控制台格式控制"</a>
					<br/>
					但在bash_shell中与\033等价的\e不能识别为转义序列开启符号而是输出e
					<br/>
					但在bash_shell中与\033等价的\0x1b不能识别为转义序列开启符号而是输出x1b
					<br/>
					所以只用\033
				</div>
			</section>
			<section>
				<h3>控制台输出颜色等格式控制</h3>
				<div>
					<!--参考bash_shell中的<a target="_blank" href="../linux/bash_shell.html#id___console__color_with_format">"输出带颜色的文字及控制台格式控制"</a>-->
					参考bash_shell中的<a target="_blank" href="../linux/bash_shell.html#id___输出带颜色的文字及控制台格式控制">"输出带颜色的文字及控制台格式控制"</a>
					<br/>
					但在bash_shell中与\033等价的\e不能识别为转义序列开启符号而是输出e
					<br/>
					但在bash_shell中与\033等价的\0x1b不能识别为转义序列开启符号而是输出x1b
					<br/>
					所以只用\033
				</div>
			</section>
			<section>
				<h3>Use chrome browser to debuge node.js program</h3>
				<div>
					log date 2017-09-05
					<div>
						--------------------------------------------------<br/>
						in&nbsp;the&nbsp;node&nbsp;server<br/>
						run&nbsp;the&nbsp;node&nbsp;program&nbsp;with&nbsp;--inspect=host:port<br/>
						for&nbsp;example<br/>
						node&nbsp;--inspect=192.168.173:9229&nbsp;index.js<br/>
						note&nbsp;:&nbsp;the&nbsp;--inspect&nbsp;option&nbsp;must&nbsp;before&nbsp;script&nbsp;file&nbsp;name,&nbsp;else&nbsp;the&nbsp;chrome&nbsp;can't&nbsp;find&nbsp;the&nbsp;node&nbsp;program<br/>
						<span class="class___tab">&#9;</span><span class="class___tab">&#9;</span>if&nbsp;the&nbsp;host&nbsp;is&nbsp;ignore&nbsp;or&nbsp;set&nbsp;to&nbsp;127.0.0.1&nbsp;then&nbsp;the&nbsp;remote&nbsp;chrome&nbsp;could&nbsp;not&nbsp;find&nbsp;this&nbsp;node&nbsp;program<br/>
						<span class="class___tab">&#9;</span><span class="class___tab">&#9;</span><br/>
						see&nbsp;the&nbsp;node.js&nbsp;api&nbsp;"Command&nbsp;Line&nbsp;Option"<br/>
						<br/>
						--inspect[=[host:]port]<br/>
						#<br/>
						Added&nbsp;in:&nbsp;v6.3.0<br/>
						<br/>
						Activate&nbsp;inspector&nbsp;on&nbsp;host:port.&nbsp;Default&nbsp;is&nbsp;127.0.0.1:9229.<br/>
						<br/>
						V8&nbsp;inspector&nbsp;integration&nbsp;allows&nbsp;tools&nbsp;such&nbsp;as&nbsp;Chrome&nbsp;DevTools&nbsp;and&nbsp;IDEs&nbsp;to&nbsp;debug&nbsp;and&nbsp;profile&nbsp;Node.js&nbsp;instances.&nbsp;The&nbsp;tools&nbsp;attach&nbsp;to&nbsp;Node.js&nbsp;instances&nbsp;via&nbsp;a&nbsp;tcp&nbsp;port&nbsp;and&nbsp;communicate&nbsp;using&nbsp;the&nbsp;Chrome&nbsp;Debugging&nbsp;Protocol.<br/>
						--inspect-brk[=[host:]port]<br/>
						#<br/>
						Added&nbsp;in:&nbsp;v7.6.0<br/>
						<br/>
						Activate&nbsp;inspector&nbsp;on&nbsp;host:port&nbsp;and&nbsp;break&nbsp;at&nbsp;start&nbsp;of&nbsp;user&nbsp;script.&nbsp;Default&nbsp;host:port&nbsp;is&nbsp;127.0.0.1:9229.<br/>
						--inspect-port=[host:]port<br/>
						#<br/>
						Added&nbsp;in:&nbsp;v7.6.0<br/>
						<br/>
						Set&nbsp;the&nbsp;host:port&nbsp;to&nbsp;be&nbsp;used&nbsp;when&nbsp;the&nbsp;inspector&nbsp;is&nbsp;activated.&nbsp;Useful&nbsp;when&nbsp;activating&nbsp;the&nbsp;inspector&nbsp;by&nbsp;sending&nbsp;the&nbsp;SIGUSR1&nbsp;signal.<br/>
						<br/>
						Default&nbsp;host&nbsp;is&nbsp;127.0.0.1.<br/>
						--------------------------------------------------<br/>
						open&nbsp;chrome&nbsp;browser<br/>
						Open&nbsp;the&nbsp;chrome://flags/#enable-devtools-experiments&nbsp;URL<br/>
						Enable&nbsp;the&nbsp;Developer&nbsp;Tools&nbsp;experiments&nbsp;flag<br/>
						Relaunch&nbsp;Chrome<br/>
						//Open&nbsp;DevTools&nbsp;Setting&nbsp;-&gt;&nbsp;Experiments&nbsp;tab&nbsp;(it&nbsp;started&nbsp;being&nbsp;visible&nbsp;after&nbsp;the&nbsp;reload)<br/>
						//Press&nbsp;"SHIFT"&nbsp;6&nbsp;times&nbsp;(enjoy&nbsp;it&nbsp;¯&nbsp;\&nbsp;_&nbsp;(ツ)&nbsp;_&nbsp;/&nbsp;¯)&nbsp;to&nbsp;show&nbsp;the&nbsp;hidden&nbsp;experiments<br/>
						//Check&nbsp;the&nbsp;"Node&nbsp;debugging"&nbsp;checkbox<br/>
						<br/>
						Open&nbsp;chrome://inspect&nbsp;url<br/>
						select&nbsp;left&nbsp;menu&nbsp;Devices&nbsp;item<br/>
						<br/>
						click&nbsp;"Open&nbsp;dedicated&nbsp;DevTools&nbsp;for&nbsp;Node"<br/>
						select&nbsp;connection<br/>
						or<br/>
						click&nbsp;"Configure..."<br/>
						<br/>
						add&nbsp;the&nbsp;remote&nbsp;pc&nbsp;ip:port,&nbsp;like&nbsp;192.168.173:9229<br/>
						<br/>
						wait&nbsp;a&nbsp;moment<br/>
						<br/>
						in&nbsp;the&nbsp;chrome://inspect/#devices&nbsp;url's&nbsp;page&nbsp;will&nbsp;show&nbsp;the&nbsp;target<br/>
						click&nbsp;the&nbsp;"inspect"<br/>
					</div>
				</div>
			</section>
		</article>
	</body>
</html>
