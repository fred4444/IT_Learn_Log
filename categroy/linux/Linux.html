<!doctype html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0,minimum-scale=1.0,user-scalable=0" />
		<title>Linux</title>
		<style>
			.class___line_head {
				margin-left : 2em;
			}
			.class___tab_place {
				margin-left : 2em;
			}
			.class___center {
				text-align : center;
				width : 100%;
				display : inline-block;
			}
			.shell_instruction {
				color : yellow;
				background-color : black;
				font-weight : 800;
				padding : 4px;
			}
			section > p {
				padding-left : 2em;
				line-height : 180%;
			}
			section > div {
				padding-left : 2em;
				line-height : 180%;
			}
		</style>
		<script>
		</script>
	</head>
	<body>
		<article>
			<header>
				<h3>Linux</h3>
				<p>
					Linux spread log.
				</p>
			</header>
			<section>
				<h3>tar過濾部分文件打包</h3>
				<p>
					<a target="_blank" href="refs/tar__exclude_file.pdf">參考文檔</a>
				</p>
			</section>
			<section>
				<h3>查看Linux内核版本的命令</h3>
				<p>
					<span class="shell_instruction">uname -a</span>
					<br/>
					查看系统内核版本号及系统名称
					<br/>
					or
					<br/>
					<span class="shell_instruction">cat /proc/version</span>
					<br/>
					查看目录"/proc"下version的信息，也可以得到当前系统的内核版本号及系统名称
					<br/>
					补充说明:/proc文件系统，它不是普通的文件系统，而是系统内核的映像，也就是说，该目录中的文件是存放在系统内存之中的，它以文件系统的方式为访问系统内核数 据的操作提供接口。而我们使用命令“uname -a"的信息就是从该文件获取的，当然用方法二的命令直接查看它的内容也可以达到同等效果.另外，加上参数"a"是获得详细信息，如果不加参数为查看系统名称。
				</p>
			</section>
			<section>
				<h3>關機及重啟</h3>
				<p>
					關機
					<br/>
					<span class="shell_instruction">poweroff</span>
					<br/>
					or
					<br/>
					<span class="shell_instruction">shutdown -P now</span>
					<br/>
					or
					<br/>
					<span class="shell_instruction">shutdown -h now</span>
					<br/>
					或參考
					<br/>
					<span class="shell_instruction">man shutdown</span>
					<br/>
					10分鐘後關機
					<br/>
					<span class="shell_instruction">shutdown -h +10</span>
					<br/>
					18:30關機
					<br/>
					<span class="shell_instruction">shutdown -h 18:30</span>
					<br/>

					
					<br/>
					<br/>
					重啟
					<br/>
					<span class="shell_instruction">reboot</span>
					<br/>
					or
					<br/>
					<span class="shell_instruction">shutdown -r now</span>
					<br/>
					或參考
					<br/>
					<span class="shell_instruction">man shutdown</span>
					<br/>
					10分鐘後重啟
					<br/>
					<span class="shell_instruction">shutdown -r +10</span>
					<br/>
					18:30重啟
					<br/>
					<span class="shell_instruction">shutdown -r 18:30</span>
				</p>
			</section>
			<section>
				<h3>ctrl+z(挂起),jobs(任务),fg(前台),bg(后台),kill(终止进程)</h3>
				<p>
					ctrl+z
					<br/>
					ctrl+z挂起前台命令暂停执行，回到shell命令行环境中
				</p>
				<p>
					jobs
					<br/>
					察看当前shell下运行的所有程序；带+表示最新的jobs；带-表示次新的jobs；其他jobs不带符号
				</p>
				<p>
					bg %n
					<br/>
					将第n个job放到后台运行
				</p>
				<p>
					bg
					<br/>
					将最后挂起的命令放到后台运行
				</p>
				<p>
					fg %n
					<br/>
					将第n个job返回前台运行
				</p>
				<p>
					fg
					<br/>
					将最后挂起的命令返回前台运行
				</p>
				<p>
					kill %n
					<br/>
					杀死第n个job，不再执行
				</p>
			</section>
			<section>
				<h3>创建iso文件</h3>
				<p>
					use mkisofs create iso file
				</p>
				<p>
					<span class="shell_instruction">mkisofs -r -o mongodb_linux_x86_64_4.0.7.iso mongodb_linux_x86_64_4.0.7.tgz</span>
					<br/>
					-r : 设置所有文件拥有读取权限
					<br/>
					-o : 在后面指定输出的iso文件的路径及文件名
				</p>
				<p>
					use dd copy device content to file
				</p>
				<p>
					<span class="shell_instruction">dd if=/dev/cdrom of=vcd.iso</span>
					<br/>
					if : 数据源块路径
					<br/>
					of : 输出文件的路径及文件名
				</p>
			</section>
			<section>
				<h3>查看系统配置信息</h3>
				<div>
					#硬件信息
					<br/>
					dmidecode
					<br/>
					#模块信息
					<br/>
					dmesg
					<br/>
					#查看分区信息如uuid等
					<br/>
					blkid
					<br/>
					#查看外存及分区信息
					<br/>
					lsblk
					<br/>
					#查看usb设备
					<br/>
					lsusb
				</div>
			</section>
			<section>
				<h3>设置分区的标签</h3>
				<p>
					#ext2/ext3/ext4
					<br/>
					<span class="shell_instruction">e2label [&lt;device&gt;] [&lt;new_label&gt;]</span>
					<br/>
					#xfs
					<br/>
					<span class="shell_instruction">xfs_admin -L [&lt;new_label&gt;] [&lt;device&gt;]</span>
					<br/>
					#jfs
					<br/>
					<span class="shell_instruction">jfs_tune -L [&lt;new_label&gt;] [&lt;device&gt;]</span>
					<br/>
					#Btrfs
					<br/>
					<span class="shell_instruction">btrfs filesystem label [&lt;device&gt;] [&lt;new_label&gt;]</span>
					<br/>
					#or
					<br/>
					<span class="shell_instruction">btrfs-filesystem label [&lt;device&gt;|&lt;mountpoint&gt;] [&lt;new_label&gt;]</span>
					<br/>
					#ReiserFS
					<br/>
					<span class="shell_instruction">reiserfstune -l [&lt;new_label&gt;] [&lt;device&gt;]</span>
					<br/>
					#swap
					<br/>
					<span class="shell_instruction">mkswap -L [&lt;new_label&gt;] [&lt;device&gt;]</span>
					<br/>
					#ntfs
					<br/>
					<span class="shell_instruction">ntfslabel [&lt;device&gt;] [&lt;new_label&gt;]</span>
					<br/>
					#for example set sda5 label is home
					<br/>
					<span class="shell_instruction">ntfslabel /dev/sda7 home</span>
				</p>
			</section>
			<section>
				<h3>添加和删除用户</h3>
				<p>
					#添加用户angular4
					<br/>
					<span class="shell_instruction">adduser angular4</span>
					<br/>
					#添加用户组angular
					<br/>
					<span class="shell_instruction">groupadd angular</span>
					<br/>
					#设置用户angular4所在组为angular
					<br/>
					<span class="shell_instruction">usermod -g angular angular4</span>
					<br/>
					<br/>

					#查看用户组
					<br/>
					<span class="shell_instruction">vim /etc/group</span>
					<br/>
					#删除用户组
					<br/>
					<span class="shell_instruction">groupdel angular</span>
					<br/>
					<span class="shell_instruction">groupdel angular4</span>
					<br/>
					#删除用户
					<br/>
					<span class="shell_instruction">userdel angular4</span>
					<br/>
					<span class="shell_instruction">rm -rf /home/angular4</span>
					<br/>
					#if add this user again will got error
					<br/>
					#Creating mailbox file: File exists
					<br/>
					<span class="shell_instruction">find / -name angular4</span>
					<br/>
					#the result include /var/spool/mail/angular4
					<br/>
					<span class="shell_instruction">rm -rf /var/spool/mail/angular4</span>
					<br/>
					<br/>

					#set user password
					<br/>
					<span class="shell_instruction">passwd angular4</span>
					<br/>
					<br/>

					#delete user password
					<br/>
					<span class="shell_instruction">passwd -d angular4</span>
				</p>
			</section>
			<section>
				<h3>change run level</h3>
				<p>
					#before CentOS 7 is change /etc/inittab file, but from CentOS 7 is no longer use this, the new run level is in /usr/lib/systemd/system/*.target
					<br/>
					#see current run level
					<br/>
					<span class="shell_instruction">systemctl list-units --type=target</span>
					<br/>
					#change run level to 3 level is
					<br/>
					<span class="shell_instruction">systemctl isolate multi-user.target</span>
					<br/>
					#change default run level to 3 level is
					<br/>
					<span class="shell_instruction">systemctl set-default multi-user.target</span>
					<br/>
					#old run level with new target relation is
					<br/>
					<span style="color : blue">
						runlevel0.target -&gt; poweroff.target
						<br/>
						runlevel1.target -&gt; rescue.target
						<br/>
						runlevel2.target -&gt; multi-user.target
						<br/>
						runlevel3.target -&gt; multi-user.target
						<br/>
						runlevel4.target -&gt; multi-user.target
						<br/>
						runlevel5.target -&gt; graphical.target
						<br/>
						runlevel6.target -&gt; reboot.target
					</span>
					<br/>
					#can use the follow instruction to see all the target
					<br/>
					<span class="shell_instruction">ls -lh /usr/lib/systemd/system/*.target</span>
				</p>
			</section>
			<section>
				<h3>CentOS 7 suspend and hibernate</h3>
				<div>
					<span class="shell_instruction">systemctl suspend</span>
					<br/>
					<span class="shell_instruction">systemctl hibernate</span>
				</div>
			</section>
			<section>
				<h3>open port in iptabls or firewalld</h3>
				<p>
					#iptables is(in CentOS 7 not use this):
					<br/>
					#add a data receive rule
					<br/>
					<span class="shell_instruction">iptables -A INPUT -p tcp --dport 22 -j ACCEPT</span>
					<br/>
					#add a data post rule
					<br/>
					<span class="shell_instruction">iptables -A OUTPUT -p tcp --sport 22 -j ACCEPT</span>
					<br/>
					#restart iptables service
					<br/>
					<span class="shell_instruction">service sshd restart</span>
					<br/>
					<br/>

					#firewalld is(in CentOS 7 use this):
					<br/>
					#add a rule, with option parameter --permanent to persistent the rule
					<br/>
					<span class="shell_instruction">firewall-cmd --permanent --add-port=22/tcp</span>
					<br/>
					#restart firewalld service
					<br/>
					<span class="shell_instruction">systemctl restart firewalld</span>
					<br/>
					#ensure the new rule is active
					<br/>
					<span class="shell_instruction">firewall-cmd --query-port=22/tcp</span>
					<br/>
				</p>
			</section>
			<section>
				<h3>set sshd service start with OS boot and start at now</h3>
				<p>
					#query ssdh service status
					<br/>
					<span class="shell_instruction">systemctl status sshd</span>
					<br/>
					#output the follow information
					<br/>
					<span style="color : blue">
					● sshd.service - OpenSSH server daemon
					<br/>
					&nbsp;&nbsp;&nbsp;Loaded: loaded (/usr/lib/systemd/system/sshd.service; disabled; vendor preset: enabled)
					<br/>
					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Active: inactive (dead)
					<br/>
				    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Docs: man:sshd(8)
					<br/>
				    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;man:sshd_config(5)
					</span>
					<br/>
					#so we see the Loaded: loaded (/usr/lib/systemd/system/sshd.service; disabled; vendor preset: enabled)
					<br/>
					#the service is not start with OS boot, so we set it start with OS boot
					<br/>
					<span class="shell_instruction">systemctl enable sshd</span>
					<br/>
					#we also see Active: inactive (dead), that means the service is not run at current time, we start it at now
					<br/>
					<span class="shell_instruction">systemctl start sshd</span>
					<br/>
				</p>
			</section>
			<section>
				<h3>双系统, 修复windows启动项</h3>
				<p>
					修改/boot/grub2/grub.cfg
					<br/>
					找到在两个menuentry末尾添加一个win7启动设置，具体参数是
					<br/>
					menuentry	‘win7’{
						<br/>
						<span class="class___tab_place"></span>set root=(hd0,1)
						<br/>
						<span class="class___tab_place"></span>chainloader +1 
						<br/>
					}
				</p>
			</section>
			<section>
				<h3>关闭触控板</h3>
				<p>
					synclient touchpadoff=1
				</p>
			</section>
			<section>
				<h3>清屏命令</h3>
				<p>
					<span class="shell_instruction">clear</span>
					<br/>
					or
					<br/>
					ctrl + l
					<br/>
					刷新屏幕，本质上只是让终端显示页向后翻了一页，如果向上滚动屏幕还可以看到之前的操作信息。
				</p>
				<p>
					<span class="shell_instruction">reset</span>
					<br/>
					完全刷新终端屏幕，之前的终端输入操作信息将都会被清空，这样虽然比较清爽，但整个命令过程速度有点慢，使用较少。
					<br/>
					值得一提的是reset命令在你的终端控制错乱时非常有用。如输入字符不出现在光标的位置的情况。还有当你敲击回车键时，新提示符并没有出现在新行上而是出现在老提示符的前面。此时reset命令就能用来修正这些问题。
				</p>
				<p>
					<span class="shell_instruction">printf '\033c'</span>
					<br/>
					真正的清空了终端屏幕，它的功能跟DOS里CMD.EXE提供的CLS效果很相似。
					<br/>
					工作原理是
					<br/>
					\033  ==  \x1B == 27 == ESC
					<br/>
					于是，这个命令变成了<ESC>c，它是VT-XXX中表示“Full Reset (RIS)”的转义码。现今我们使用的所有的终端都是VT兼容的，它的另一种实现方式也可以这样：
					<br/>
					键盘上Ctrl+v---&gt;Esc--&gt;输入c再回加。但如果你发现自己使用的是一个非常奇怪的终端（如在putty上），那这个命令你可能用不了。
					<br/>
					 printf是bash里内置的命令，内置命令的优先级比其它可执行文件要高。
				</p>
			</section>
			<section>
				<h3>操作目录命令</h3>
				<p>
					回到刚才的目录
					<br/>
					<span class="shell_instruction">cd -</span>
				</p>
				<p>
					目录压栈
					<br/>
					<span class="shell_instruction">pushd .</span>
				</p>
				<p>
					目录出栈
					<br/>
					<span class="shell_instruction">popd</span>
				</p>
			</section>
			<section>
				<h3>查看内存</h3>
				<p>
					<span class="shell_instruction">free</span>
				</p>
			</section>
			<section>
				<h3>帮助,查找命令</h3>
				<p>
					<span class="shell_instruction">man -k key_word</span>
					<br/>
					-k : 列出包含在下一个参数中的字符的命令
				</p>
			</section>
			<section>
				<h3>生成ssh协议秘钥</h3>
				<p>
					use ssh-keygen instruction
				</p>
				<p>
					<span class="shell_instruction">ssh-keygen -t rsa -C email@domain</span>
					<br/>
					-t : 在下一个参数中指定加密算法
					<br/>
					-C : 在下一个参数中指定注释
				</p>
			</section>
			<section>
				<h3>encrypt and decrypt file with symmetric algorithm(文件加密解密使用对称算法)</h3>
				<p>
					use openssl, encrypt file by the follow instruction
				</p>
				<p>
					<span class="shell_instruction">openssl enc -des3 -a -salt -in source_file -out target_file [-pass password]</span>
					<br/>
					-des3 : 为加密算法(可以根据自己需要选择).
					<br/>
					-a : 对加密后的数据进行base64编码，或解密前，先对数据进行base64解码.
					<br/>
					-salt : 加盐,这是一个神奇的选项，加盐后，相同的明文可以得到不同的密文。默认情况下，盐值是随机生成的，可以使用-S选项明确指定盐值.
					<br/>
					-in : 在下一个参数中指定要加密的源文件.
					<br/>
					-out : 在下一个参数中指定加密后的文件.
					<br/>
					-pass : 在下一个参数中指定密码, 不加此参数则会在运行时等待用户输入密码,并以*号显示.
				</p>
				<p>
					use openssl, decrypt file by the follow instruction
				</p>
				<p>
					<span class="shell_instruction">openssl enc -d -des3 -a -salt -in source_file -out target_file [-pass password]</span>
					<br/>
					-d : 解密.
					<br/>
					-des3 : 为加密算法(可以根据自己需要选择).
					<br/>
					-a : 对加密后的数据进行base64编码，或解密前，先对数据进行base64解码.
					<br/>
					-salt : 加盐,这是一个神奇的选项，加盐后，相同的明文可以得到不同的密文。默认情况下，盐值是随机生成的，可以使用-S选项明确指定盐值.
					<br/>
					-in : 在下一个参数中指定要加密的源文件.
					<br/>
					-out : 在下一个参数中指定加密后的文件.
					<br/>
					-pass : 在下一个参数中指定密码, 不加此参数则会在运行时等待用户输入密码,并以*号显示.
				</p>
			</section>
		</article>
	</body>
</html>
