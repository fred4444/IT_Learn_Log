<!doctype html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0,minimum-scale=1.0,user-scalable=0" />
		<title>third party js</title>
		<style>
			.class___line_head {
				margin-left : 2em;
			}
			.class___code {
				color : yellow;
				background-color : black;
				line-height : 24px;
				font-size : 18px;
				vertical-align : bottom;
				white-space : nowrap;
				overflow-x : auto;
			}
			.class___tab {
				display : inline-block;
				width : 4ex;
				overflow-x : hidden;
				line-height : 24px;
				font-size : 18px;
				vertical-align : bottom;
				white-space : pre-wrap;
			}
			.class___code_last_line {
				display : inline-block;
				white-space : nowrap;
			}
			.shell_instruction {
				color : yellow;
				background-color : black;
				font-weight : 800;
				padding : 4px;
			}
			section {
				margin-top : 60px;
			}
			section > div {
				padding-left : 2em;
				line-height : 180%;
			}
			#id___textarea___input_source_code {
				height : 100px;
				width : calc(100% - 6px);
				margin-bottom : 10px;
			}
			#id___textarea___output_html_code {
				height : 100px;
				width : calc(100% - 6px);
				margin-top : 10px;
			}
		</style>
		<style>
			#id___protptype_chain .class___prototype_chain__grid__item {
				width : 500px;
				display : grid;
				grid-template-columns : 20px 460px 20px;
				border : 1px solid black;
				text-align : center;
				position : absolute
			}
			#id___protptype_chain .class___prototype_chain__grid__item div {
				overflow-x : auto;
				border : 1px solid black;
				white-space : nowrap;
			}
			#id___protptype_chain .class___prototype_chain__grid__function {
				color : green;
				border-color : green;
			}
			#id___protptype_chain .class___prototype_chain__grid__function div {
				border-color : green;
			}
		</style>
		<script>
			convert_code_to_html = () => {
				let source = document.getElementById('id___textarea___input_source_code');
				let target = document.getElementById('id___textarea___output_html_code');
				let s = source.value;
				//console.log(s);
				s = s.trim();
				s = s.replace(/\r/g, '');
				s = s.replace(/&/g, '&amp;');
				s = s.replace(/ /g, '&nbsp;');
				s = s.replace(/>/g, '&gt;');
				s = s.replace(/</g, '&lt;');
				s = s.replace(/\t/g, '<span class="class___tab">&#9;</span>');
				s = s.replace(/\n/g, '<br/>\n');
				s = s.replace(/\n/g, '\n\t');
				s += '<br/>';
				//console.log(s);
				target.value = '<div class="class___code">\n\t' + s + '\n</div>';
			}
			window.onload = (e) => {
				let button = document.getElementById('id___button___convert_code_to_html');
				//console.log(button);
				button.addEventListener('click', convert_code_to_html, false);
			}
		</script>
	</head>
	<body>
		<article>
			<header>
				<h3>javascript third party</h3>
				<p>
					//
				</p>
			</header>
			<section>
				<h3>代码转换</h3>
				<div>
					<textarea id="id___textarea___input_source_code"></textarea>
					<br/>
					<button id="id___button___convert_code_to_html">轉換</button>
					<br/>
					<textarea id="id___textarea___output_html_code"></textarea>
				</div>
			</section>
			<section>
				<h3>node.js接收formdata数据</h3>
				<div>
					参考
					<br/>
					<a target="_blank" href="https://www.npmjs.com/package/busboy">npm busboy</a>
					<br/>
					<a target="_blank" href="https://github.com/mscdex/busboy">github busboy</a>
					<br/>
					<a target="_blank" href="https://www.npmjs.com/package/async-busboy">npm async-busboy</a>
					<br/>
					<a target="_blank" href="https://github.com/m4nuC/async-busboy">github async-busboy</a>
					<br/>
					类型formdata发送的请求报文中的属性是没有类型的, 无法区分数值, 字符串, 数组, 数组套数组, 例如[1, 2, ["3"], 4]和[1, 2, 3, 4]的收到的报文内容是一样的, 所以要想区分这些可以在浏览器端将所有除文件外的所有属性放在一个对象中然后将这个对象用JSON.stringify(obj)转成字符串在指定一个属性名称用formdata.append存入, 在服务端读取这个指定名称的属性然后将属性值用JSON.parse解析出来即可
					<br/>
					注意在接收请求报文时相应的属性是有顺序的, 将文件内容属性放在后面, 这样在服务端接收到文件内容之前可以读出所有除文件内容的属性值, 在文件很大时将文件的内容按流式处理不要一次性全读出来避免内存占用过大.
				</div>
			</section>
			<section>
				<h3>vscode</h3>
				<div>
					linux环境下在vscode中调试nodejs代码时若打开的路径是用软链接时会导致断点无法绑定(Breakpoint set but not yet bound)
					<br/>
					例如:
					<br/>
					代码文件夹的真实路径为:~/true_path/code/nodejs_code
					<br/>
					~/soft_link -&gt; ~/true_path/code/nodejs_code
					<br/>
					在vscode中打开~/soft_link文件夹则会导致断点无法绑定
				</div>
			</section>
			<section>
				<h3>webpack</h3>
				<div>
					在webpack 4.42.1版本中json文件不需要在配置文件中配置loader, 直接使用就可, 若配置了loader则会报错
				</div>
			</section>
			<section>
				<h3>解析office文档及pdf等</h3>
				<div>
					textract a text extraction node module.
					<br/>
					textract能够解析如下类型的文件:
					<br/>
					HTML, HTM
					<br/>
					ATOM, RSS
					Markdown
					<br/>
					EPUB
					<br/>
					XML, XSL
					<br/>
					PDF
					<br/>
					DOC, DOCX
					<br/>
					ODT, OTT (experimental, feedback needed!)
					<br/>
					RTF
					<br/>
					XLS, XLSX, XLSB, XLSM, XLTX
					<br/>
					CSV
					ODS, OTS
					<br/>
					PPTX, POTX
					<br/>
					ODP, OTP
					<br/>
					ODG, OTG
					<br/>
					PNG, JPG, GIF
					<br/>
					DXF
					<br/>
					application/javascript
					<br/>
					All text/* mime-types.
					<br/>
					<br/>
					参考地址如下:
					<br/>
					npm : <a target="_blank" href="https://www.npmjs.com/package/textract">https://www.npmjs.com/package/textract</a>
					<br/>
					github : <a target="_blank" href="https://github.com/dbashford/textract">https://github.com/dbashford/textract</a>
					<br/>
					<br/>
					<br/>
					pdf2json is a node.js module that parses and converts PDF from binary to json format, it's built with pdf.js and extends it with interactive form elements and text content parsing outside browser.
					<br/>
					参考地址如下:
					<br/>
					npm : <a target="_blank" href="https://www.npmjs.com/package/pdf2json">https://www.npmjs.com/package/pdf2json</a>
					<br/>
					github : <a target="_blank" href="https://github.com/modesty/pdf2json">https://github.com/modesty/pdf2json</a>


					<br/>
					<br/>
					<br/>
					其它参考文献:
					<a target="_blank" href="https://www.cnblogs.com/jackson-yqj/p/10329448.html">NodeJs之word文件生成与解析</a>
				</div>
			</section>
			<section>
			<section>
				<h3>microsoft office</h3>
				<div>
					docxtemplater is a library to generate docx/pptx documents from a docx/pptx template. It can replace {placeholders} with data and also supports loops and conditions. The templates can be edited by non-programmers, for example your clients.
					<br/>
					docxtemplater 支持node.js端和浏览器端根据word文件模板替换{placeholders}形式的占位符生成新的word文件, ppt亦同
					<br/>
					npm : <a target="_blank" href="https://www.npmjs.com/package/docxtemplater">https://www.npmjs.com/package/docxtemplater</a>
					<br/>
					github : <a target="_blank" href="https://github.com/open-xml-templating/docxtemplater">https://github.com/open-xml-templating/docxtemplater</a>
					<br/>
					网址1: <a target="_blank" href="https://docxtemplater.com/">https://docxtemplater.com/</a>
					<br/>
					document: <a target="_blank" href="https://docxtemplater.readthedocs.io/en/latest/generate.html">https://docxtemplater.readthedocs.io/en/latest/generate.html</a>
					<br/>
					<a target="_blank" href="./refs/docxtemplater/docxtemplater-master.zip">docxtemplater源代码</a>
					<br/>
					<br/>
					nodejs端先安装
					<br/>
					<span class="shell_instruction">cnpm install --save docxtemplater pizzip</span>
					<br/>
					编写word模板文档, 打开word输入内容, 并设置好格式, 如图:
					<br/>
					<img target="_blank" src="./refs/docxtemplater/docxtemplater_word_template_file.png"/>
					<br/>
					其中的{name}是一个占位符, 占位符的名称是"name", 后面生成的文件{name}会被整个替换, {value}相似
					<br/>
					编写代码:
					<div class="class___code">
						const&nbsp;fs&nbsp;=&nbsp;require('fs');<br/>
						const&nbsp;path&nbsp;=&nbsp;require('path');<br/>
						<br/>
						const&nbsp;PizZip&nbsp;=&nbsp;require('pizzip');<br/>
						const&nbsp;Docxtemplater&nbsp;=&nbsp;require('docxtemplater');<br/>
						<br/>
						try&nbsp;{<br/>
						<span class="class___tab">&#9;</span>let&nbsp;content&nbsp;=&nbsp;fs.readFileSync('./test.docx');<br/>
						<br/>
						<span class="class___tab">&#9;</span>const&nbsp;zip_i&nbsp;=&nbsp;new&nbsp;PizZip(content);<br/>
						<br/>
						<span class="class___tab">&#9;</span>let&nbsp;doc&nbsp;=&nbsp;new&nbsp;Docxtemplater(zip_i);<br/>
						<span class="class___tab">&#9;</span>doc.setData({<br/>
						<span class="class___tab">&#9;</span><span class="class___tab">&#9;</span>name&nbsp;:&nbsp;'测试用名称',<br/>
						<span class="class___tab">&#9;</span><span class="class___tab">&#9;</span>value&nbsp;:&nbsp;'test value'<br/>
						<span class="class___tab">&#9;</span>});<br/>
						<span class="class___tab">&#9;</span>doc.render();<br/>
						<span class="class___tab">&#9;</span>const&nbsp;zip_o&nbsp;=&nbsp;doc.getZip();<br/>
						<span class="class___tab">&#9;</span>const&nbsp;buf&nbsp;=&nbsp;zip_o.generate({<br/>
						<span class="class___tab">&#9;</span><span class="class___tab">&#9;</span>type&nbsp;:&nbsp;'nodebuffer'<br/>
						<span class="class___tab">&#9;</span>});<br/>
						<span class="class___tab">&#9;</span>fs.writeFileSync('./output.docx',&nbsp;buf);<br/>
						}&nbsp;catch&nbsp;(e)&nbsp;{<br/>
						<span class="class___tab">&#9;</span>console.log(e);<br/>
						}<br/>
					</div>
					运行代码生成文件名称为output.docx的结果文件如下图:
					<br/>
					<img target="_blank" src="./refs/docxtemplater/docxtemplater_word_result.png"/>
					<br/>
					browser client
					<br/>
					<a target="_blank" href="./refs/docxtemplater/word.tar.xz">示例代码</a>
					<br/>
					<a href="https://github.com/Ziv-Barber/officegen">officegen</a> is Creating Office Open XML files (Word, Excel and Powerpoint) for Microsoft Office 2007 and later without external tools, just pure Javascript. officegen should work on any environment that supports Node.js including Linux, OSX and Windows. officegen also supporting PowerPoint native charts objects with embedded data.
					<br/>
					<a target="_blank" href="refs/officegen/officegen-master.zip">officegen源代码</a>
				</div>
			</section>
			<section>
				<h3>echarts</h3>
				<div>
					echarts 4.7.0 用npm或cnpm安装后或是从github源码中有一个map文件夹, 里面是地图文件其中的china.json是中国地图文件
				</div>
			</section>
			<section>
				<h3>npm安装包</h3>
				<div>
					国内访问外网都很慢，甚至不能访问！安装Node时自带的npm地址默认是http://registry.npmjs.org, npm install没反应！
					<br/>
					用cnpm代替npm安装并使用国内的镜像库https://registry.npm.taobao.org
					<br/>
					<span class="shell_instruction">npm install cnpm -g --registry=https://registry.npm.taobao.org</span>
				</div>
			</section>
		</article>
	</body>
</html>
