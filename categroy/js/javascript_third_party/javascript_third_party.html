<!doctype html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0,minimum-scale=1.0,user-scalable=0" />
		<title>third party js</title>
		<style>
			.class___line_head {
				margin-left : 2em;
			}
			.class___code {
				color : yellow;
				background-color : black;
				line-height : 24px;
				font-size : 18px;
				vertical-align : bottom;
				white-space : nowrap;
				overflow-x : auto;
			}
			.class___tab {
				display : inline-block;
				width : 4ex;
				overflow-x : hidden;
				line-height : 24px;
				font-size : 18px;
				vertical-align : bottom;
				white-space : pre-wrap;
			}
			.class___code_last_line {
				display : inline-block;
				white-space : nowrap;
			}
			.shell_instruction {
				color : yellow;
				background-color : black;
				font-weight : 800;
				padding : 4px;
			}
			section {
				margin-top : 60px;
			}
			section > div {
				padding-left : 2em;
				line-height : 180%;
			}
			#id___textarea___input_source_code {
				height : 100px;
				width : calc(100% - 6px);
				margin-bottom : 10px;
			}
			#id___textarea___output_html_code {
				height : 100px;
				width : calc(100% - 6px);
				margin-top : 10px;
			}
		</style>
		<style>
			#id___protptype_chain .class___prototype_chain__grid__item {
				width : 500px;
				display : grid;
				grid-template-columns : 20px 460px 20px;
				border : 1px solid black;
				text-align : center;
				position : absolute
			}
			#id___protptype_chain .class___prototype_chain__grid__item div {
				overflow-x : auto;
				border : 1px solid black;
				white-space : nowrap;
			}
			#id___protptype_chain .class___prototype_chain__grid__function {
				color : green;
				border-color : green;
			}
			#id___protptype_chain .class___prototype_chain__grid__function div {
				border-color : green;
			}
		</style>
		<script>
			convert_code_to_html = () => {
				let source = document.getElementById('id___textarea___input_source_code');
				let target = document.getElementById('id___textarea___output_html_code');
				let s = source.value;
				//console.log(s);
				s = s.trim();
				s = s.replace(/\r/g, '');
				s = s.replace(/&/g, '&amp;');
				s = s.replace(/ /g, '&nbsp;');
				s = s.replace(/>/g, '&gt;');
				s = s.replace(/</g, '&lt;');
				s = s.replace(/\t/g, '<span class="class___tab">&#9;</span>');
				s = s.replace(/\n/g, '<br/>\n');
				s = s.replace(/\n/g, '\n\t');
				s += '<br/>';
				//console.log(s);
				target.value = '<div class="class___code">\n\t' + s + '\n</div>';
			}
			window.onload = (e) => {
				let button = document.getElementById('id___button___convert_code_to_html');
				//console.log(button);
				button.addEventListener('click', convert_code_to_html, false);
			}
		</script>
	</head>
	<body>
		<article>
			<header>
				<h3>javascript third party</h3>
				<p>
					//
				</p>
			</header>
			<section>
				<h3>代码转换</h3>
				<div>
					<textarea id="id___textarea___input_source_code"></textarea>
					<br/>
					<button id="id___button___convert_code_to_html">轉換</button>
					<br/>
					<textarea id="id___textarea___output_html_code"></textarea>
				</div>
			</section>
			<section>
				<h3>vscode</h3>
				<div>
					linux环境下在vscode中调试nodejs代码时若打开的路径是用软链接时会导致断点无法绑定(Breakpoint set but not yet bound)
					<br/>
					例如:
					<br/>
					代码文件夹的真实路径为:~/true_path/code/nodejs_code
					<br/>
					~/soft_link -&gt; ~/true_path/code/nodejs_code
					<br/>
					在vscode中打开~/soft_link文件夹则会导致断点无法绑定
				</div>
			</section>
			<section>
				<h3>webpack</h3>
				<div>
					在webpack 4.42.1版本中json文件不需要在配置文件中配置loader, 直接使用就可, 若配置了loader则会报错
				</div>
			</section>
			<section>
				<h3>microsoft office</h3>
				<div>
					docxtemplater is a library to generate docx/pptx documents from a docx/pptx template. It can replace {placeholders} with data and also supports loops and conditions. The templates can be edited by non-programmers, for example your clients.
					<br/>
					docxtemplater 支持node.js端和浏览器端根据word文件模板替换{placeholders}形式的占位符生成新的word文件, ppt亦同
					<br/>
					npm : <a target="_blank" href="https://www.npmjs.com/package/docxtemplater">https://www.npmjs.com/package/docxtemplater</a>
					<br/>
					github : <a target="_blank" href="https://github.com/open-xml-templating/docxtemplater">https://github.com/open-xml-templating/docxtemplater</a>
					<br/>
					网址1: <a target="_blank" href="https://docxtemplater.com/">https://docxtemplater.com/</a>
					<br/>
					document: <a target="_blank" href="https://docxtemplater.readthedocs.io/en/latest/generate.html">https://docxtemplater.readthedocs.io/en/latest/generate.html</a>
					<br/>
					<a target="_blank" href="./refs/docxtemplater/docxtemplater-master.zip">docxtemplater源代码</a>
					<br/>
					<br/>
					nodejs端先安装
					<br/>
					<span class="shell_instruction">cnpm install --save docxtemplater pizzip</span>
					<br/>
					编写word模板文档, 打开word输入内容, 并设置好格式, 如图:
					<br/>
					<img target="_blank" src="./refs/docxtemplater/docxtemplater_word_template_file.png"/>
					<br/>
					其中的{name}是一个占位符, 占位符的名称是"name", 后面生成的文件{name}会被整个替换, {value}相似
					<br/>
					编写代码:
					<div class="class___code">
						const&nbsp;fs&nbsp;=&nbsp;require('fs');<br/>
						const&nbsp;path&nbsp;=&nbsp;require('path');<br/>
						<br/>
						const&nbsp;PizZip&nbsp;=&nbsp;require('pizzip');<br/>
						const&nbsp;Docxtemplater&nbsp;=&nbsp;require('docxtemplater');<br/>
						<br/>
						try&nbsp;{<br/>
						<span class="class___tab">&#9;</span>let&nbsp;content&nbsp;=&nbsp;fs.readFileSync('./test.docx');<br/>
						<br/>
						<span class="class___tab">&#9;</span>const&nbsp;zip_i&nbsp;=&nbsp;new&nbsp;PizZip(content);<br/>
						<br/>
						<span class="class___tab">&#9;</span>let&nbsp;doc&nbsp;=&nbsp;new&nbsp;Docxtemplater(zip_i);<br/>
						<span class="class___tab">&#9;</span>doc.setData({<br/>
						<span class="class___tab">&#9;</span><span class="class___tab">&#9;</span>name&nbsp;:&nbsp;'测试用名称',<br/>
						<span class="class___tab">&#9;</span><span class="class___tab">&#9;</span>value&nbsp;:&nbsp;'test value'<br/>
						<span class="class___tab">&#9;</span>});<br/>
						<span class="class___tab">&#9;</span>doc.render();<br/>
						<span class="class___tab">&#9;</span>const&nbsp;zip_o&nbsp;=&nbsp;doc.getZip();<br/>
						<span class="class___tab">&#9;</span>const&nbsp;buf&nbsp;=&nbsp;zip_o.generate({<br/>
						<span class="class___tab">&#9;</span><span class="class___tab">&#9;</span>type&nbsp;:&nbsp;'nodebuffer'<br/>
						<span class="class___tab">&#9;</span>});<br/>
						<span class="class___tab">&#9;</span>fs.writeFileSync('./output.docx',&nbsp;buf);<br/>
						}&nbsp;catch&nbsp;(e)&nbsp;{<br/>
						<span class="class___tab">&#9;</span>console.log(e);<br/>
						}<br/>
					</div>
					运行代码生成文件名称为output.docx的结果文件如下图:
					<br/>
					<img target="_blank" src="./refs/docxtemplater/docxtemplater_word_result.png"/>
					<br/>
					browser client
					<br/>
					<a target="_blank" href="./refs/docxtemplater/word.tar.xz">示例代码</a>
					<br/>
					<a href="https://github.com/Ziv-Barber/officegen">officegen</a> is Creating Office Open XML files (Word, Excel and Powerpoint) for Microsoft Office 2007 and later without external tools, just pure Javascript. officegen should work on any environment that supports Node.js including Linux, OSX and Windows. officegen also supporting PowerPoint native charts objects with embedded data.
					<br/>
					<a target="_blank" href="refs/officegen/officegen-master.zip">officegen源代码</a>
				</div>
			</section>
			<section>
				<h3>echarts</h3>
				<div>
					echarts 4.7.0 用npm或cnpm安装后或是从github源码中有一个map文件夹, 里面是地图文件其中的china.json是中国地图文件
				</div>
			</section>
			<section>
				<h3>npm安装包</h3>
				<div>
					国内访问外网都很慢，甚至不能访问！安装Node时自带的npm地址默认是http://registry.npmjs.org, npm install没反应！
					<br/>
					用cnpm代替npm安装并使用国内的镜像库https://registry.npm.taobao.org
					<br/>
					<span class="shell_instruction">npm install cnpm -g --registry=https://registry.npm.taobao.org</span>
				</div>
			</section>
		</article>
	</body>
</html>
